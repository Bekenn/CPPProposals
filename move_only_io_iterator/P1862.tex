\documentclass{wg21}

\usepackage{xcolor}
\usepackage{soul}
\usepackage{ulem}
\usepackage{fullpage}
\usepackage{parskip}
\usepackage{csquotes}
\usepackage{relsize}      % provide relative font size changes
\usepackage{textcomp}     % provide \text{l,r}angle
\usepackage{mathrsfs}     % mathscr font

\title{Ranges adaptors for non-copyable iterators}
\docnumber{D1862R1}
\audience{LEWG, LWG}
\author{Corentin Jabot}{corentin.jabot@gmail.com}
\authortwo{Casey Carter}{Casey@Carter.net}

%\usepackage[inner=2cm,outer=2cm]{geometry}

\begin{document}
\maketitle


\hypertarget{introduction}{%
	\section{Introduction}\label{introduction}}


This paper is an addendum. to P1207 and add support where possible to the iterators of the views introduced by
The one range proposal as well as P1035, with the apologies of the author for the tardiness of that work.

\section{Points of design}

Views and adaptors constructed from iterators (whether that is two iterators, an iterator and an index or an iterator and a sentinel) need to store these iterators - which would subsequently need to be copied by calls to \tcode{begin()}.

Note that because iterating over a container does not invalidate the storage, all sensible ranges with non-copyable iterators are views.


All other views support move-only iterators (with the exception of reverse view which require bidirectional iterators).

Caching of move-only iterators is not supported either, which is sensible given single-pass iterators are invalided by reading from the range.
\newpage
\subsection{\tcode{views::counted} and \tcode{subrange}}

Unlike other views, \tcode{subrange} does store the begin iterator.
We therefore have two options in the C++20 time frame:

\begin{itemize}
\item Require copyability for \tcode{subrange}, and adapt \tcode{views::counted} at a later date to be constructed from a range rather than an iterator, therefore bypassing the need for a copy in the \tcode{begin} call.

\begin{note}
Neither \tcode{subrange} nor \tcode{views::counted} are necessary to implement other standard views and algorithms operating on non forward iterators and ranges.
\end{note}

\item Move the iterator in the call to \tcode{begin()} in \tcode{views::subrange}.
This is a simple change but requires the adoption of \cite{P1456}.


\begin{note}
	In the general case, it is not guaranteed that the iterators returned by two successive calls to \tcode{begin} will be usable.
	(In all cases, dereferencing one of these iterator after the other has been incremented is undefined behavior).

	So moving the iterator out if the view is in this case reasonable.
\end{note}

There is also the question of whether \tcode{subrange::begin} should be const for non-copyable iterators.
Constness is necessary to satisfy the requirements of \emph{simple-view}, but this would require the iterator to be mutable and to mutate it in a const method...
The author prefers \tcode{subrange::begin} to be non-const if the iterator is not copyable and so in this case
\tcode{subrange} would not satisfy the requirements of \emph{simple-view}.


\added{The provided wording for this second option as approved by LEWG.}

\end{itemize}

\section{Implementation}

This proposal has been implemented in cmcstl2.

\section{Acknowledgments}

Many thanks to Eric Niebler, Casey Carter, Christopher Di Bella and Tristan Brindle for
reviewing this work and providing valuable feedback.

\section{Wording}


\rSec1[ranges.syn]{Header \tcode{<ranges>} synopsis}

\indexlibrary{\idxhdr{ranges}}%
\begin{codeblock}
#include <initializer_list>
#include <iterator>

namespace std::ranges {
	inline namespace @\unspec@ {
		// \ref{range.access}, range access
		inline constexpr @\unspec@ begin = @\unspec@;
		inline constexpr @\unspec@ end = @\unspec@;
		inline constexpr @\unspec@ cbegin = @\unspec@;
		inline constexpr @\unspec@ cend = @\unspec@;
		inline constexpr @\unspec@ rbegin = @\unspec@;
		inline constexpr @\unspec@ rend = @\unspec@;
		inline constexpr @\unspec@ crbegin = @\unspec@;
		inline constexpr @\unspec@ crend = @\unspec@;

		inline constexpr @\unspec@ size = @\unspec@;
		inline constexpr @\unspec@ empty = @\unspec@;
		inline constexpr @\unspec@ data = @\unspec@;
		inline constexpr @\unspec@ cdata = @\unspec@;
	}

	// \ref{range.range}, ranges
	template<class T>
	concept range = @\seebelow@;

	template<range R>
	using iterator_t = decltype(ranges::begin(declval<R&>()));
	template<range R>
	using sentinel_t = decltype(ranges::end(declval<R&>()));
	template<range R>
	using range_difference_t = iter_difference_t<iterator_t<R>>;
	template<range R>
	using range_value_t = iter_value_t<iterator_t<R>>;
	template<range R>
	using range_reference_t = iter_reference_t<iterator_t<R>>;
	template<range R>
	using range_rvalue_reference_t = iter_rvalue_reference_t<iterator_t<R>>;

	// \ref{range.sized}, sized ranges
	template<class>
	inline constexpr bool disable_sized_range = false;

	template<class T>
	concept sized_range = @\seebelow@;

	// \ref{range.view}, views
	template<class T>
	inline constexpr bool enable_view = @\seebelow@;

	struct view_base { };

	template<class T>
	concept view = @\seebelow@;

	// \ref{range.refinements}, other range refinements
	template<class R, class T>
	concept output_range = @\seebelow@;

	template<class T>
	concept input_range = @\seebelow@;

	template<class T>
	concept forward_range = @\seebelow@;

	template<class T>
	concept bidirectional_range = @\seebelow@;

	template<class T>
	concept random_access_range = @\seebelow@;

	template<class T>
	concept contiguous_range = @\seebelow@;

	template<class T>
	concept common_range = @\seebelow@;

	template<class T>
	concept viewable_range = @\seebelow@;

	// \ref{view.interface}, class template \tcode{view_interface}
	template<class D>
	requires is_class_v<D> && same_as<D, remove_cv_t<D>>
	class view_interface;

	// \ref{range.subrange}, sub-ranges
	enum class subrange_kind : bool { unsized, sized };

	template<input_or_output_iterator I, sentinel_for<I> S = I, subrange_kind K = @\seebelow@>
	requires (K == subrange_kind::sized || !sized_sentinel_for<S, I>)
	class subrange;

	// \ref{range.dangling}, dangling iterator handling
	struct dangling;

	template<range R>
	using safe_iterator_t = conditional_t<@\placeholder{forwarding-range}@<R>, iterator_t<R>, dangling>;

	template<range R>
	using safe_subrange_t =
	conditional_t<@\placeholder{forwarding-range}@<R>, subrange<iterator_t<R>>, dangling>;

	// \ref{range.empty}, empty view
	template<class T>
	requires is_object_v<T>
	class empty_view;

	namespace views {
		template<class T>
		inline constexpr empty_view<T> empty{};
	}

	// \ref{range.single}, single view
	template<copy_constructible T>
	requires is_object_v<T>
	class single_view;

	namespace views { inline constexpr @\unspec@ single = @\unspec@; }

	// \ref{range.iota}, iota view
	template<weakly_incrementable W, semiregular Bound = unreachable_sentinel_t>
	requires @\placeholder{weakly-equality-comparable-with}@<W, Bound>
	class iota_view;

	namespace views { inline constexpr @\unspec@ iota = @\unspec@; }

	// \ref{range.all}, all view
	namespace views { inline constexpr @\unspec@ all = @\unspec@; }

	template<viewable_range R>
	using all_view = decltype(views::all(declval<R>()));

	template<range R>
	requires is_object_v<R>
	class ref_view;

	// \ref{range.filter}, filter view
	template<input_range V, indirect_unary_predicate<iterator_t<V>> Pred>
	requires view<V> && is_object_v<Pred>
	class filter_view;

	namespace views { inline constexpr @\unspec@ filter = @\unspec@; }

	// \ref{range.transform}, transform view
	template<input_range V, copy_constructible F>
	requires view<V> && is_object_v<F> &&
	regular_invocable<F&, range_reference_t<V>>
	class transform_view;

	namespace views { inline constexpr @\unspec@ transform = @\unspec@; }

	// \ref{range.take}, take view
	template<view> class take_view;

	namespace views { inline constexpr @\unspec@ take = @\unspec@; }

	// \ref{range.take.while}, take while view
	template<view R, class Pred>
	requires input_range<R> && is_object_v<Pred> &&
	indirect_unary_predicate<const Pred, iterator_t<R>>
	class take_while_view;

	namespace views { inline constexpr @\unspec@ take_while = @\unspec@; }

	// \ref{range.drop}, drop view
	template<view R>
	class drop_view;

	namespace views { inline constexpr @\unspec@ drop = @\unspec@; }

	// \ref{range.drop.while}, drop while view
	template<view R, class Pred>
	requires input_range<R> && is_object_v<Pred> &&
	indirect_unary_predicate<const Pred, iterator_t<R>>
	class drop_while_view;

	namespace views { inline constexpr @\unspec@ drop_while = @\unspec@; }

	// \ref{range.join}, join view
	template<input_range V>
	requires view<V> && input_range<range_reference_t<V>> &&
	(is_reference_v<range_reference_t<V>> ||
	view<range_value_t<V>>)
	class join_view;

	namespace views { inline constexpr @\unspec@ join = @\unspec@; }

	// \ref{range.split}, split view
	template<class R>
	concept @\placeholder{tiny-range}@ = @\seebelow@;   // \expos

	template<input_range V, forward_range Pattern>
	requires view<V> && view<Pattern> &&
	indirectly_comparable<iterator_t<V>, iterator_t<Pattern>, ranges::equal_to> &&
	(forward_range<V> || @\placeholder{tiny-range}@<Pattern>)
	class split_view;

	namespace views { inline constexpr @\unspec@ split = @\unspec@; }

	// \ref{range.counted}, counted view
	namespace views { inline constexpr @\unspec@ counted = @\unspec@; }

	// \ref{range.common}, common view
	template<view V>
	requires (!common_range<V> @\added{\&\& copyable<iterator_t<V>>}@)
	class common_view;

	namespace views { inline constexpr @\unspec@ common = @\unspec@; }

	// \ref{range.reverse}, reverse view
	template<view V>
	requires bidirectional_range<V>
	class reverse_view;

	namespace views { inline constexpr @\unspec@ reverse = @\unspec@; }

	// \ref{range.istream}, istream view
	template<movable Val, class CharT, class Traits = char_traits<CharT>>
	requires @\seebelow@
	class basic_istream_view;
	template<class Val, class CharT, class Traits>
	basic_istream_view<Val, CharT, Traits> istream_view(basic_istream<CharT, Traits>& s);

	// \ref{range.elements}, elements view
	template<input_range R, size_t N>
	requires @\seebelow@;
	class elements_view;

	template<class R>
	using keys_view = elements_view<all_view<R>, 0>;
	template<class R>
	using values_view = elements_view<all_view<R>, 1>;

	namespace views {
		template<size_t N>
		inline constexpr @\unspec@ elements = @\unspec@ ;
		inline constexpr @\unspec@ keys = @\unspec@ ;
		inline constexpr @\unspec@ values = @\unspec@ ;
	}
}
\end{codeblock}


\rSec2[range.subrange]{Sub-ranges}

\pnum
The \tcode{subrange} class template combines together an
iterator and a sentinel into a single object that models the
\libconcept{view} concept. Additionally, it models the
\libconcept{sized_range} concept when the final template parameter is
\tcode{subrange_kind::sized}.

\begin{codeblock}
	namespace std::ranges {
		template<class T>
		concept @\placeholder{pair-like}@ =                                    // \expos
		!is_reference_v<T> && requires(T t) {
			typename tuple_size<T>::type;   // ensures \tcode{tuple_size<T>} is complete
			requires derived_from<tuple_size<T>, integral_constant<size_t, 2>>;
			typename tuple_element_t<0, remove_const_t<T>>;
			typename tuple_element_t<1, remove_const_t<T>>;
			{ get<0>(t) } -> convertible_to<const tuple_element_t<0, T>&>;
			{ get<1>(t) } -> convertible_to<const tuple_element_t<1, T>&>;
		};

		template<class T, class U, class V>
		concept @\placeholder{pair-like-convertible-to}@ =                     // \expos
		!range<T> && @\placeholder{pair-like}@<remove_reference_t<T>> &&
		requires(T&& t) {
			{ get<0>(std::forward<T>(t)) } -> convertible_to<U>;
			{ get<1>(std::forward<T>(t)) } -> convertible_to<V>;
		};

		template<class T, class U, class V>
		concept @\placeholder{pair-like-convertible-from}@ =                   // \expos
		!range<T> && @\placeholder{pair-like}@<T> && constructible_from<T, U, V>;

		template<class T>
		concept @\placeholder{iterator-sentinel-pair}@ =                       // \expos
		!range<T> && @\placeholder{pair-like}@<T> &&
		sentinel_for<tuple_element_t<1, T>, tuple_element_t<0, T>>;

		template<input_or_output_iterator I, sentinel_for<I> S = I, subrange_kind K =
		sized_sentinel_for<S, I> ? subrange_kind::sized : subrange_kind::unsized>
		requires (K == subrange_kind::sized || !sized_sentinel_for<S, I>)
		class subrange : public view_interface<subrange<I, S, K>> {
			private:
			static constexpr bool StoreSize =                      // \expos
			K == subrange_kind::sized && !sized_sentinel_for<S, I>;
			I begin_ = I();                                        // \expos
			S end_ = S();                                          // \expos
			@\placeholdernc{make-unsigned-like-t}@(iter_difference_t<I>) size_ = 0;  // \expos; present only
			// when \tcode{StoreSize} is \tcode{true}
			public:
			subrange() = default;

			constexpr subrange(I i, S s) requires (!StoreSize);

			constexpr subrange(I i, S s, @\placeholdernc{make-unsigned-like-t}@(iter_difference_t<I>) n)
			requires (K == subrange_kind::sized);

			template<@\placeholder{not-same-as}@<subrange> R>
			requires @\placeholder{forwarding-range}@<R> &&
			convertible_to<iterator_t<R>, I> && convertible_to<sentinel_t<R>, S>
			constexpr subrange(R&& r) requires (!StoreSize || sized_range<R>);

			template<@\placeholder{forwarding-range}@ R>
			requires convertible_to<iterator_t<R>, I> && convertible_to<sentinel_t<R>, S>
			constexpr subrange(R&& r, @\placeholder{make-unsigned-like-t}@(iter_difference_t<I>) n)
			requires (K == subrange_kind::sized)
			: subrange{ranges::begin(r), ranges::end(r), n}
			{}

			template<@\placeholder{not-same-as}@<subrange> PairLike>
			requires @\placeholder{pair-like-convertible-to}@<PairLike, I, S>
			constexpr subrange(PairLike&& r) requires (!StoreSize)
			: subrange{std::get<0>(std::forward<PairLike>(r)),
				std::get<1>(std::forward<PairLike>(r))}
			{}

			template<@\placeholder{pair-like-convertible-to}@<I, S> PairLike>
			constexpr subrange(PairLike&& r, @\placeholder{make-unsigned-like-t}@(iter_difference_t<I>) n)
			requires (K == subrange_kind::sized)
			: subrange{std::get<0>(std::forward<PairLike>(r)),
				std::get<1>(std::forward<PairLike>(r)), n}
			{}

			template<@\placeholder{not-same-as}@<subrange> PairLike>
			requires @\placeholder{pair-like-convertible-from}@<PairLike, const I&, const S&>
			constexpr operator PairLike() const;

			constexpr I begin() const @\added{requires copyable<I>}@;
			@\added{[[nodiscard]] constexpr I begin() requires (!copyable<I>)}@;
			constexpr S end() const;

			constexpr bool empty() const;
			constexpr @\placeholder{make-unsigned-like-t}@(iter_difference_t<I>) size() const
			requires (K == subrange_kind::sized);

			[[nodiscard]] constexpr subrange next(iter_difference_t<I> n = 1) const
			@\added{\& requires forward_iterator<I>}@;
			@\added{[[nodiscard]] constexpr subrange next(iter_difference_t<I> n = 1) \&\&;}@

			[[nodiscard]] constexpr subrange prev(iter_difference_t<I> n = 1) const
			requires bidirectional_iterator<I>;
			constexpr subrange& advance(iter_difference_t<I> n);

			friend constexpr I begin(subrange&& r) { return r.begin(); }
			friend constexpr S end(subrange&& r) { return r.end(); }
		};

		template<input_or_output_iterator I, sentinel_for<I> S>
		subrange(I, S, @\placeholdernc{make-unsigned-like-t}@(iter_difference_t<I>)) ->
		subrange<I, S, subrange_kind::sized>;

		template<@\placeholder{iterator-sentinel-pair}@ P>
		subrange(P) -> subrange<tuple_element_t<0, P>, tuple_element_t<1, P>>;

		template<@\placeholder{iterator-sentinel-pair}@ P>
		subrange(P, @\placeholdernc{make-unsigned-like-t}@(iter_difference_t<tuple_element_t<0, P>>)) ->
		subrange<tuple_element_t<0, P>, tuple_element_t<1, P>, subrange_kind::sized>;

		template<@\placeholder{forwarding-range}@ R>
		subrange(R&&) ->
		subrange<iterator_t<R>, sentinel_t<R>,
		(sized_range<R> || sized_sentinel_for<sentinel_t<R>, iterator_t<R>>)
		? subrange_kind::sized : subrange_kind::unsized>;

		template<@\placeholder{forwarding-range}@ R>
		subrange(R&&, @\placeholdernc{make-unsigned-like-t}@(range_difference_t<R>)) ->
		subrange<iterator_t<R>, sentinel_t<R>, subrange_kind::sized>;

		template<size_t N, class I, class S, subrange_kind K>
		requires (N < 2)
		constexpr auto get(const subrange<I, S, K>& r);

		@\added{template<size_t N, class I, class S, subrange_kind K>}@
		@\added{requires (N < 2)}@
		@\added{constexpr auto get(subrange<I, S, K>\&\& r);}@
	}

	namespace std {
		using ranges::get;
	}
\end{codeblock}

\rSec3[range.subrange.ctor]{Constructors and conversions}

\indexlibrarymember{subrange}{subrange}%
\begin{itemdecl}
	constexpr subrange(I i, S s) requires (!StoreSize);
\end{itemdecl}

\begin{itemdescr}
	\pnum
	\expects
	\range{i}{s} is a valid range.

	\pnum
	\effects
	Initializes \tcode{begin_} with \tcode{\changed{i}{std::move(i)}} and \tcode{end_} with
	\tcode{s}.
\end{itemdescr}

\indexlibrarymember{subrange}{subrange}%
\begin{itemdecl}
	constexpr subrange(I i, S s, @\placeholdernc{make-unsigned-like-t}@(iter_difference_t<I>) n)
	requires (K == subrange_kind::sized);
\end{itemdecl}

\begin{itemdescr}
	\pnum
	\expects
	\range{i}{s} is a valid range, and
	\tcode{n == \placeholdernc{make-unsigned-like}(ranges::distance(i, s))}.

	\pnum
	\effects
	Initializes \tcode{begin_} with \tcode{\changed{i}{std::move(i)}} and \tcode{end_} with
	\tcode{s}. If \tcode{StoreSize} is \tcode{true}, initializes \tcode{size_} with
	\tcode{n}.

	\pnum
	\begin{note}
		Accepting the length of the range and storing it to later return  from
		\tcode{size()} enables \tcode{subrange} to model \libconcept{sized_range} even
		when it stores an iterator and sentinel that do not model
		\libconcept{sized_sentinel_for}.
	\end{note}
\end{itemdescr}

\indexlibrarymember{subrange}{subrange}%
\begin{itemdecl}
	template<@\expos{not-same-as}@<subrange> R>
	requires @\expos{forwarding-range}@<R> &&
	convertible_to<iterator_t<R>, I> && convertible_to<sentinel_t<R>, S>
	constexpr subrange(R&& r) requires (!StoreSize || sized_range<R>);
\end{itemdecl}

\begin{itemdescr}
	\pnum
	\effects
	Equivalent to:
	\begin{itemize}
		\item If \tcode{StoreSize} is \tcode{true},
		\tcode{subrange\{ranges::begin(r), ranges::end(r), ranges::size(r)\}}.
		\item Otherwise, \tcode{subrange\{ranges::begin(r), ranges::end(r)\}}.
	\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{operator \placeholder{PairLike}}!\idxcode{subrange}}%
\begin{itemdecl}
	template<@\expos{not-same-as}@<subrange> PairLike>
	requires @\expos{pair-like-convertible-from}@<PairLike, const I&, const S&>
	constexpr operator PairLike() const;
\end{itemdecl}

\begin{itemdescr}
	\pnum
	\effects
	Equivalent to: \tcode{return PairLike(begin_, end_);}
\end{itemdescr}

\rSec3[range.subrange.access]{Accessors}

\indexlibrarymember{begin}{subrange}%
\begin{itemdecl}
	constexpr I begin() const @\added{requires copyable<I>}@;
\end{itemdecl}

\begin{itemdescr}
	\pnum
	\effects
	Equivalent to: \tcode{return begin_;}
\end{itemdescr}

\begin{addedblock}
\indexlibrarymember{begin}{subrange}%
\begin{itemdecl}
	constexpr I begin() requires (!copyable<I>)@;
\end{itemdecl}

\begin{itemdescr}
	\pnum
	\effects
	Equivalent to: \tcode{return std::move(begin_);}
\end{itemdescr}
\end{addedblock}

\indexlibrarymember{end}{subrange}%
\begin{itemdecl}
	constexpr S end() const;
\end{itemdecl}

\begin{itemdescr}
	\pnum
	\effects
	Equivalent to: \tcode{return end_;}
\end{itemdescr}

\indexlibrarymember{empty}{subrange}%
\begin{itemdecl}
	constexpr bool empty() const;
\end{itemdecl}

\begin{itemdescr}
	\pnum
	\effects
	Equivalent to: \tcode{return begin_ == end_;}
\end{itemdescr}

\indexlibrarymember{size}{subrange}%
\begin{itemdecl}
	constexpr @\placeholdernc{make-unsigned-like-t}@(iter_difference_t<I>) size() const
	requires (K == subrange_kind::sized);
\end{itemdecl}

\begin{itemdescr}
	\pnum
	\effects
	\begin{itemize}
		\item If \tcode{StoreSize} is \tcode{true}, equivalent to: \tcode{return size_;}
		\item Otherwise, equivalent to: \tcode{return \placeholdernc{make-unsigned-like-t}(end_ - begin_);}
	\end{itemize}
\end{itemdescr}

\indexlibrarymember{next}{subrange}%
\begin{itemdecl}
	[[nodiscard]] constexpr subrange next(iter_difference_t<I> n = 1) const
	@\added{\& requires forward_iterator<I>}@;
\end{itemdecl}

\begin{itemdescr}
	\pnum
	\effects
	Equivalent to:
	\begin{codeblock}
		auto tmp = *this;
		tmp.advance(n);
		return tmp;
	\end{codeblock}

	\pnum
	\begin{removedblock}
	\begin{note}
		If \tcode{I} does not model \libconcept{forward_iterator}, \tcode{next}
		can invalidate \tcode{*this}.
	\end{note}
\end{removedblock}
\end{itemdescr}

\begin{addedblock}
\indexlibrarymember{next}{subrange}%
\begin{itemdecl}
	[[nodiscard]] constexpr subrange next(iter_difference_t<I> n = 1) &&;
\end{itemdecl}

\begin{itemdescr}
	\pnum
	\effects
	Equivalent to:
	\begin{codeblock}
		advance(n);
		return std::move(*this);
	\end{codeblock}
\end{itemdescr}
\end{addedblock}


\indexlibrarymember{prev}{subrange}%
\begin{itemdecl}
	[[nodiscard]] constexpr subrange prev(iter_difference_t<I> n = 1) const
	requires bidirectional_iterator<I>;
\end{itemdecl}

\begin{itemdescr}
	\pnum
	\effects
	Equivalent to:
	\begin{codeblock}
		auto tmp = *this;
		tmp.advance(-n);
		return tmp;
	\end{codeblock}
\end{itemdescr}

\indexlibrarymember{advance}{subrange}%
\begin{itemdecl}
	constexpr subrange& advance(iter_difference_t<I> n);
\end{itemdecl}

\begin{itemdescr}
	\pnum
	\effects
	Equivalent to:
	\begin{itemize}
		\item If \tcode{StoreSize} is \tcode{true},
		\begin{codeblock}
			auto d = n - ranges::advance(begin_, n, end_);
			if (d >= 0)
			size_ -= @\placeholdernc{make-unsigned-like}@(d);
			else
			size_ += @\placeholdernc{make-unsigned-like}@(-d);
			return *this;
		\end{codeblock}
		\item Otherwise,
		\begin{codeblock}
			ranges::advance(begin_, n, end_);
			return *this;
		\end{codeblock}
	\end{itemize}
\end{itemdescr}

\indexlibrarymember{get}{subrange}%
\begin{itemdecl}
	template<size_t N, class I, class S, subrange_kind K>
	requires (N < 2)
	constexpr auto get(const subrange<I, S, K>& r);
\end{itemdecl}
\begin{addedblock}
\indexlibrarymember{get}{subrange}%
\begin{itemdecl}
	template<size_t N, class I, class S, subrange_kind K>
	requires (N < 2)
	constexpr auto get(subrange<I, S, K>&& r);
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
	\pnum
	\effects
	Equivalent to:
	\begin{codeblock}
		if constexpr (N == 0)
		return r.begin();
		else
		return r.end();
	\end{codeblock}
\end{itemdescr}



\rSec1[range.adaptors]{Range adaptors}

...


\rSec2[range.filter]{Filter view}

\rSec3[range.filter.overview]{Overview}

\pnum
\tcode{filter_view} presents a \libconcept{view} of an underlying sequence
without the elements that fail to satisfy a predicate.

\pnum
\begin{example}
\begin{codeblock}
vector<int> is{ 0, 1, 2, 3, 4, 5, 6 };
filter_view evens{is, [](int i) { return 0 == i % 2; }};
	for (int i : evens)
	cout << i << ' '; // prints: 0 2 4 6
\end{codeblock}

\end{example}

\rSec3[range.filter.view]{Class template \tcode{filter_view}}

\begin{codeblock}
namespace std::ranges {
	template<input_range V, indirect_unary_predicate<iterator_t<V>> Pred>
	requires view<V> && is_object_v<Pred>
	class filter_view : public view_interface<filter_view<V, Pred>> {
		private:
		V base_ = V();                // \expos
		@\placeholdernc{semiregular-box}@<Pred> pred_;  // \expos

		// \ref{range.filter.iterator}, class \tcode{filter_view::iterator}
		class iterator;               // \expos
		// \ref{range.filter.sentinel}, class \tcode{filter_view::sentinel}
		class sentinel;               // \expos

		public:
		filter_view() = default;
		constexpr filter_view(V base, Pred pred);
		template<input_range R>
		requires viewable_range<R> && constructible_from<V, all_view<R>>
		constexpr filter_view(R&& r, Pred pred);

		constexpr V base() const;

		constexpr iterator begin();
		constexpr auto end() {
			if constexpr (common_range<V>)
			return iterator{*this, ranges::end(base_)};
			else
			return sentinel{*this};
		}
	};

	template<class R, class Pred>
	filter_view(R&&, Pred) -> filter_view<all_view<R>, Pred>;
}
\end{codeblock}

\indexlibrary{\idxcode{filter_view}!\idxcode{filter_view}}%
\begin{itemdecl}
constexpr filter_view(V base, Pred pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{std::move(base)} and initializes
\tcode{pred_} with \tcode{std::move(pred)}.
\end{itemdescr}

\indexlibrary{\idxcode{filter_view}!\idxcode{filter_view}}%
\begin{itemdecl}
template<input_range R>
requires viewable_range<R> && constructible_from<V, all_view<R>>
constexpr filter_view(R&& r, Pred pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{views::all(std::forward<R>(r))}
and initializes \tcode{pred_} with \tcode{std::\brk{}move(pred)}.
\end{itemdescr}

\indexlibrary{\idxcode{base}!\idxcode{filter_view}}%
\begin{itemdecl}
constexpr V base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return base_;}
\end{itemdescr}

\indexlibrary{\idxcode{begin}!\idxcode{filter_view}}%
\begin{itemdecl}
constexpr iterator begin();
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{pred_.has_value()}.

\pnum
\returns
\tcode{\{*this, ranges::find_if(base_, ref(*pred_))\}}.

\pnum
\remarks In order to provide the amortized constant time complexity required by
the \libconcept{range} concept, \added{when \tcode{filter_view} models \tcode{forward_range}} this function caches the result within the
\tcode{filter_view} for use on subsequent calls.
\end{itemdescr}

\rSec3[range.filter.iterator]{Class \tcode{filter_view::iterator}}

\indexlibrary{\idxcode{iterator}!\idxcode{filter_view}}%
\begin{codeblock}
namespace std::ranges {
	template<class V, class Pred>
	class filter_view<V, Pred>::iterator {
		private:
		iterator_t<V> current_ = iterator_t<V>();   // \expos
		filter_view* parent_ = nullptr;             // \expos
		public:
		using iterator_concept  = @\seebelow@;
		using iterator_category = @\seebelow@;
		using value_type        = range_value_t<V>;
		using difference_type   = range_difference_t<V>;

		iterator() = default;
		constexpr iterator(filter_view& parent, iterator_t<V> current);

		constexpr iterator_t<V> base() const @\added{\& requires copyable<iterator_t<V>>}@;
		@\added{constexpr iterator_t<V> base() \&\&;}@
		constexpr range_reference_t<V> operator*() const;
		constexpr iterator_t<V> operator->() const
		requires @\placeholder{has-arrow}@<iterator_t<V>>;

		constexpr iterator& operator++();
		constexpr void operator++(int);
		constexpr iterator operator++(int) requires forward_range<V>;

		constexpr iterator& operator--() requires bidirectional_range<V>;
		constexpr iterator operator--(int) requires bidirectional_range<V>;

		friend constexpr bool operator==(const iterator& x, const iterator& y)
		requires equality_comparable<iterator_t<V>>;

		friend constexpr range_rvalue_reference_t<V> iter_move(const iterator& i)
		noexcept(noexcept(ranges::iter_move(i.current_)));
		friend constexpr void iter_swap(const iterator& x, const iterator& y)
		noexcept(noexcept(ranges::iter_swap(x.current_, y.current_)))
		requires indirectly_swappable<iterator_t<V>>;
	};
}
\end{codeblock}

\pnum
Modification of the element a \tcode{filter_view::iterator} denotes is
permitted, but results in undefined behavior if the resulting value does not
satisfy the filter predicate.

\pnum
\tcode{iterator::iterator_concept} is defined as follows:
\begin{itemize}
\item If \tcode{V} models \libconcept{bidirectional_range}, then
\tcode{iterator_concept} denotes \tcode{bidirectional_iterator_tag}.

\item Otherwise, if \tcode{V} models \libconcept{forward_range}, then
\tcode{iterator_concept} denotes \tcode{forward_iterator_tag}.

\item Otherwise, \tcode{iterator_concept} denotes \tcode{input_iterator_tag}.
\end{itemize}

\pnum
\tcode{iterator::iterator_category} is defined as follows:
\begin{itemize}
\item Let \tcode{C} denote the type
\tcode{iterator_traits<iterator_t<V>>::iterator_category}.

\item If \tcode{C} models
\tcode{\libconcept{derived_from}<bidirectional_iterator_tag>},
then \tcode{iterator_category} denotes \tcode{bi\-directional_iterator_tag}.

\item Otherwise, if  \tcode{C} models
\tcode{\libconcept{derived_from}<forward_iterator_tag>},
then \tcode{iterator_category} denotes \tcode{forward_iterator_tag}.

\item Otherwise, \added{if \tcode{iterator_t<V>} models \tcode{copyable}, }\tcode{iterator_category} denotes \tcode{input_iterator_tag}.

\begin{addedblock}
\item Otherwise, \tcode{iterator_category} denotes \tcode{output_iterator_tag}
\end{addedblock}
\end{itemize}

\indexlibrary{\idxcode{iterator}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr iterator(filter_view& parent, iterator_t<V> current);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{current_} with \tcode{\changed{current}{std::move(current)}} and
\tcode{parent_} with \tcode{addressof(parent)}.
\end{itemdescr}

\indexlibrary{\idxcode{base}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr iterator_t<V> base() const @\added{\& requires copyable<iterator_t<V>>}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return current_;}
\end{itemdescr}


\begin{addedblock}
\indexlibrary{\idxcode{base}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr iterator_t<V> base() &&;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return std::move(current_);}
\end{itemdescr}
\end{addedblock}


\indexlibrary{\idxcode{operator*}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr range_reference_t<V> operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return *current_;}
\end{itemdescr}

...

\rSec3[range.filter.sentinel]{Class \tcode{filter_view::sentinel}}

...


\rSec2[range.transform]{Transform view}

...

\rSec3[range.transform.iterator]{Class template \tcode{transform_view::iterator}}

\begin{codeblock}
namespace std::ranges {
	template<class V, class F>
	template<bool Const>
	class transform_view<V, F>::iterator {
		private:
		using Parent =                              // \expos
		conditional_t<Const, const transform_view, transform_view>;
		using Base   =                              // \expos
		conditional_t<Const, const V, V>;
		iterator_t<Base> current_ =                 // \expos
		iterator_t<Base>();
		Parent* parent_ = nullptr;                  // \expos
		public:
		using iterator_concept  = @\seebelow@;
		using iterator_category = @\seebelow@;
		using value_type        =
		remove_cvref_t<invoke_result_t<F&, range_reference_t<Base>>>;
		using difference_type   = range_difference_t<Base>;

		iterator() = default;
		constexpr iterator(Parent& parent, iterator_t<Base> current);
		constexpr iterator(iterator<!Const> i)
		requires Const && convertible_to<iterator_t<V>, iterator_t<Base>>;

		constexpr iterator_t<Base> base() const @\added{\& requires copyable<iterator_t<Base>>}@;
		@\added{constexpr iterator_t<Base> base() \&\&;}@

		constexpr decltype(auto) operator*() const
		{ return invoke(*parent_->fun_, *current_); }

		constexpr iterator& operator++();
		constexpr void operator++(int);
		constexpr iterator operator++(int) requires forward_range<Base>;

		constexpr iterator& operator--() requires bidirectional_range<Base>;
		constexpr iterator operator--(int) requires bidirectional_range<Base>;

		constexpr iterator& operator+=(difference_type n)
		requires random_access_range<Base>;
		constexpr iterator& operator-=(difference_type n)
		requires random_access_range<Base>;
		constexpr decltype(auto) operator[](difference_type n) const
		requires random_access_range<Base>
		{ return invoke(*parent_->fun_, current_[n]); }

		friend constexpr bool operator==(const iterator& x, const iterator& y)
		requires equality_comparable<iterator_t<Base>>;

		friend constexpr bool operator<(const iterator& x, const iterator& y)
		requires random_access_range<Base>;
		friend constexpr bool operator>(const iterator& x, const iterator& y)
		requires random_access_range<Base>;
		friend constexpr bool operator<=(const iterator& x, const iterator& y)
		requires random_access_range<Base>;
		friend constexpr bool operator>=(const iterator& x, const iterator& y)
		requires random_access_range<Base>;
		friend constexpr compare_three_way_result_t<iterator_t<Base>>
		operator<=>(const iterator& x, const iterator& y)
		requires random_access_range<Base> && three_way_comparable<iterator_t<Base>>;

		friend constexpr iterator operator+(iterator i, difference_type n)
		requires random_access_range<Base>;
		friend constexpr iterator operator+(difference_type n, iterator i)
		requires random_access_range<Base>;

		friend constexpr iterator operator-(iterator i, difference_type n)
		requires random_access_range<Base>;
		friend constexpr difference_type operator-(const iterator& x, const iterator& y)
		requires random_access_range<Base>;

		friend constexpr decltype(auto) iter_move(const iterator& i)
		noexcept(noexcept(invoke(*i.parent_->fun_, *i.current_)))
		{
			if constexpr (is_lvalue_reference_v<decltype(*i)>)
			return std::move(*i);
			else
			return *i;
		}

		friend constexpr void iter_swap(const iterator& x, const iterator& y)
		noexcept(noexcept(ranges::iter_swap(x.current_, y.current_)))
		requires indirectly_swappable<iterator_t<Base>>;
	};
}
\end{codeblock}

\pnum
\tcode{iterator::iterator_concept} is defined as follows:
\begin{itemize}
\item If \tcode{V} models \libconcept{random_access_range}, then
\tcode{iterator_concept} denotes \tcode{random_access_iterator_tag}.

\item Otherwise, if \tcode{V} models \libconcept{bidirectional_range}, then
\tcode{iterator_concept} denotes \tcode{bidirectional_iterator_tag}.

\item Otherwise, if \tcode{V} models \libconcept{forward_range}, then
\tcode{iterator_concept} denotes \tcode{forward_iterator_tag}.

\item Otherwise, \tcode{iterator_concept} denotes \tcode{input_iterator_tag}.
\end{itemize}

\pnum
Let \tcode{C} denote the type
\tcode{iterator_traits<iterator_t<Base>>::iterator_category}.
If \tcode{C} models \tcode{\libconcept{derived_from}<contiguous_iterator_tag>},
then \tcode{iterator_category} denotes
\tcode{random_access_iterator_tag}; otherwise, \tcode{iterator_category} denotes \tcode{C}.

\indexlibrary{\idxcode{iterator}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
constexpr iterator(Parent& parent, iterator_t<Base> current);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{current_} with  \tcode{\changed{current}{std::move(current)}} and
\tcode{parent_} with \tcode{addressof(parent)}.
\end{itemdescr}

\indexlibrary{\idxcode{iterator}!\idxcode{transform_view::iterator}}%
\begin{itemdecl}
constexpr iterator(iterator<!Const> i)
requires Const && convertible_to<iterator_t<V>, iterator_t<Base>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{current_} with \tcode{std::move(i.current_)} and
\tcode{parent_} with \tcode{i.parent_}.
\end{itemdescr}

\begin{itemdecl}
constexpr iterator_t<Base> base() const @\added{\& requires copyable<iterator_t<Base>>}@;
\end{itemdecl}

\begin{itemdescr}
	\pnum
	\effects Equivalent to: \tcode{return current_;}
\end{itemdescr}


\begin{addedblock}
\begin{itemdecl}
constexpr iterator_t<Base> base() &&;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return std::move(current_);}
\end{itemdescr}
\end{addedblock}




\indexlibrary{\idxcode{operator++}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
constexpr iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
	++current_;
	return *this;
\end{codeblock}
\end{itemdescr}

...

\rSec2[range.take]{Take view}

...

\rSec2[range.take.while]{Take while view}

...

\rSec3[range.drop.view]{Class template \tcode{drop_view}}

\indexlibrary{\idxcode{drop_view}}%
\begin{codeblock}
namespace std::ranges {
	template<view R>
	class drop_view : public view_interface<drop_view<R>> {
		public:
		drop_view() = default;
		constexpr drop_view(R base, range_difference_t<R> count);

		constexpr R base() const;

		constexpr auto begin()
		requires (!(@\placeholder{simple-view}@<R> && random_access_range<R>));
		constexpr auto begin() const
		requires random_access_range<const R>;

		constexpr auto end()
		requires (!@\placeholder{simple-view}@<R>)
		{ return ranges::end(base_); }

		constexpr auto end() const
		requires range<const R>
		{ return ranges::end(base_); }

		constexpr auto size()
		requires sized_range<R>
		{
			const auto s = ranges::size(base_);
			const auto c = static_cast<decltype(s)>(count_);
			return s < c ? 0 : s - c;
		}

		constexpr auto size() const
		requires sized_range<const R>
		{
			const auto s = ranges::size(base_);
			const auto c = static_cast<decltype(s)>(count_);
			return s < c ? 0 : s - c;
		}
		private:
		R base_;                                    // \expos
		range_difference_t<R> count_;               // \expos
	};

	template<class R>
	drop_view(R&&, range_difference_t<R>) -> drop_view<all_view<R>>;
}
\end{codeblock}

\indexlibrary{\idxcode{drop_view}!constructor}%
\begin{itemdecl}
constexpr drop_view(R base, range_difference_t<R> count);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{count >= 0} is \tcode{true}.

\pnum
\effects
Initializes \tcode{base_} with \tcode{std::move(base)} and
\tcode{count_} with \tcode{count}.
\end{itemdescr}

\indexlibrarymember{base}{drop_view}%
\begin{itemdecl}
constexpr R base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return base_;}
\end{itemdescr}

\indexlibrarymember{begin}{drop_view}%
\begin{itemdecl}
constexpr auto begin()
requires (!(@\placeholder{simple-view}@<R> && random_access_range<R>));
constexpr auto begin() const
requires random_access_range<const R>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{ranges::next(ranges::begin(base_), count_, ranges::end(base_))}.

\pnum
\remarks
In order to provide the amortized constant-time complexity required
by the \tcode{range} concept,
the first overload caches the result within the \tcode{drop_view}
\added{when \tcode{drop_view} models \tcode{forward_range}}
for use on subsequent calls.
\begin{note}
	Without this,
	applying a \tcode{reverse_view} over a \tcode{drop_view}
	would have quadratic iteration complexity.
\end{note}
\end{itemdescr}

\rSec3[range.drop.adaptor]{\tcode{views::drop}}

\pnum
The name \tcode{views::drop} denotes
a range adaptor object\iref{range.adaptor.object}.
For some subexpressions \tcode{E} and \tcode{F},
the expression \tcode{views::drop(E, F)}
is expression-equivalent to \tcode{drop_view\{E, F\}}.

\rSec2[range.drop.while]{Drop while view}

\rSec3[range.drop.while.overview]{Overview}

\pnum
Given a unary predicate \tcode{pred} and a \tcode{view} \tcode{r},
\tcode{drop_while_view} produces a \tcode{view}
of the range \range{ranges::find_if_not(r, pred)}{ranges::end(r)}.

\pnum
\begin{example}
\begin{codeblock}
	constexpr auto source = "  \t   \t   \t   hello there";
	auto is_invisible = [](const auto x) { return x == ' ' || x == '\t'; };
	auto skip_ws = drop_while_view{source, is_invisible};
	for (auto c : skip_ws) {
		cout << c;                                    // prints \tcode{hello there} with no leading space
	}
\end{codeblock}
\end{example}

\rSec3[range.drop.while.view]{Class template \tcode{drop_while_view}}

\indexlibrary{\idxcode{drop_while_view}}%
\begin{codeblock}
namespace std::ranges {
	template<view R, class Pred>
	requires input_range<R> && is_object_v<Pred> &&
	indirect_unary_predicate<const Pred, iterator_t<R>>
	class drop_while_view : public view_interface<drop_while_view<R, Pred>> {
		public:
		drop_while_view() = default;
		constexpr drop_while_view(R base, Pred pred);

		constexpr R base() const;
		constexpr const Pred& pred() const;

		constexpr auto begin();

		constexpr auto end()
		{ return ranges::end(base_); }

		private:
		R base_;                                            // \expos
		@\placeholder{semiregular-box}@<Pred> pred_; @\itcorr[-1]@                       // \expos
	};

	template<class R, class Pred>
	drop_while_view(R&&, Pred) -> drop_while_view<all_view<R>, Pred>;
}
\end{codeblock}

\indexlibrary{\idxcode{drop_while_view}!constructor}%
\begin{itemdecl}
constexpr drop_while_view(R base, Pred pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \tcode{base_} with \tcode{std::move(base)} and
\tcode{pred_} with \tcode{std::move(pred)}.
\end{itemdescr}

\indexlibrarymember{base}{drop_while_view}%
\begin{itemdecl}
constexpr R base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return base_;}
\end{itemdescr}

\indexlibrarymember{pred}{drop_while_view}%
\begin{itemdecl}
constexpr const Pred& pred() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return *pred_;}
\end{itemdescr}

\indexlibrarymember{begin}{drop_while_view}%
\begin{itemdecl}
constexpr auto begin();


\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{ranges::find_if_not(base_, cref(*pred_))}.

\pnum
\remarks
In order to provide the amortized constant-time complexity
required by the \tcode{range} concept,
the first call caches the result within the \tcode{drop_while_view}
\added{when \tcode{drop_while_view} models \tcode{forward_range}}
for use on subsequent calls.
\begin{note}
	Without this,
	applying a \tcode{reverse_view} over a \tcode{drop_while_view}
	would have quadratic iteration complexity.
\end{note}
\end{itemdescr}

\rSec3[range.drop.while.adaptor]{\tcode{views::drop_while}}

\pnum
The name \tcode{views::drop_while}
denotes a range adaptor object\iref{range.adaptor.object}.
For some subexpressions \tcode{E} and \tcode{F},
the expression \tcode{views::drop_while(E, F)}
is expression-equivalent to \tcode{drop_while_view\{E, F\}}.

\rSec2[range.join]{Join view}
...
\pnum
\tcode{iterator::iterator_category} is defined as follows:
\begin{itemize}
	\item Let \placeholder{OUTERC} denote
	\tcode{iterator_traits<iterator_t<Base>>::iterator_category}, and
	let \placeholder{INNERC} denote
	\tcode{iterator_traits<iterator_t<range_reference_t<Base>>>::iterator_category}.
	\item If \tcode{ref_is_glvalue} is \tcode{true} and
	\placeholder{OUTERC} and \placeholder{INNERC} each model
	\tcode{derived_from<bidirectional_iterator_tag>}, \tcode{iterator_category}
	denotes \tcode{bidirectional_iterator_tag}.
	\item Otherwise, if \tcode{ref_is_glvalue} is \tcode{true} and
	\placeholder{OUTERC} and \placeholder{INNERC} each model
	\tcode{derived_from<for\-ward_iterator_tag>}, \tcode{iterator_category}
	denotes \tcode{forward_iterator_tag}.
	\item Otherwise, \added{if \tcode{iterator_t<Base>} models \tcode{coyable},} \tcode{iterator_category} denotes \tcode{input_iterator_tag}.
	\item
	\added{Otherwise, \tcode{iterator_category} denotes \tcode{output_iterator_tag}.}
\end{itemize}
...

\rSec2[range.split]{Split view}

\rSec3[range.split.overview]{Overview}

\pnum
\tcode{split_view} takes a \libconcept{view} and a delimiter, and splits
the \libconcept{view} into subranges on the delimiter. The delimiter can be
a single element or a \libconcept{view} of elements.

\pnum
\begin{example}
\begin{codeblock}
	string str{"the quick brown fox"};
	split_view sentence{str, ' '};
	for (auto word : sentence) {
		for (char ch : word)
		cout << ch;
		cout << '*';
	}
	// The above prints: the*quick*brown*fox*
\end{codeblock}
\end{example}

\rSec3[range.split.view]{Class template \tcode{split_view}}

\begin{codeblock}
namespace std::ranges {
	template<auto> struct @\placeholdernc{require-constant}@;       // \expos

	template<class R>
	concept @\placeholdernc{tiny-range}@ =                          // \expos
	sized_range<R> &&
	requires { typename @\placeholdernc{require-constant}@<remove_reference_t<R>::size()>; } &&
	(remove_reference_t<R>::size() <= 1);

	template<input_range V, forward_range Pattern>
	requires view<V> && view<Pattern> &&
	indirectly_comparable<iterator_t<V>, iterator_t<Pattern>, ranges::equal_to> &&
	(forward_range<V> || @\placeholdernc{tiny-range}@<Pattern>)
	class split_view : public view_interface<split_view<V, Pattern>> {
		private:
		V base_ = V();                              // \expos
		Pattern pattern_ = Pattern();               // \expos
		iterator_t<V> current_ = iterator_t<V>();   // \expos, present only if \tcode{!forward_range<V>}
		// \ref{range.split.outer}, class template \tcode{split_view::outer_iterator}
		template<bool> struct outer_iterator;       // \expos
		// \ref{range.split.inner}, class template \tcode{split_view::inner_iterator}
		template<bool> struct inner_iterator;       // \expos
		public:
		split_view() = default;
		constexpr split_view(V base, Pattern pattern);

		template<input_range R, forward_range P>
		requires constructible_from<V, all_view<R>> &&
		constructible_from<Pattern, all_view<P>>
		constexpr split_view(R&& r, P&& p);

		template<input_range R>
		requires constructible_from<V, all_view<R>> &&
		constructible_from<Pattern, single_view<range_value_t<R>>>
		constexpr split_view(R&& r, range_value_t<R> e);

		constexpr auto begin() {
			if constexpr (forward_range<V>)
			return outer_iterator<@\placeholder{simple-view}@<V>>{*this, ranges::begin(base_)};
			else {
				current_ = ranges::begin(base_);
				return outer_iterator<false>{*this};
			}
		}

		constexpr auto begin() const requires forward_range<V> && forward_range<const V> {
			return outer_iterator<true>{*this, ranges::begin(base_)};
		}

		constexpr auto end() requires forward_range<V> && common_range<V> {
			return outer_iterator<@\placeholder{simple-view}@<V>>{*this, ranges::end(base_)};
		}

		constexpr auto end() const {
			if constexpr (forward_range<V> && forward_range<const V> && common_range<const V>)
			return outer_iterator<true>{*this, ranges::end(base_)};
			else
			return default_sentinel;
		}
	};

	template<class R, class P>
	split_view(R&&, P&&) -> split_view<all_view<R>, all_view<P>>;

	template<input_range R>
	split_view(R&&, range_value_t<R>)
	-> split_view<all_view<R>, single_view<range_value_t<R>>>;
}
\end{codeblock}

\indexlibrary{\idxcode{split_view}!\idxcode{split_view}}%
\begin{itemdecl}
constexpr split_view(V base, Pattern pattern);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{std::move(base)}, and
\tcode{pattern_} with \tcode{std::move(pattern)}.
\end{itemdescr}

\indexlibrary{\idxcode{split_view}!\idxcode{split_view}}%
\begin{itemdecl}
template<input_range R, forward_range P>
requires constructible_from<V, all_view<R>> &&
constructible_from<Pattern, all_view<P>>
constexpr split_view(R&& r, P&& p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \tcode{base_} with \tcode{views::all(std::forward<R>(r))}, and
\tcode{pattern_} with \tcode{views::all(\brk{}std::forward<P>(p))}.
\end{itemdescr}

\indexlibrary{\idxcode{split_view}!\idxcode{split_view}}%
\begin{itemdecl}
template<input_range R>
requires constructible_from<V, all_view<R>> &&
constructible_from<Pattern, single_view<range_value_t<R>>>
constexpr split_view(R&& r, range_value_t<R> e);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \tcode{base_} with \tcode{views::all(std::forward<R>(r))}, and
\tcode{pattern_} with \tcode{single_view\{\brk{}std::move(e)\}}.
\end{itemdescr}

\rSec3[range.split.outer]{Class template \tcode{split_view::outer_iterator}}

\begin{codeblock}
namespace std::ranges {
	template<class V, class Pattern>
	template<bool Const>
	struct split_view<V, Pattern>::outer_iterator {
		private:
		using Parent =                              // \expos
		conditional_t<Const, const split_view, split_view>;
		using Base   =                              // \expos
		conditional_t<Const, const V, V>;
		Parent* parent_ = nullptr;                  // \expos
		iterator_t<Base> current_ =                 // \expos, present only if \tcode{V} models \libconcept{forward_range}
		iterator_t<Base>();

		public:
		using iterator_concept  =
		conditional_t<forward_range<Base>, forward_iterator_tag, input_iterator_tag>;
		using iterator_category = input_iterator_tag;
		// \ref{range.split.outer.value}, class \tcode{split_view::outer_iterator::value_type}
		struct value_type;
		using difference_type   = range_difference_t<Base>;

		outer_iterator() = default;
		constexpr explicit outer_iterator(Parent& parent)
		requires (!forward_range<Base>);
		constexpr outer_iterator(Parent& parent, iterator_t<Base> current)
		requires forward_range<Base>;
		constexpr outer_iterator(outer_iterator<!Const> i)
		requires Const && convertible_to<iterator_t<V>, iterator_t<const V>>;

		constexpr value_type operator*() const;

		constexpr outer_iterator& operator++();
		constexpr decltype(auto) operator++(int) {
			if constexpr (forward_range<Base>) {
				auto tmp = *this;
				++*this;
				return tmp;
			} else
			++*this;
		}

		friend constexpr bool operator==(const outer_iterator& x, const outer_iterator& y)
		requires forward_range<Base>;

		friend constexpr bool operator==(const outer_iterator& x, default_sentinel_t);
	};
}
\end{codeblock}

\pnum
Many of the following specifications refer to the notional member
\tcode{\placeholder{current}} of \tcode{outer_iterator}.
\tcode{\placeholder{current}} is equivalent to \tcode{current_} if \tcode{V}
models \libconcept{forward_range}, and \tcode{parent_->current_} otherwise.

\indexlibrary{\idxcode{outer_iterator}!\idxcode{split_view::outer_iterator}}%
\begin{itemdecl}
constexpr explicit outer_iterator(Parent& parent)
requires (!forward_range<Base>);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{parent_} with \tcode{addressof(parent)}.
\end{itemdescr}

\indexlibrary{\idxcode{outer_iterator}!\idxcode{split_view::outer_iterator}}%
\begin{itemdecl}
constexpr outer_iterator(Parent& parent, iterator_t<Base> current)
requires forward_range<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{parent_} with \tcode{addressof(parent)}
and \tcode{current_} with \tcode{\changed{current}{std::move(current)}}.
\end{itemdescr}

\indexlibrary{\idxcode{outer_iterator}!\idxcode{split_view::outer_iterator}}%
\begin{itemdecl}
constexpr outer_iterator(outer_iterator<!Const> i)
requires Const && convertible_to<iterator_t<V>, iterator_t<const V>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{parent_} with \tcode{i.parent_} and
\tcode{current_} with \tcode{std::move(i.current_)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator*}!\idxcode{split_view::outer_iterator}}%
\begin{itemdecl}
constexpr value_type operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return value_type\{*this\};}
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{split_view::outer_iterator}}%
\begin{itemdecl}
constexpr outer_iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
	const auto end = ranges::end(parent_->base_);
	if (@\placeholder{current}@ == end) return *this;
	const auto [pbegin, pend] = subrange{parent_->pattern_};
	if (pbegin == pend) ++@\placeholder{current}@;
	else {
		do {
			@\removed{const}@ auto [b, p] =
		        ranges::mismatch(@\changed{\placeholdernc{current}}{std::move(\placeholdernc{current})}@, end, pbegin, pend);
			@\added{\placeholder{current} = std::move(b);}@
			if (p == pend) {
				@\removed{\placeholder{current} = b;}@  // The pattern matched; skip it
				break;
			}
		} while (++@\placeholder{current}@ != end);
	}
	return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{split_view::outer_iterator}}%
\begin{itemdecl}
friend constexpr bool operator==(const outer_iterator& x, const outer_iterator& y)
requires forward_range<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return x.current_ == y.current_;}
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{split_view::outer_iterator}}%
\begin{itemdecl}
friend constexpr bool operator==(const outer_iterator& x, default_sentinel_t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return x.\placeholder{current} == ranges::end(x.parent_->base_);}
\end{itemdescr}

\rSec3[range.split.outer.value]{Class \tcode{split_view::outer_iterator::value_type}}

\begin{codeblock}
namespace std::ranges {
	template<class V, class Pattern>
	template<bool Const>
	struct split_view<V, Pattern>::outer_iterator<Const>::value_type {
		private:
		outer_iterator i_ = outer_iterator();               // \expos
		public:
		value_type() = default;
		constexpr explicit value_type(outer_iterator i);

		constexpr inner_iterator<Const> begin() const @\added{requires copyable<outer_iterator>}@;
		constexpr inner_iterator<Const> begin() @\added{requires (!copyable<outer_iterator>)}@;
		constexpr default_sentinel_t end() const;
	};
}
\end{codeblock}

\indexlibrary{\idxcode{value_type}!\idxcode{split_view::outer_iterator::value_type}}%
\begin{itemdecl}
constexpr explicit value_type(outer_iterator i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{i_} with \tcode{\changed{i}{std::move(i)}}.
\end{itemdescr}

\indexlibrary{\idxcode{begin}!\idxcode{split_view::outer_iterator::value_type}}%
\begin{itemdecl}
constexpr inner_iterator<Const> begin() const @\added{requires copyable<outer_iterator>}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return inner_iterator<Const>\{i_\};}
\end{itemdescr}


\begin{addedblock}
\begin{itemdecl}
	constexpr inner_iterator<Const> begin() requires (!copyable<outer_iterator>);
\end{itemdecl}

\begin{itemdescr}
	\pnum
	\effects Equivalent to: \tcode{return inner_iterator<Const>\{std::move(i_)\};}
\end{itemdescr}
\end{addedblock}

\indexlibrary{\idxcode{end}!\idxcode{split_view::outer_iterator::value_type}}%
\begin{itemdecl}
constexpr default_sentinel_t end() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return default_sentinel;}
\end{itemdescr}

\rSec3[range.split.inner]{Class template \tcode{split_view::inner_iterator}}

\begin{codeblock}
namespace std::ranges {
	template<class V, class Pattern>
	template<bool Const>
	struct split_view<V, Pattern>::inner_iterator {
		private:
		using Base =
		conditional_t<Const, const V, V>;                 // \expos
		outer_iterator<Const> i_ = outer_iterator<Const>(); // \expos
		bool incremented_ = false;                          // \expos
		public:
		using iterator_concept  = typename outer_iterator<Const>::iterator_concept;
		using iterator_category = @\seebelow@;
		using value_type        = range_value_t<Base>;
		using difference_type   = range_difference_t<Base>;

		inner_iterator() = default;
		constexpr explicit inner_iterator(outer_iterator<Const> i);

		constexpr decltype(auto) operator*() const { return *i_.@\placeholder{current}@; }

		constexpr inner_iterator& operator++();
		constexpr decltype(auto) operator++(int) {
			if constexpr (forward_range<V>) {
				auto tmp = *this;
				++*this;
				return tmp;
			} else
			++*this;
		}

		friend constexpr bool operator==(const inner_iterator& x, const inner_iterator& y)
		requires forward_range<Base>;

		friend constexpr bool operator==(const inner_iterator& x, default_sentinel_t);

		friend constexpr decltype(auto) iter_move(const inner_iterator& i)
		noexcept(noexcept(ranges::iter_move(i.i_.@\placeholdernc{current}@))) {
			return ranges::iter_move(i.i_.@\placeholdernc{current}@);
		}

		friend constexpr void iter_swap(const inner_iterator& x, const inner_iterator& y)
		noexcept(noexcept(ranges::iter_swap(x.i_.@\placeholdernc{current}, y.i_.\placeholdernc{current}@)))
		requires indirectly_swappable<iterator_t<Base>>;
	};
}
\end{codeblock}

\pnum
The \grammarterm{typedef-name} \tcode{iterator_category} denotes \added{:}
\begin{removedblock}
\tcode{forward_iterator_tag} if
\tcode{iterator_traits<iterator_t<Base>>::iterator_category} models
\tcode{derived_from<forward_iterator_tag>}, and \tcode{input_iterator_tag} otherwise.
\end{removedblock}

\begin{addedblock}
\begin{itemize}
\item \tcode{forward_iterator_tag} if \tcode{iterator_traits<iterator_t<Base>>::iterator_category} models \tcode{derived_from<forward_iterator_tag>}
\item Otherwise, if \tcode{iterator_t<Base>} and \tcode{iterator_t<range_reference_t<Base>>} are copyable, \tcode{iterator_category} denotes \tcode{input_iterator_tag}.
\item Otherwise, \tcode{iterator_category} denotes \tcode{output_iterator_tag}.
\end{itemize}
\end{addedblock}

\indexlibrary{\idxcode{inner_iterator}!\idxcode{split_view::inner_iterator}}%
\begin{itemdecl}
constexpr explicit inner_iterator(outer_iterator<Const> i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{i_} with \tcode{\changed{i}{std::move(i)}}.
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{split_view::inner_iterator}}%
\begin{itemdecl}
constexpr inner_iterator& operator++() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
	incremented_ = true;
	if constexpr (!forward_range<Base>) {
		if constexpr (Pattern::size() == 0) {
			return *this;
		}
	}
	++i_.@\placeholder{current}@;
	return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{split_view::inner_iterator}}%
\begin{itemdecl}
friend constexpr bool operator==(const inner_iterator& x, const inner_iterator& y)
requires forward_range<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return x.i_.current_ == y.i_.current_;}
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{split_view::inner_iterator}}%
\begin{itemdecl}
friend constexpr bool operator==(const inner_iterator& x, default_sentinel_t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{removedblock}
\begin{codeblock}
	auto cur = x.i_.@\placeholder{current}@;
	auto end = ranges::end(x.i_.parent_->base_);
	if (cur == end) return true;
	auto [pcur, pend] = subrange{x.i_.parent_->pattern_};
	if (pcur == pend) return x.incremented_;
	do {
		if (*cur != *pcur) return false;
		if (++pcur == pend) return true;
	} while (++cur != end);
	return false;
\end{codeblock}
\end{removedblock}

\begin{addedblock}
\begin{codeblock}
	auto [pcur, pend] = subrange{x.i_.parent_->pattern_};
	auto end = ranges::end(x.i_.parent_->base_);
	if constexpr (@\placeholdernc{tiny-range}<Pattern>@) {
		const auto & cur = x.i_.@\placeholder{current}@;
		if (cur == end) return true;
		if (pcur == pend) return x.incremented_;
		return *cur == *pcur;
	}
	else {
		auto cur = x.i_.@\placeholder{current}@;
		if (cur == end) return true;
		if (pcur == pend) return x.incremented_;
		do {
			if (*cur != *pcur) return false;
			if (++pcur == pend) return true;
		} while (++cur != end);
		return false;
	}
\end{codeblock}
\end{addedblock}

\end{itemdescr}

\indexlibrary{\idxcode{iter_swap}!\idxcode{split_view::inner_iterator}}%
\begin{itemdecl}
friend constexpr void iter_swap(const inner_iterator& x, const inner_iterator& y)
noexcept(noexcept(ranges::iter_swap(x.i_.@\placeholdernc{current}, y.i_.\placeholdernc{current}@)))
requires indirectly_swappable<iterator_t<Base>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to
\tcode{ranges::iter_swap(x.i_.\placeholdernc{current}, y.i_.\placeholdernc{current})}.
\end{itemdescr}

\rSec3[range.split.adaptor]{\tcode{views::split}}

\pnum
The name \tcode{views::split} denotes a
range adaptor object\iref{range.adaptor.object}.
For some subexpressions \tcode{E} and \tcode{F},
the expression \tcode{views::split(E, F)} is expression-equivalent to
\tcode{split_view\{E, F\}}.


\rSec2[range.counted]{Counted view}

\pnum
A counted view presents a \libconcept{view} of the elements
of the counted range\iref{iterator.requirements.general} \range{i}{n}
for some iterator \tcode{i} and non-negative integer \tcode{n}.

\pnum
The name \tcode{views::counted} denotes a
customization point object\iref{customization.point.object}.
Let \tcode{E} and \tcode{F} be expressions,
and let \tcode{T} be \tcode{decay_t<decltype((E))>}.
Then the expression \tcode{views::counted(E, F)} is expression-equivalent to:

\begin{itemize}
\item If \tcode{T} models \libconcept{input_or_output_iterator} and
\tcode{decltype((F))} models \tcode{\libconcept{convertible_to}<iter_differ\-ence_t<T>>},
\begin{itemize}
	\item \tcode{subrange\{E, E + static_cast<iter_difference_t<T>>(F)\}}
	if \tcode{T} models \libconcept{random_access_\-it\-er\-ator}.
	\item Otherwise,
	\tcode{subrange\{counted_iterator\{E, F\}, default_sentinel\}}.
\end{itemize}

\item Otherwise, \tcode{views::counted(E, F)} is ill-formed.
\begin{note}
	This case can result in substitution failure when \tcode{views::counted(E, F)}
	appears in the immediate context of a template instantiation.
\end{note}
\end{itemize}

\rSec2[range.common]{Common view}

\rSec3[range.common.overview]{Overview}

\pnum
\tcode{common_view} takes a \libconcept{view} which has different types for
its iterator and sentinel and turns it into a \libconcept{view} of the same
elements with an iterator and sentinel of the same type.

\pnum
\begin{note}
\tcode{common_view} is useful for calling legacy algorithms that expect
a range's iterator and sentinel types to be the same.
\end{note}

\pnum
\begin{example}
\begin{codeblock}
	// Legacy algorithm:
	template<class ForwardIterator>
	size_t count(ForwardIterator first, ForwardIterator last);

	template<forward_range R>
	void my_algo(R&& r) {
		auto&& common = common_view{r};
		auto cnt = count(common.begin(), common.end());
		// ...
	}
\end{codeblock}
\end{example}

\rSec3[range.common.view]{Class template \tcode{common_view}}

\begin{codeblock}
namespace std::ranges {
template<view V>
requires (!common_range<V>@\added{ \&\& \tcode{copyable<iterator_t<V>>}}@)
class common_view : public view_interface<common_view<V>> {
	private:
	V base_ = V();  // \expos
	public:
	common_view() = default;

	constexpr explicit common_view(V r);

	template<viewable_range R>
	requires (!common_range<R> && constructible_from<V, all_view<R>>)
	constexpr explicit common_view(R&& r);

	constexpr V base() const;

	constexpr auto size() requires sized_range<V> {
		return ranges::size(base_);
	}
	constexpr auto size() const requires sized_range<const V> {
		return ranges::size(base_);
	}

	constexpr auto begin() {
		if constexpr (random_access_range<V> && sized_range<V>)
		return ranges::begin(base_);
		else
		return common_iterator<iterator_t<V>, sentinel_t<V>>(ranges::begin(base_));
	}

	constexpr auto begin() const requires range<const V> {
		if constexpr (random_access_range<const V> && sized_range<const V>)
		return ranges::begin(base_);
		else
		return common_iterator<iterator_t<const V>, sentinel_t<const V>>(ranges::begin(base_));
	}

	constexpr auto end() {
		if constexpr (random_access_range<V> && sized_range<V>)
		return ranges::begin(base_) + ranges::size(base_);
		else
		return common_iterator<iterator_t<V>, sentinel_t<V>>(ranges::end(base_));
	}

	constexpr auto end() const requires range<const V> {
		if constexpr (random_access_range<const V> && sized_range<const V>)
		return ranges::begin(base_) + ranges::size(base_);
		else
		return common_iterator<iterator_t<const V>, sentinel_t<const V>>(ranges::end(base_));
	}
};

template<class R>
common_view(R&&) -> common_view<all_view<R>>;
}
\end{codeblock}

\indexlibrary{\idxcode{common_view}!\idxcode{common_view}}%
\begin{itemdecl}
constexpr explicit common_view(V base);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{std::move(base)}.
\end{itemdescr}

\indexlibrary{\idxcode{common_view}!\idxcode{common_view}}%
\begin{itemdecl}
template<viewable_range R>
requires (!common_range<R> && constructible_from<V, all_view<R>>)
constexpr explicit common_view(R&& r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{views::all(std::forward<R>(r))}.
\end{itemdescr}

\indexlibrary{\idxcode{base}!\idxcode{common_view}}%
\begin{itemdecl}
constexpr V base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return base_;}
\end{itemdescr}

...

\rSec3[range.common.adaptor]{\tcode{views::common}}

\pnum
The name \tcode{views::common} denotes a
range adaptor object\iref{range.adaptor.object}.
For some subexpression \tcode{E},
the expression \tcode{views::common(E)} is expression-equivalent to:

\begin{itemize}
\item \tcode{views::all(E)},
if \tcode{decltype((E))} models \libconcept{common_range}
and \tcode{views::all(E)} is a well-formed expression.

\item Otherwise, \tcode{common_view\{E\}}.
\end{itemize}

\rSec2[range.reverse]{Reverse view}

...

\rSec2[range.istream]{Istream view}

...

\rSec2[range.elements]{Elements view}

\rSec3[range.elements.overview]{Overview}

\pnum
\tcode{elements_view} takes
a \tcode{view} of tuple-like values and a \tcode{size_t}, and
produces a \tcode{view} with a value-type of the $N^\text{th}$ element
of the adapted \tcode{view}'s value-type.

\pnum
The name \tcode{views::elements<N>} denotes
a range adaptor object\iref{range.adaptor.object}.
For some subexpression \tcode{E} and constant expression \tcode{N},
the expression \tcode{views::elements<N>(E)} is expression-equivalent to
\tcode{elements_view<all_view<decltype((E))>, N>\{E\}}.

\begin{example}
\begin{codeblock}
	auto historical_figures = map{
		{"Lovelace"sv, 1815},
		{"Turing"sv, 1912},
		{"Babbage"sv, 1791},
		{"Hamilton"sv, 1936}
	};

	auto names = historical_figures | views::elements<0>;
	for (auto&& name : names) {
		cout << name << ' ';          // prints \tcode{Babbage Hamilton Lovelace Turing }
	}

	auto birth_years = historical_figures | views::elements<1>;
	for (auto&& born : birth_years) {
		cout << born << ' ';          // prints \tcode{1791 1936 1815 1912 }
	}
\end{codeblock}
\end{example}

\pnum
\tcode{keys_view} is an alias for \tcode{elements_view<all_view<R>, 0>}, and
is useful for extracting keys from associative containers.

\begin{example}
\begin{codeblock}
	auto names = keys_view{historical_figures};
	for (auto&& name : names) {
		cout << name << ' ';          // prints \tcode{Babbage Hamilton Lovelace Turing }
	}
\end{codeblock}
\end{example}

\pnum
\tcode{values_view} is an alias for \tcode{elements_view<all_view<R>, 1>}, and
is useful for extracting values from associative containers.

\begin{example}
\begin{codeblock}
	auto is_even = [](const auto x) { return x % 2 == 0; };
		cout << ranges::count_if(values_view{historical_figures}, is_even);     // prints \tcode{2}
	\end{codeblock}
\end{example}

\rSec3[range.elements.view]{Class template \tcode{elements_view}}

\indexlibrary{\idxcode{elements_view}}%
\begin{codeblock}
namespace std::ranges {
	template<class T, size_t N>
	concept @\placeholder{has-tuple-element}@ =                   // \expos
	requires(T t) {
		typename tuple_size<T>::type;
		requires N < tuple_size_v<T>;
		typename tuple_element_t<N, T>;
		{ get<N>(t) } -> const tuple_element_t<N, T>&;
	};


	template<input_range R, size_t N>
	requires view<R> && @\placeholder{has-tuple-element}@<range_value_t<R>, N> &&
	@\placeholder{has-tuple-element}@<remove_reference_t<range_reference_t<R>>, N>
	class elements_view : public view_interface<elements_view<R, N>> {
		public:
		elements_view() = default;
		constexpr explicit elements_view(R base);

		constexpr R base() const;

		constexpr auto begin() requires (!@\placeholder{simple-view}@<R>)
		{ return iterator<false>(ranges::begin(base_)); }

		constexpr auto begin() const requires @\placeholder{simple-view}@<R>
		{ return iterator<true>(ranges::begin(base_)); }

		constexpr auto end() requires (!@\placeholder{simple-view}@<R>)
		{ return ranges::end(base_); }

		constexpr auto end() const requires @\placeholder{simple-view}@<R>
		{ return ranges::end(base_); }

		constexpr auto size() requires sized_range<R>
		{ return ranges::size(base_); }

		constexpr auto size() const requires sized_range<const R>
		{ return ranges::size(base_); }

		private:
		template<bool> struct iterator;                     // \expos
		R base_ = R();                                      // \expos
	};
}
\end{codeblock}

\indexlibrary{\idxcode{elements_view}!constructor}%
\begin{itemdecl}
	constexpr explicit elements_view(R base);
\end{itemdecl}

\begin{itemdescr}
	\pnum
	\effects
	Initializes \tcode{base_} with \tcode{std::move(base)}.
\end{itemdescr}

\indexlibrarymember{base}{elements_view}%
\begin{itemdecl}
	constexpr R base() const;
\end{itemdecl}

\begin{itemdescr}
	\pnum
	\effects
	Equivalent to: \tcode{return base_;}
\end{itemdescr}

\rSec3[range.elements.iterator]{Class template \tcode{elements_view::iterator}}

\begin{codeblock}
namespace std::ranges {
	template<class R, size_t N>
	template<bool Const>
	class elements_view<R, N>::iterator {                 // \expos
		using base_t = conditional_t<Const, const R, R>;
		friend iterator<!Const>;

		iterator_t<base_t> current_;
		public:
		using iterator_category = typename iterator_traits<iterator_t<base_t>>::iterator_category;
		using value_type = remove_cvref_t<tuple_element_t<N, range_value_t<base_t>>>;
		using difference_type = range_difference_t<base_t>;

		iterator() = default;
		constexpr explicit iterator(iterator_t<base_t> current);
		constexpr iterator(iterator<!Const> i)
		requires Const && convertible_to<iterator_t<R>, iterator_t<base_t>>;


		constexpr iterator_t<base_t> base() const @\added{\& requires copyable<iterator_t<base_t>>}@;
		@\added{constexpr iterator_t<base_t> base() \&\&;}@

		constexpr decltype(auto) operator*() const
		{ return get<N>(*current_); }

		constexpr iterator& operator++();
		constexpr void operator++(int) requires (!forward_range<base_t>);
		constexpr iterator operator++(int) requires forward_range<base_t>;

		constexpr iterator& operator--() requires bidirectional_range<base_t>;
		constexpr iterator operator--(int) requires bidirectional_range<base_t>;

		constexpr iterator& operator+=(difference_type x)
		requires random_access_range<base_t>;
		constexpr iterator& operator-=(difference_type x)
		requires random_access_range<base_t>;

		constexpr decltype(auto) operator[](difference_type n) const
		requires random_access_range<base_t>
		{ return get<N>(*(current_ + n)); }

		friend constexpr bool operator==(const iterator& x, const iterator& y)
		requires equality_comparable<iterator_t<base_t>>;
		friend constexpr bool operator==(const iterator& x, const sentinel_t<base_t>& y);

		friend constexpr bool operator<(const iterator& x, const iterator& y)
		requires random_access_range<base_t>;
		friend constexpr bool operator>(const iterator& x, const iterator& y)
		requires random_access_range<base_t>;
		friend constexpr bool operator<=(const iterator& y, const iterator& y)
		requires random_access_range<base_t>;
		friend constexpr bool operator>=(const iterator& x, const iterator& y)
		requires random_access_range<base_t>;
		friend constexpr compare_three_way_result_t<iterator_t<base_t>>
		operator<=>(const iterator& x, const iterator& y)
		requires random_access_range<base_t> && three_way_comparable<iterator_t<base_t>>;

		friend constexpr iterator operator+(const iterator& x, difference_type y)
		requires random_access_range<base_t>;
		friend constexpr iterator operator+(difference_type x, const iterator& y)
		requires random_access_range<base_t>;
		friend constexpr iterator operator-(const iterator& x, difference_type y)
		requires random_access_range<base_t>;
		friend constexpr difference_type operator-(const iterator& x, const iterator& y)
		requires random_access_range<base_t>;

		friend constexpr difference_type
		operator-(const iterator<Const>& x, const sentinel_t<base_t>& y)
		requires sized_sentinel_for<sentinel_t<base_t>, iterator_t<base_t>>;
		friend constexpr difference_type
		operator-(const sentinel_t<base_t>& x, const iterator<Const>& y)
		requires sized_sentinel_for<sentinel_t<base_t>, iterator_t<base_t>>;
	};
}
\end{codeblock}

\begin{itemdecl}
	constexpr explicit iterator(iterator_t<base_t> current);
\end{itemdecl}

\begin{itemdescr}
	\pnum
	\effects
	Initializes \tcode{current_} with \tcode{\changed{current}{std::move(current)}}.
\end{itemdescr}

\begin{itemdecl}
	constexpr iterator(iterator<!Const> i)
	requires Const && convertible_to<iterator_t<R>, iterator_t<base_t>>;
\end{itemdecl}

\begin{itemdescr}
	\pnum
	\effects
	Initializes \tcode{current_} with \tcode{i.current_}.
\end{itemdescr}

\begin{itemdecl}
	constexpr iterator_t<base_t> base() const @\added{\& requires copyable<iterator_t<V>>}@;
\end{itemdecl}

\begin{itemdescr}
	\pnum
	\effects
	Equivalent to: \tcode{return current_;}
\end{itemdescr}

\begin{addedblock}
\begin{itemdecl}
	constexpr iterator_t<base_t> base() &&;
\end{itemdecl}

\begin{itemdescr}
	\pnum
	\effects Equivalent to: \tcode{return std::move(current_);}
\end{itemdescr}
\end{addedblock}


\begin{itemdecl}
	constexpr iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
	\pnum
	\effects Equivalent to:
	\begin{codeblock}
		++current_;
		return *this;
	\end{codeblock}
\end{itemdescr}

...


\begin{thebibliography}{9}


	\bibitem[P0896]{P0896}
	Eric Niebler, Casey Carter, Christopher Di Bella.
	\emph{The One Ranges Proposal}\newline
	\url{https://wg21.link/P0896}


	\bibitem[P1456]{P1456}
	Casey Carter
	\emph{ Move-only views}\newline
	\url{https://wg21.link/P1456}

	 Move-only views (by Casey Carter) (2019-01-25)

	\bibitem[P1035]{P1035}
	Christopher Di Bella
	\emph{Input range adaptors}\newline
	\url{https://wg21.link/P1035}

	\bibitem[N4820]{N4820}
	Richard Smith
	\emph{Working Draft, Standard for Programming Language C++}\newline
	\url{https://wg21.link/n4820}


\end{thebibliography}

\end{document}
