% !TeX program = luatex
% !TEX encoding = UTF-8

\documentclass{wg21}

\title{Naming Text Encodings to Demystify Them}
\docnumber{P1885R5}
\audience{SG-16, LEWG}
\author{Corentin Jabot}{corentin.jabot@gmail.com}
\authortwo{Peter Brett}{pbrett@cadence.com}

\begin{document}
\maketitle

\paperquote{If you can't name it, you probably don't know what it is\\
    	If you don't know what it is, you don't know what it isn't\\
    	Tony Van Eerd}


\section{Target}

C++23

\section{Abstract}

For historical reasons, all text encodings mentioned in the standard are derived from
a locale object, which does not necessarily match the reality of how programs and systems interact.

This model works poorly with modern understanding of text, ie the Unicode model separates encoding
from locales which are purely rules for formatting and text transformations but do not affect
which characters are represented by a sequence of code units.

Moreover, the standard does not provide a way to query which encodings are expected or used by the environment,
leading to guesswork and unavoidable UB.

This paper introduces the notions of literal encoding, environment encoding, and a way to query them.


\section{Examples}

\subsection{Listing the encoding}

\begin{colorblock}
#include <text_encoding>
#include <iostream>

void print(const std::text_encoding & c) {
    std::cout << c.name()
    << " (iana mib: " << c.mib() << ")\n"
    << "Aliases:\n";
    for(auto && a : c.aliases()) {
        std::cout << '\t' << a << '\n';
    }
}

int main() {
    std::cout << "Literal Encoding: ";
    print(std::text_encoding::literal());
    std::cout << "Wide Literal Encoding: ";
    print(std::text_encoding::wide_literal());
    std::cout << "environment Encoding: ";
    print(std::text_encoding::environment());
    std::cout << "Wide environment Encoding: ";
    print(std::text_encoding::wide_environment());
}
\end{colorblock}

Compiled with \tcode{g++ -fwide-exec-charset=EBCDIC-US -fexec-charset=SHIFT_JIS}, this program may display:

\begin{colorblock}
    Literal Encoding: SHIFT_JIS (iana mib: 17)
    Aliases:
        Shift_JIS
        MS_Kanji
        csShiftJIS

    Wide Literal Encoding: EBCDIC-US (iana mib: 2078)
    Aliases:
        EBCDIC-US
        csEBCDICUS

    environment Encoding: UTF-8 (iana mib: 106)
    Aliases:
        UTF-8
        csUTF8

    Wide environment Encoding: ISO-10646-UCS-4 (IANA mib: 1001)
    Aliases:
        ISO-10646-UCS-4
        csUCS4
\end{colorblock}

\subsection{LWG3314}

[time.duration.io] specifies that the unit for microseconds is µ on environments able to display it.
This is currently difficult to detect and implement properly.

The following allows an implementation to use µ if it is supported by both the execution encoding and the encoding
attached to the stream.


\begin{colorblock}
    template<class traits, class Rep, class Period>
    void print_suffix(basic_ostream<char, traits>& os, const duration<Rep, Period>& d)
    {
        if constexpr(text_encoding::literal() == text_encoding::UTF8) {
            if (os.getloc().encoding() == text_encoding::UTF8) {
                os << d.count() << "\u00B5s"; // µ
                return;
            }
        }
        os << d.count() << "us";
    }
\end{colorblock}

A more complex implementation may support more encodings, such as iso-8859-1.

\subsection{Asserting a specific encoding is set}

On POSIX, matching encodings is done by name, which pulls the entire database.
To avoid that we propose a method to asserting that the environment encoding is as expected.
such method mixed to only pull in the strings associated with this encoding:

\begin{colorblock}
int main() {
    return text_encoding::environment_is<text_encoding::id::UTF8>();
}
\end{colorblock}




\subsection{User construction}

To support other use cases such as interoperability with other libraries or internet protocols,
\tcode{text_encoding} can be constructed by users

\begin{colorblock}
text_encoding my_utf8("utf8");
assert(my_utf8.name() == "utf8"sv); // Get the user provided name back
assert(my_utf8.mib() == text_encoding::id::UTF8);

text_encoding my_utf8_2(text_encoding::id::UTF8);
assert(my_utf8_2.name() == "UTF-8"sv); // Get the preferred name for the implementation
assert(my_utf8_2.mib() == text_encoding::id::UTF8);
assert(my_utf8 == my_utf8_2);
\end{colorblock}

\subsection{Unregistered encoding}

Unregistered encoding are also supported. They have the \tcode{other} mib, no aliases and are compared
by names:

\begin{colorblock}
text_encoding wtf8("WTF-8");
assert(wtf8.name() == "WTF-8"sv);
assert(wtf8.mib() == text_encoding::id::other);

//encodings with the \tcode{other} mib are compared by name, ignoring case, hyphens and underscores
assert(wtf8 == text_encoding("___wtf8__"));
\end{colorblock}


\section{Revisions}

\subsection*{Revision 5}
\begin{itemize}
    \item Add motivation for name returning const char*
    \item Improve wording
    \item Rename \tcode{system} to \tcode{environment}
    \item Remove freestanding wording - will be handled separately
    \item Exclude a couple of legacy encodings that are problematic with the name matching algorithm
\end{itemize}

\subsection*{Revision 4}
\begin{itemize}
    \item Change \tcode{operator==(encoding, mib)} for \tcode{id::other}
    \item Add wording for freestanding
    \item Improve wording
    \item Improve alias comparison algorithm to match unicode TR22
\end{itemize}

\subsection*{Revision 3}
\begin{itemize}
    \item Add a list of encodings NOT registed by IANA
    \item Add a comparative list of IANA/WHATWG
    \item Address names that do not uniquely identify encodings
    \item Add more examples
\end{itemize}

\subsection*{Revision 2}
\begin{itemize}
	\item Add all the enumerators of rcf 3008
    \item Add a mib constructor to \tcode{text_encoding}
    \item Add \tcode{environment_is} and \tcode{wide_environment_is} function templates
\end{itemize}

\subsection*{Revision 1}
\begin{itemize}
    \item Add more example and clarifications
    \item Require hosted implementations to support all the names registered in \cite{rfc3808}.
\end{itemize}

\section{Use cases}

This paper aims to make C++ simpler by exposing information that is currently hidden to the point of
being perceived as magical by many.
It also leaves no room for a language below C++ by ensuring that text encoding does not require the use of C functions.

The primary use cases are:

\begin{itemize}
    \item Ensuring a specific string encoding at compile time
    \item Ensuring at runtime that string literals are compatible with the environment encoding
    \item Custom conversion function
    \item locale-independent text transformation
\end{itemize}

\subsection{Non goals}

This facility aims to help \textbf{identify} text encodings and does not want to solve encoding conversion and decoding.
Future text encoders and decoders may use the proposed facility as a way to identify their source and destination encoding.
The current facility is \emph{just} a fancy name.

\section{The many text encodings of a C++ environment}

Text in a technical sense is a sequence of bytes to which is virtually attached an encoding.
Without encoding, a blob of data simply cannot be interpreted as text.

In many cases, the encoding used to encode a string is not communicated along with that string and its
encoding is therefore presumed with more or less success.

Generally, it is useful to know the encoding of a string when

\begin{itemize}
    \item Transferring data as text between environments or processes (I/O)
    \item Textual transformation of data
    \item Interpretation of a piece of data
\end{itemize}

In the purview of the standard, text I/O text originates from
\begin{itemize}
    \item The source code (literals)
    \item The iostream library as well as environment functions
    \item Environment variables and command-line arguments intended to be interpreted as text.
\end{itemize}

Locales provide text transformation and conversion facilities and as such, in the current model have an encoding attached to them.

There are therefore 3 sets of encodings of primary interest:

\begin{itemize}
    \item The encoding of narrow and wide characters and string literals
    \item The narrow and wide encodings used by a program when sending or receiving strings from its environment
    \item The encoding of narrow and wide characters attached to a \tcode{std::locale} object
\end{itemize}

\note Because they have different code units sizes, narrow and wide strings have different encodings.
\tcode{char8_t}, \tcode{char16_t}, \tcode{char32_t} literals are assumed to be respectively UTF-8, UTF-16 and UTF-32 encoded.
\endnote

\note A program may have to deal with more encoding - for example, on Windows, the encoding of the console attached to \tcode{cout} may be different from the environment encoding.

Likewise depending on the platform, paths may or may not have an encoding attached to them, and that encoding may either be a property of the platform or the filesystem itself.
\endnote


The standard only has the notion of execution character sets (which implies the existence of execution encodings), whose definitions are locale-specific.
That implies that the standard assumes that string literals are encoded in a subset of the encoding of the locale encoding.

This has to hold notably because it is not generally possible to differentiate runtime strings from compile-time literals at runtime.

This model does, however, present some shortcomings:

First, in practice, C++ softwares are often no longer compiled in the same environment as the one on which they are run and the entity providing the program may not have control over the environment on which it is run.

Both POSIX and C++ derives the encoding from the locale. Which is an unfortunate artifact of an era when 255 characters or less ought to be enough for anyone.
Sadly, the locale can change at runtime, which means the encoding which is used by ctype and conversion functions can change at runtime.
However, this encoding ought to be an immutable property as it is dictated by the environment (often the parent process).
In the general case, it is not for a program to change the encoding expected by its environment.
A C++ program sets the locale to "C" (see \cite{N2346}, 7.11.1.1.4) (which assumes a US ASCII encoding) during initialization, further losing information.


Many text transformations can be done in a locale-agnostic manner yet require the encoding to be known - as no text transformation can ever be applied without
prior knowledge of what the encoding of that text is.

More importantly, it is difficult or impossible for a developer to diagnose an incompatibility between the locale-derived, encoding, the environment-assumed encoding and
the encoding of string literals.

Exposing the different encodings would let developers verify that that the environment is compatible with the implementation-defined encoding of string literals, aka that the encoding and character set used to encode string literals are a strict subset of the encoding of the environment.

\section{Identifying Encodings}

To be able to expose the encoding to developers we need to be able to synthesize that information.
The challenge, of course, is that there exist many encodings (hundreds), and many names to refer to each one.
Fortunately there exist a database of registered encoding covering almost all encodings supported by operating systems and compilers.
This database is maintained by IANA through a process described by \cite{rfc2978}.

This database lists over 250 registered character sets and for each:
\begin{itemize}
    \item A name
    \item A unique identifier
    \item A set of known aliases
\end{itemize}

We propose to use that information to reliably identify encoding across implementations and systems.


\section{Design Considerations}

\subsection{Encodings are orthogonal to locales}

The following proposal is mostly independent of locales so that the relevant part can be implemented in an environment in which \tcode{<locale>}
is not available, as well as to make sure we can transition \tcode{std::locale} to be more compatible with Unicode.

\subsection{Naming}
SG-16 is looking at rewording the terminology associated with text and encoding throughout the standard, this paper does not yet reflect that effort.

However "environment encoding" and "literal encoding" are descriptive terms. In particular, "environment" is illustrative of the
fact that a C++ program has, in the general case, no control over the encoding it is expected to produce and consume.

\subsection{MIBEnum}

We provide a \tcode{text_encoding::id} enum with the MIBEnum value of a few often used encodings for convenience.
Because there is a rather large number of encodings and because this list may evolve faster than the standard, it was pointed out during early review that it would be detrimental to attempt to provide a complete list.
\begin{note}
MIB stands for Management Information Base, which is IANA nomenclature, the name has no particular interest besides a desire not to deviate from the existing standards and practices.
\end{note}


The enumerators \tcode{unknown} and \tcode{other}and their corresponding values, are specified in \cite{rfc3808}:

\begin{itemize}
	\item \tcode{other} designate an encoding not registered in the IANA Database, such that 2 encodings with the \tcode{other} mib are identical if their names compare equal.
	\item \tcode{unknown} is used when the encoding could not be determined. Under the current proposal,  only default constructing a \tcode{text_encoding} object can produce that value. The encoding associated with the locale or environment is always known.
\end{itemize}

While \tcode{MIBEnum} was necessary to make that proposal implementable consistently across platforms,
its main purpose is to remediate the fact that encoding can have multiple inconsistent names across implementations.

\subsection{Name and aliases}

The proposed API offers both a name and aliases.
The \tcode{name} method reflects the name with which the \tcode{text_encoding} object was created, when applicable.
This is notably important when the encoding is not registered, or its name differs from the IANA name.

\subsection{Unique identification of encodings}

The IANA database intends that the name refers to a specific set of characters.
However, for historical reasons, there exist some names (like Shift-JIS) which describes several slightly different encoding.
The intent of this proposal is that the names refer to the character sets as described by IANA.
Further differentiation can be made in the application through out-of-band information such as the provenance of the text to which the encoding is associated. RFC2978 mandates that all names and aliases are unique.

\subsection{Implementation flexibility}

This proposal aims to be implementable on all platforms as such, it supports encodings not registered with IANA, does not impose that
a freestanding implementation is aware of all registered encodings, and it lets implementers provide their aliases for IANA-registered encoding.
Because the process for registering encodings is documented \cite{rfc2978} implementations can (but are not required to) provide
registered encodings not defined in \cite{rfc3808} - in the case that RFC is updated out of sync with the standard.
However, \cite{rfc3808} is from 2004 and has not been updated. As the world converges to UTF-8, new encodings are less likely to
be registered.

Implementations may not extend the \tcode{text_encoding::id} as to guarantee source compatibility.

\subsection{\tcode{const char*}}

A primary use case is to enable people to write their own conversion functions.
Unfortunately, most APIs expect NULL-terminated strings, which is why we return a \tcode{const char*}.
This is \href{https://gcc.gnu.org/bugzilla/show_bug.cgi?id=98576#c2}{requested by users} and consistent with \tcode{source_location},
\tcode{stacktrace}, ...
We would have consider a null-terminated \tcode{string_view} as proposed in \paper{P1402R0} if such thing was available! 


\subsection{Freestanding}

For this class to be compatible with free-standing environments, care has been taken to avoid
allocation and exceptions.
As such, we put an upper bound on the length of the name of encodings passed to \tcode{text_encoding} constructor of 63+1 characters.
Per rfc2978, the names must not exceed 40 characters.
There is however a name of 45 characters in the database. 
64 has been arbitrarily chosen being the smallest power of 2 number that would fit all the name with some extra space
for future-proofing

However, no wording for freestanding is provided as there are currently missing pieces (notably string_view).
We propose that making this facility freestanding can be bundled with the wider work by Ben Craig.

\subsection{Name comparison}

Names and aliases are compared ignoring case and non-alphanumeric characters, in a way that follows
\href{https://www.unicode.org/reports/tr22/tr22-8.html#Charset_Alias_Matching}{Unicode recommandations}

This leads to a couple of ambiguities ("iso-ir-9-1" and "iso-ir-9-2" match "iso-ir-91" and "iso-ir-92", respectively).
The 2 problematics encodings have been excluded from our proposal entirely.
They were designed in 1975 for use in newspapers in Norway and are no longer in use. Supporting them would either require a perfect match, even though we know from experience that users will find 20 creative ways to spell UTF-8, or to perform in sequence a perfect match and a loose match; we do not this is a reasonable cost to pay for algorithms that fell into disuse long ago:


Reference: \href{https://www.itscj.ipsj.or.jp/iso-ir/009-1.pdf}{iso-ir-9-1} \href{https://www.itscj.ipsj.or.jp/iso-ir/009-2.pdf}{iso-ir-9-2}

Note these are different from ISO646-NO2 which is the long obsoleted Norwegian ancestor to ISO 8859-1


\section{Implementation}

The following proposal has been prototyped using a modified version of GCC to expose the encoding information.

On Windows, the run-time encoding can be determined by \tcode{GetACP} - and then map to MIB values, while on a POSIX platform it corresponds to value of \tcode{nl_langinfo} when the environment ("") locale is set - before the program's locale is set to \tcode{C}.

On OSX \tcode{CFStringGetSystemEncoding} and \tcode{CFStringConvertEncodingToIANACharSetName} can also be used.


While exposing the literal encoding is novel, a few libraries do expose the environment encoding, including Qt and wxWidget, and use the IANA registry.

Part of this proposal is available on \href{https://compiler-explorer.com/z/7D3Z3x}{Compiler explorer}
(literal and wide_literal are not supported)


\section{Compatibility with 3rd party systems}

\subsection{Qt}

\begin{colorblock}
// Get a QTextCodec able to convert the environment encoding to QString
auto codec = QTextCodec::codecForMib(std::text_encoding::environment().mib());
\end{colorblock}

\subsection{ICU}

\begin{colorblock}
// Get a UConverter object able to convert to and from the environment encoding to
// ICU's internal encoding.
UErrorCode err;
UConverter* converter = ucnv_open(std::text_encoding::environment().name(), &err);
\end{colorblock}

\begin{colorblock}
// Check whether a UConverter converts to the environment encoding
bool compatibleWithenvironmentEncoding(UConverter* converter)
{
    UErrorCode err;
    const char* name == ucnv_getName(converter, &err);
    assert(U_SUCCESS(err));
    return std::text_encoding(name) == std::text_encoding::environment();
}
\end{colorblock}

\subsection{ICONV}

\begin{colorblock}
// Convert from UTF-8 to the environment encoding, transliterating if necessary
iconv_t converter
    = iconv_open(std::format("{}//TRANSLIT", std::text_encoding::literal()).c_str(), "utf-8");
\end{colorblock}


\section{FAQ}

\subsection{Why rely on the IANA registry ?}

The IANA registry has been picked for several reasons

\begin{itemize}
\item It can be referenced through an RFC in the standard
\item It has wide vendor buy-in
\item It is used as a primary source for many tools including ICU and iconv, and many programming languages and libraries.
\item It has an extensive number of entries which makes it uniquely suitable for the wide portability requirements of C++. Notably, it supports IBM codepages.
\item It provides stable enum values designed for efficient and portable comparison in programming languages
\item There is a well-specified support for unregistered encodings
\item There is a well-specified process to register new encodings
\end{itemize}

We also considered the WHATWG Encoding specification. But this specification is designed specifically for the web
and has no provision for EBCDIC encodings, provides no numerical values, etc.

Annex A provides a comparative list of IANA and WHATWG lists.

Extensive research didn't found any other registry worth considering.
It would be possible to maintain our own list in the standard, but this would put an undue burden on the committee and
risks reducing portability with existing tools, libraries, and other languages.

\subsection{Why not return a \tcode{text_encoding::id} rather than a \tcode{text_encoding} object?}
Some implementations may need to return a non-register encoding, in which case they would return \tcode{mib::other} and a custom name.

\tcode{text_encoding::environment()} and \tcode{text_encoding::environment_mib()} (not proposed) would generate the same code in an optimized build.


\subsection{But handling names is expensive?}
To ensure that the proposal is implementable in a constrained environment, \tcode{text_encoding} has a limit of 63 characters per encoding name
which is sufficient to support all encodings we are aware of (registered or not)

\subsection{It seems like names and mib are separate concerns?}

Not all encodings are registered (even if most are), it is therefore not possible to identify all encoding uniquely by mib.
Encodings may have many names, but some platforms will have a preferred name.

The combination of a name + a mib covers 100\% of use cases. Aliases further help with integration with third-party libraries or to develop
tools that need mime encoding names.

\subsection{Why can't there be vendor provided MIBs?}

This would be meaningless in portable code. \tcode{mib} is only useful as a mechanism to identify encodings \textbf{portably} and to increase compatibility across third-party libraries.

It does not prevent the support of unregistered encodings:

\begin{colorblock}
    text_encoding wtf8("WTF-8");
    assert(wtf8.name() == "WTF-8"sv);
    assert(wtf8.mib() == text_encoding::id::other);
\end{colorblock}


\subsection{Why can't there be a \tcode{text_encoding(name, mib)} constructor?}

Same reason, if users are allowed to construct text_encoding from registered names or names otherwise
unknown from the implementation with an arbitrary mib, it becomes impossible to maintain the invariant of the class
(the relation between mib and name), which would make the interface much harder to use, without providing
any functionality.

\subsection{I just want to check that my platform is utf-8 without paying for all these other encodings?}

we added \tcode{environment_is} to that end.

\begin{colorblock}[style=MY]
    int main() {
        assert(text_encoding::environment_is<text_encoding::id::UTF8>
                  && "Non UTF8 encoding detected, go away");
    }
\end{colorblock}


This can be implemented in a way that only stores in the program the necessary information for that particular encoding (unless \tcode{aliases} is called at runtime).

On Windows and OSX, only calling \tcode{encoding::aliases} would pull any data in the program, even if calling \tcode{environment}.


\subsection{What is the cost of calling \tcode{aliases}?}

My crude implementation pulls in 30Ki of data when calling aliases or the name constructor, or \tcode{environment()} (on POSIX).
\section{Future work}

Exposing the notion of text encoding in the core and library language gives us the tools to solve some problems in the standard.

Notably, it offers a sensible way to do locale-independent, encoding-aware padding in \tcode{std::format} as in described in \cite{P1868}.

While this gives us the tools to handle encoding, it does not fix the core wording.


\subsection{Why do \tcode{name()} and \tcode{aliases()} return \tcode{const char*} rather than \tcode{string_view}?}

One of the design goals is to be compatible with widely deployed libraries such as ICU and iconv, which are, on most platforms, the defacto standards for text transformations, classification, and transcoding.
These are C APIs which expect null-terminated string.
Returning a null-terminated string_view of which end() is dereferenced would be UB.
Returning a \tcode{string} and hopping that SBO kicks in would add complexity for little reason, and would preclude the name function to be provided in free standing implementations.
LEWG previously elected to use const char* in source_location, stacktrace, etc

\newpage


\section{Proposed wording}

Add the header \tcode{<text_encoding>} to the "C++ library headers" table in
\tcode{[headers]}, in a place that respects the table’s current alphabetic
order.

Add the macro \tcode{__cpp_lib_text_encoding} to \tcode{[version.syn]}, in a
place that respects the current alphabetic order:

\begin{codeblock}
#define __cpp_lib_text_encoding 201911L (**placeholder**) // also in \tcode{text_encoding}
\end{codeblock}

Add a new header \tcode{<text_encoding>}.

\begin{quote}
\begin{addedblock}

[text.encoding] describes an interface for accessing the IANA Character Sets database.


%describes an interface A \tcode{text\_encoding} is an object which represents a character encoding by %exposing data from the Character Sets database described by \cite{rfc2978} and \cite{rfc3808}.

\begin{codeblock}

namespace std {

struct text_encoding {

    inline constexpr size_t max_name_length = 63;

    enum class id : int_least32_t {
        other = 1,
        unknown = 2,
        ASCII = 3,
        ISOLatin1 = 4,
        ISOLatin2 = 5,
        ISOLatin3 = 6,
        ISOLatin4 = 7,
        ISOLatinCyrillic = 8,
        ISOLatinArabic = 9,
        ISOLatinGreek = 10,
        ISOLatinHebrew = 11,
        ISOLatin5 = 12,
        ISOLatin6 = 13,
        ISOTextComm = 14,
        HalfWidthKatakana = 15,
        JISEncoding = 16,
        ShiftJIS = 17,
        EUCPkdFmtJapanese = 18,
        EUCFixWidJapanese = 19,
        ISO4UnitedKingdom = 20,
        ISO11SwedishForNames = 21,
        ISO15Italian = 22,
        ISO17Spanish = 23,
        ISO21German = 24,
        ISO60DanishNorwegian = 25,
        ISO69French = 26,
        ISO10646UTF1 = 27,
        ISO646basic1983 = 28,
        INVARIANT = 29,
        ISO2IntlRefVersion = 30,
        NATSSEFI = 31,
        NATSSEFIADD = 32,
        ISO10Swedish = 35,
        KSC56011987 = 36,
        ISO2022KR = 37,
        EUCKR = 38,
        ISO2022JP = 39,
        ISO2022JP2 = 40,
        ISO13JISC6220jp = 41,
        ISO14JISC6220ro = 42,
        ISO16Portuguese = 43,
        ISO18Greek7Old = 44,
        ISO19LatinGreek = 45,
        ISO25French = 46,
        ISO27LatinGreek1 = 47,
        ISO5427Cyrillic = 48,
        ISO42JISC62261978 = 49,
        ISO47BSViewdata = 50,
        ISO49INIS = 51,
        ISO50INIS8 = 52,
        ISO51INISCyrillic = 53,
        ISO54271981 = 54,
        ISO5428Greek = 55,
        ISO57GB1988 = 56,
        ISO58GB231280 = 57,
        ISO61Norwegian2 = 58,
        ISO70VideotexSupp1 = 59,
        ISO84Portuguese2 = 60,
        ISO85Spanish2 = 61,
        ISO86Hungarian = 62,
        ISO87JISX0208 = 63,
        ISO88Greek7 = 64,
        ISO89ASMO449 = 65,
        ISO90 = 66,
        ISO91JISC62291984a = 67,
        ISO92JISC62991984b = 68,
        ISO93JIS62291984badd = 69,
        ISO94JIS62291984hand = 70,
        ISO95JIS62291984handadd = 71,
        ISO96JISC62291984kana = 72,
        ISO2033 = 73,
        ISO99NAPLPS = 74,
        ISO102T617bit = 75,
        ISO103T618bit = 76,
        ISO111ECMACyrillic = 77,
        ISO121Canadian1 = 78,
        ISO122Canadian2 = 79,
        ISO123CSAZ24341985gr = 80,
        ISO88596E = 81,
        ISO88596I = 82,
        ISO128T101G2 = 83,
        ISO88598E = 84,
        ISO88598I = 85,
        ISO139CSN369103 = 86,
        ISO141JUSIB1002 = 87,
        ISO143IECP271 = 88,
        ISO146Serbian = 89,
        ISO147Macedonian = 90,
        ISO150 = 91,
        ISO151Cuba = 92,
        ISO6937Add = 93,
        ISO153GOST1976874 = 94,
        ISO8859Supp = 95,
        ISO10367Box = 96,
        ISO158Lap = 97,
        ISO159JISX02121990 = 98,
        ISO646Danish = 99,
        USDK = 100,
        DKUS = 101,
        KSC5636 = 102,
        Unicode11UTF7 = 103,
        ISO2022CN = 104,
        ISO2022CNEXT = 105,
        UTF8 = 106,
        ISO885913 = 109,
        ISO885914 = 110,
        ISO885915 = 111,
        ISO885916 = 112,
        GBK = 113,
        GB18030 = 114,
        OSDEBCDICDF0415 = 115,
        OSDEBCDICDF03IRV = 116,
        OSDEBCDICDF041 = 117,
        ISO115481 = 118,
        KZ1048 = 119,
        UCS2 = 1000,
        UCS4 = 1001,
        UnicodeASCII = 1002,
        UnicodeLatin1 = 1003,
        UnicodeJapanese = 1004,
        UnicodeIBM1261 = 1005,
        UnicodeIBM1268 = 1006,
        UnicodeIBM1276 = 1007,
        UnicodeIBM1264 = 1008,
        UnicodeIBM1265 = 1009,
        Unicode11 = 1010,
        SCSU = 1011,
        UTF7 = 1012,
        UTF16BE = 1013,
        UTF16LE = 1014,
        UTF16 = 1015,
        CESU8 = 1016,
        UTF32 = 1017,
        UTF32BE = 1018,
        UTF32LE = 1019,
        BOCU1 = 1020,
        Windows30Latin1 = 2000,
        Windows31Latin1 = 2001,
        Windows31Latin2 = 2002,
        Windows31Latin5 = 2003,
        HPRoman8 = 2004,
        AdobeStandardEncoding = 2005,
        VenturaUS = 2006,
        VenturaInternational = 2007,
        DECMCS = 2008,
        PC850Multilingual = 2009,
        PC8DanishNorwegian = 2012,
        PC862LatinHebrew = 2013,
        PC8Turkish = 2014,
        IBMSymbols = 2015,
        IBMThai = 2016,
        HPLegal = 2017,
        HPPiFont = 2018,
        HPMath8 = 2019,
        HPPSMath = 2020,
        HPDesktop = 2021,
        VenturaMath = 2022,
        MicrosoftPublishing = 2023,
        Windows31J = 2024,
        GB2312 = 2025,
        Big5 = 2026,
        Macintosh = 2027,
        IBM037 = 2028,
        IBM038 = 2029,
        IBM273 = 2030,
        IBM274 = 2031,
        IBM275 = 2032,
        IBM277 = 2033,
        IBM278 = 2034,
        IBM280 = 2035,
        IBM281 = 2036,
        IBM284 = 2037,
        IBM285 = 2038,
        IBM290 = 2039,
        IBM297 = 2040,
        IBM420 = 2041,
        IBM423 = 2042,
        IBM424 = 2043,
        PC8CodePage437 = 2011,
        IBM500 = 2044,
        IBM851 = 2045,
        PCp852 = 2010,
        IBM855 = 2046,
        IBM857 = 2047,
        IBM860 = 2048,
        IBM861 = 2049,
        IBM863 = 2050,
        IBM864 = 2051,
        IBM865 = 2052,
        IBM868 = 2053,
        IBM869 = 2054,
        IBM870 = 2055,
        IBM871 = 2056,
        IBM880 = 2057,
        IBM891 = 2058,
        IBM903 = 2059,
        IBBM904 = 2060,
        IBM905 = 2061,
        IBM918 = 2062,
        IBM1026 = 2063,
        IBMEBCDICATDE = 2064,
        EBCDICATDEA = 2065,
        EBCDICCAFR = 2066,
        EBCDICDKNO = 2067,
        EBCDICDKNOA = 2068,
        EBCDICFISE = 2069,
        EBCDICFISEA = 2070,
        EBCDICFR = 2071,
        EBCDICIT = 2072,
        EBCDICPT = 2073,
        EBCDICES = 2074,
        EBCDICESA = 2075,
        EBCDICESS = 2076,
        EBCDICUK = 2077,
        EBCDICUS = 2078,
        Unknown8BiT = 2079,
        Mnemonic = 2080,
        Mnem = 2081,
        VISCII = 2082,
        VIQR = 2083,
        KOI8R = 2084,
        HZGB2312 = 2085,
        IBM866 = 2086,
        PC775Baltic = 2087,
        KOI8U = 2088,
        IBM00858 = 2089,
        IBM00924 = 2090,
        IBM01140 = 2091,
        IBM01141 = 2092,
        IBM01142 = 2093,
        IBM01143 = 2094,
        IBM01144 = 2095,
        IBM01145 = 2096,
        IBM01146 = 2097,
        IBM01147 = 2098,
        IBM01148 = 2099,
        IBM01149 = 2100,
        Big5HKSCS = 2101,
        IBM1047 = 2102,
        PTCP154 = 2103,
        Amiga1251 = 2104,
        KOI7switched = 2105,
        BRF = 2106,
        TSCII = 2107,
        CP51932 = 2108,
        windows874 = 2109,
        windows1250 = 2250,
        windows1251 = 2251,
        windows1252 = 2252,
        windows1253 = 2253,
        windows1254 = 2254,
        windows1255 = 2255,
        windows1256 = 2256,
        windows1257 = 2257,
        windows1258 = 2258,
        TIS620 = 2259,
        CP50220 = 2260,
        reserved = 3000
    };

    constexpr text_encoding() = default;
    constexpr explicit text_encoding(string_view name) noexcept;
    constexpr text_encoding(id mib) noexcept;

    constexpr id mib() const noexcept;
    constexpr const char* name() const noexcept;

    constexpr auto aliases() const noexcept -> @{\seebelow}@;

    constexpr bool operator==(const text_encoding & other) const noexcept;
    constexpr bool operator==(id mib) const noexcept;

    static consteval text_encoding literal();
    static consteval text_encoding wide_literal();

    static text_encoding environment() noexcept;
    static text_encoding wide_environment() noexcept;


    template<id id_>
    static bool text_encoding::environment_is() noexcept;

    template<id id_>
    static bool text_encoding::wide_environment_is() noexcept;

    private:
        id mib_ = id::unknown; // \expos
        char name_[max_name_length+1] = {0}; // \expos
    };


// hash support
template<class T> struct hash;
template<> struct hash<text_encoding>;

}


\end{codeblock}
\end{addedblock}
\end{quote}


\begin{addedblock}

\pnum A \defn{registered-character-set} is a character set in the IANA Character Sets database.



The set of known \defn{registered-character-set} contains every \defn{registered-character-set} specified in the IANA Character Sets database except for the following:
\begin{itemize}
\item NATS-DANO (33)
\item NATS-DANO-ADD	(34)
\end{itemize}


Each \defn{registered-character-set} is identified by an enumerator in \tcode{text_encoding::id}, has a unique \defn{preferred-name} and has a set of 0 or more aliases.
Its name is specified in the IANA Character Sets database.
Its set of aliases is an implementation-defined superset of the aliases specified in the IANA Character Sets database.

Each alias is associated with exactly one \defn{registered-character-set}.

\begin{note}
The name and value of each enumerator in the \tcode{text_encoding::id} enum is identical to those specified in \cite{rfc3808} except for the following modifications:
\begin{itemize}
    \item the "cs" prefix is removed from each name
    \item \tcode{csUnicode} is renamed \tcode{text_encoding::id::UCS2}
    \end{itemize}
\end{note}



\pnum Let \tcode{bool COMP_NAME(string_view a, string_view b)} be a function that returns \tcode{true} if two strings encoded in the literal character set are equal ignoring: character case;  all characters outside of the ranges [a-z], [A-Z], [0-9]; and \tcode{0} not preceded by [0-9].

\begin{itemdecl}
inline constexpr size_t max_name_length = @\seebelow@;
\end{itemdecl}

\begin{itemdecl}
constexpr explicit text_encoding(string_view name) noexcept;
\end{itemdecl}

\begin{itemdescr}
    \preconditions \tcode{name.size() <= max_name_length} is \tcode{true}.

    \effects
    If there exists a preferred-name or alias \tcode{a} of \defn{registered-character-set} such that \tcode{COMP_NAME(a, name.c_str())} is \tcode{true}, initializes
    \tcode{mib_} with the value of the enumerator of \tcode{id} associated with that \defn{registered-character-set}. Otherwise, initialize \tcode{mib_} with \tcode{id::other}.

    Initialises \tcode{name_} as if with \tcode{strncpy(name_, name.data(), name.size())}.

\end{itemdescr}


\begin{itemdecl}
constexpr text_encoding(id mib) noexcept;
\end{itemdecl}

\begin{itemdescr}
    \preconditions \tcode{mib} has the value of one of the enumerators of \tcode{id}.

    Initializes \tcode{mib_} with \tcode{mib}.

    If \tcode{mib} is not one of \tcode{id::unknown}, \tcode{id::other}, initializes \tcode{name_}
    as if with \tcode{strcpy(name_, *(aliases().begin()))};
\end{itemdescr}


\begin{itemdecl}
constexpr id mib() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{mib\_}.

\end{itemdescr}

\begin{itemdecl}
constexpr const char* name() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\returns \tcode{name_};

\begin{note}
    \tcode{name_} is a \ntbs.
\end{note}

\end{itemdescr}


\begin{itemdecl}
constexpr auto aliases() const noexcept;
\end{itemdecl}

\begin{itemdescr}
Let \tcode{AliasRange} denote an implementation-defined type such that:
\begin{itemize}
    \item \tcode{ranges::view<AliasRange>} is true,
    \item \tcode{ranges::random_access_range<AliasRange>} is true,
    \item \tcode{same_as<ranges::range_value_t<AliasRange>, string_view>} is true,
\end{itemize}

Let \tcode{r} denote an instance of \tcode{AliasRange}.

\pnum If \tcode{*this} represents a \defn{registered-character-set} then:
\begin{itemize}
    \item \tcode{r[0]} is the  \defn{preferred-name} of the \defn{registered-character-set},
    \item \tcode{r} contains the aliases of the \defn{registered-character-set},
    \item \pnum \tcode{r} does not contain duplicate values when compared with \tcode{COMP_NAME}.
\end{itemize}

Otherwise, \tcode{r} is an empty range.

\returns \tcode{r}.

\begin{note}
The order of elements in \tcode{r} is unspecified.
\end{note}

\end{itemdescr}

\begin{itemdecl}
constexpr bool operator==(const text_encoding & other) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\returns

If \tcode{mib() == id::other \&\& other.mib() == id::other} is true, then return \tcode{COMP_NAME(name(), other.name())}.

Otherwise, return \tcode{mib() == other.mib()}.

\end{itemdescr}

\begin{itemdecl}
constexpr bool operator==(id i) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{mib() == i}.
\end{itemdescr}

\begin{itemdecl}
static consteval text_encoding literal();
\end{itemdecl}

\begin{itemdescr}
    \returns A \tcode{text_encoding} object representing the encoding of ordinary string literals.
    The returned value never compares true to \tcode{id::unknown}.
\end{itemdescr}

\begin{itemdecl}
static consteval text_encoding wide_literal();
\end{itemdecl}

\begin{itemdescr}
    \returns A \tcode{text_encoding} object representing the encoding of wide string literals.
    The returned value never compares \tcode{true} to \tcode{id::unknown}.
\end{itemdescr}

\begin{itemdecl}
static text_encoding environment() noexcept;
\end{itemdecl}

\begin{itemdescr}
Return the implementation-defined \defn{execution character encoding} at the start of the program.
On a POSIX environment, this is equivalent to \tcode{text_encoding(nl_langinfo_l(CODESET, newlocale(LC_CTYPE_MASK, "", (locale_t)0))}.

\begin{note}
This function always returns the same value during the execution of a program and is not affected by calls to \tcode{setlocale}.
\end{note}
\end{itemdescr}

\begin{itemdecl}
static text_encoding wide_environment() noexcept;
\end{itemdecl}

\begin{itemdescr}
Return the implementation-defined \defn{wide execution character encoding} at the start of the program.

\begin{note}
This function always returns the same value during the execution of a program and is not affected by calls to \tcode{setlocale}.
\end{note}
\end{itemdescr}

\begin{itemdecl}
template<id id_>
static bool text_encoding::environment_is() noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects Equivalent to \tcode{environment() == id_}
\end{itemdescr}

\begin{itemdecl}
template<id id_>
static bool text_encoding::environment_wide_is() noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects Equivalent to \tcode{wide_environment() == id_}
\end{itemdescr}


\end{addedblock}

In \tcode{[locale]}:

\begin{quote}
\begin{codeblock}
namespace std {
  class locale {
  public:
    [...]

    // locale operations
    string name() const;
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
    text_encoding encoding() const;
    text_encoding wide_encoding() const;
\end{codeblock}
\end{addedblock}
\begin{codeblock}
  };
}
\end{codeblock}
\end{quote}

In \tcode{[locale.members]}:

\begin{itemdecl}
string name() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The name of
\tcode{*this},
if it has one; otherwise, the string \tcode{"*"}.
\end{itemdescr}

\begin{addedblock}
\begin{itemdecl}
text_encoding encoding() const;
\end{itemdecl}

\begin{itemdescr}
  \returns The text encoding for narrow strings associated with the locale \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
text_encoding wide_encoding() const;
\end{itemdecl}

\begin{itemdescr}
  \returns The text encoding for wide strings associated with the locale \tcode{*this}.
\end{itemdescr}
\end{addedblock}

\subsection{Bibliography}

\begin{itemize}
    \renewcommand{\labelitemi}{---}
    % ISO documents in numerical order.
    \item
    ISO 4217:2015,
    \doccite{Codes for the representation of currencies}
    \item
    ISO/IEC 10967-1:2012,
    \doccite{Information technology --- Language independent arithmetic ---
        Part 1: Integer and floating point arithmetic}
    \item
    ISO/IEC/IEEE 60559:2011, \doccite{Information technology ---
        Microprocessor Systems --- Floating-Point arithmetic}
    % Other international standards.
    \item
    %%% Format for the following entry is based on that specified at
    %%% http://www.iec.ch/standardsdev/resources/draftingpublications/directives/principles/referencing.htm
    The Unicode Consortium. Unicode Standard Annex, UAX \#29,
    \doccite{Unicode Text Segmentation} [online].
    Edited by Mark Davis. Revision 35; issued for Unicode 12.0.0. 2019-02-15 [viewed 2020-02-23].
    Available from: \url{http://www.unicode.org/reports/tr29/tr29-35.html}
\begin{addedblock}
    \item
    IANA Character Sets Database.\\
    Available from: \url{https://www.iana.org/assignments/character-sets/}
\end{addedblock}
    \item
    IANA Time Zone Database.
    Available from: \url{https://www.iana.org/time-zones}
    % Literature references.
    \item
    Bjarne Stroustrup,
    \doccite{The \Cpp{} Programming Language, second edition}, Chapter R.
    Addison-Wesley Publishing Company, ISBN 0-201-53992-6, copyright \copyright 1991 AT\&T
    \item
    Brian W. Kernighan and Dennis M. Ritchie,
    \doccite{The C Programming Language}, Appendix A.
    Prentice-Hall, 1978, ISBN 0-13-110163-3, copyright \copyright 1978 AT\&T
    \item
    P.J. Plauger,
    \doccite{The Draft Standard \Cpp{} Library}.
    Prentice-Hall, ISBN 0-13-117003-1, copyright \copyright 1995 P.J. Plauger)
\end{itemize}

The arithmetic specification described in ISO/IEC 10967-1:2012 is
called \defn{LIA-1} in this document.


\section{Acknowledgments}

Many thanks to Victor Zverovich, Thiago Macieira, Jens Maurer, Tom Honermann, and others for reviewing this work and providing valuable feedback.

\section{Annex: Registered encodings}
\begin{longtable}{| p{.40\textwidth} | p{.40\textwidth} |}
\hline
\textbf{IANA} & \textbf{WHATWG} \\ \hline
\hline
ANSI_X3.110-1983 & \\ \hline
ASMO_449 & \\ \hline
Adobe-Standard-Encoding & \\ \hline
Adobe-Symbol-Encoding & \\ \hline
Amiga-1251 & \\ \hline
BOCU-1 & \\ \hline
BRF & \\ \hline
BS_4730 & \\ \hline
BS_viewdata & \\ \hline
Big5 & Big5\\ \hline
Big5-HKSCS & \\ \hline
CESU-8 & \\ \hline
CP50220 & \\ \hline
CP51932 & \\ \hline
CSA_Z243.4-1985-1 & \\ \hline
CSA_Z243.4-1985-2 & \\ \hline
CSA_Z243.4-1985-gr & \\ \hline
CSN_369103 & \\ \hline
DEC-MCS & \\ \hline
DIN_66003 & \\ \hline
DS_2089 & \\ \hline
EBCDIC-AT-DE & \\ \hline
EBCDIC-AT-DE-A & \\ \hline
EBCDIC-CA-FR & \\ \hline
EBCDIC-DK-NO & \\ \hline
EBCDIC-DK-NO-A & \\ \hline
EBCDIC-ES & \\ \hline
EBCDIC-ES-A & \\ \hline
EBCDIC-ES-S & \\ \hline
EBCDIC-FI-SE & \\ \hline
EBCDIC-FI-SE-A & \\ \hline
EBCDIC-FR & \\ \hline
EBCDIC-IT & \\ \hline
EBCDIC-PT & \\ \hline
EBCDIC-UK & \\ \hline
EBCDIC-US & \\ \hline
ECMA-cyrillic & \\ \hline
ES & \\ \hline
ES2 & \\ \hline
EUC-JP & EUC-JP\\ \hline
EUC-KR & EUC-KR\\ \hline
Extended_UNIX_Code_Fixed_Width_for_Japanese & \\ \hline
GB18030 & gb18030\\ \hline
GB2312 & \\ \hline
GBK & GBK\\ \hline
GB_1988-80 & \\ \hline
GB_2312-80 & \\ \hline
GOST_19768-74 & \\ \hline
HP-DeskTop & \\ \hline
HP-Legal & \\ \hline
HP-Math8 & \\ \hline
HP-Pi-font & \\ \hline
HZ-GB-2312 & \\ \hline
IBM-Symbols & \\ \hline
IBM-Thai & \\ \hline
IBM00858 & \\ \hline
IBM00924 & \\ \hline
IBM01140 & \\ \hline
IBM01141 & \\ \hline
IBM01142 & \\ \hline
IBM01143 & \\ \hline
IBM01144 & \\ \hline
IBM01145 & \\ \hline
IBM01146 & \\ \hline
IBM01147 & \\ \hline
IBM01148 & \\ \hline
IBM01149 & \\ \hline
IBM037 & \\ \hline
IBM038 & \\ \hline
IBM1026 & \\ \hline
IBM1047 & \\ \hline
IBM273 & \\ \hline
IBM274 & \\ \hline
IBM275 & \\ \hline
IBM277 & \\ \hline
IBM278 & \\ \hline
IBM280 & \\ \hline
IBM281 & \\ \hline
IBM284 & \\ \hline
IBM285 & \\ \hline
IBM290 & \\ \hline
IBM297 & \\ \hline
IBM420 & \\ \hline
IBM423 & \\ \hline
IBM424 & \\ \hline
IBM437 & \\ \hline
IBM500 & \\ \hline
IBM775 & \\ \hline
IBM850 & \\ \hline
IBM851 & \\ \hline
IBM852 & \\ \hline
IBM855 & \\ \hline
IBM857 & \\ \hline
IBM860 & \\ \hline
IBM861 & \\ \hline
IBM862 & \\ \hline
IBM863 & \\ \hline
IBM864 & \\ \hline
IBM865 & \\ \hline
IBM866 & IBM866\\ \hline
IBM868 & \\ \hline
IBM869 & \\ \hline
IBM870 & \\ \hline
IBM871 & \\ \hline
IBM880 & \\ \hline
IBM891 & \\ \hline
IBM903 & \\ \hline
IBM904 & \\ \hline
IBM905 & \\ \hline
IBM918 & \\ \hline
IEC_P27-1 & \\ \hline
INIS & \\ \hline
INIS-8 & \\ \hline
INIS-cyrillic & \\ \hline
INVARIANT & \\ \hline
ISO-10646-J-1 & \\ \hline
ISO-10646-UCS-2 & \\ \hline
ISO-10646-UCS-4 & \\ \hline
ISO-10646-UCS-Basic & \\ \hline
ISO-10646-UTF-1 & \\ \hline
ISO-10646-Unicode-Latin1 & \\ \hline
ISO-11548-1 & \\ \hline
ISO-2022-CN & \\ \hline
ISO-2022-CN-EXT & \\ \hline
ISO-2022-JP & ISO-2022-JP\\ \hline
ISO-2022-JP-2 & \\ \hline
ISO-2022-KR & \\ \hline
ISO-8859-1 & \\ \hline
ISO-8859-1-Windows-3.0-Latin-1 & \\ \hline
ISO-8859-1-Windows-3.1-Latin-1 & \\ \hline
ISO-8859-10 & ISO-8859-10\\ \hline
ISO-8859-13 & ISO-8859-13\\ \hline
ISO-8859-14 & ISO-8859-14\\ \hline
ISO-8859-15 & ISO-8859-15\\ \hline
ISO-8859-16 & ISO-8859-16\\ \hline
ISO-8859-2 & ISO-8859-2\\ \hline
ISO-8859-2-Windows-Latin-2 & \\ \hline
ISO-8859-3 & ISO-8859-3\\ \hline
ISO-8859-4 & ISO-8859-4\\ \hline
ISO-8859-5 & ISO-8859-5\\ \hline
ISO-8859-6 & ISO-8859-6\\ \hline
ISO-8859-6-E & \\ \hline
ISO-8859-6-I & \\ \hline
ISO-8859-7 & ISO-8859-7\\ \hline
ISO-8859-8 & ISO-8859-8\\ \hline
ISO-8859-8-E & \\ \hline
ISO-8859-8-I & ISO-8859-8-I\\ \hline
ISO-8859-9 & \\ \hline
ISO-8859-9-Windows-Latin-5 & \\ \hline
ISO-Unicode-IBM-1261 & \\ \hline
ISO-Unicode-IBM-1264 & \\ \hline
ISO-Unicode-IBM-1265 & \\ \hline
ISO-Unicode-IBM-1268 & \\ \hline
ISO-Unicode-IBM-1276 & \\ \hline
ISO_10367-box & \\ \hline
ISO_2033-1983 & \\ \hline
ISO_5427 & \\ \hline
ISO_5427:1981 & \\ \hline
ISO_5428:1980 & \\ \hline
ISO_646.basic:1983 & \\ \hline
ISO_646.irv:1983 & \\ \hline
ISO_6937-2-25 & \\ \hline
ISO_6937-2-add & \\ \hline
ISO_8859-supp & \\ \hline
IT & \\ \hline
JIS_C6220-1969-jp & \\ \hline
JIS_C6220-1969-ro & \\ \hline
JIS_C6226-1978 & \\ \hline
JIS_C6226-1983 & \\ \hline
JIS_C6229-1984-a & \\ \hline
JIS_C6229-1984-b & \\ \hline
JIS_C6229-1984-b-add & \\ \hline
JIS_C6229-1984-hand & \\ \hline
JIS_C6229-1984-hand-add & \\ \hline
JIS_C6229-1984-kana & \\ \hline
JIS_Encoding & \\ \hline
JIS_X0201 & \\ \hline
JIS_X0212-1990 & \\ \hline
JUS_I.B1.002 & \\ \hline
JUS_I.B1.003-mac & \\ \hline
JUS_I.B1.003-serb & \\ \hline
KOI7-switched & \\ \hline
KOI8-R & KOI8-R\\ \hline
KOI8-U & KOI8-U\\ \hline
KSC5636 & \\ \hline
KS_C_5601-1987 & \\ \hline
KZ-1048 & \\ \hline
Latin-greek-1 & \\ \hline
MNEM & \\ \hline
MNEMONIC & \\ \hline
MSZ_7795.3 & \\ \hline
Microsoft-Publishing & \\ \hline
NATS-DANO & \\ \hline
NATS-DANO-ADD & \\ \hline
NATS-SEFI & \\ \hline
NATS-SEFI-ADD & \\ \hline
NC_NC00-10:81 & \\ \hline
NF_Z_62-010 & \\ \hline
NF_Z_62-010_(1973) & \\ \hline
NS_4551-1 & \\ \hline
NS_4551-2 & \\ \hline
OSD_EBCDIC_DF03_IRV & \\ \hline
OSD_EBCDIC_DF04_1 & \\ \hline
OSD_EBCDIC_DF04_15 & \\ \hline
PC8-Danish-Norwegian & \\ \hline
PC8-Turkish & \\ \hline
PT & \\ \hline
PT2 & \\ \hline
PTCP154 & \\ \hline
SCSU & \\ \hline
SEN_850200_B & \\ \hline
SEN_850200_C & \\ \hline
Shift_JIS & Shift_JIS\\ \hline
T.101-G2 & \\ \hline
T.61-7bit & \\ \hline
T.61-8bit & \\ \hline
TIS-620 & \\ \hline
TSCII & \\ \hline
UNICODE-1-1 & \\ \hline
UNICODE-1-1-UTF-7 & \\ \hline
UNKNOWN-8BIT & \\ \hline
US-ASCII & \\ \hline
UTF-16 & \\ \hline
UTF-16BE & UTF-16BE\\ \hline
UTF-16LE & UTF-16LE\\ \hline
UTF-32 & \\ \hline
UTF-32BE & \\ \hline
UTF-32LE & \\ \hline
UTF-7 & \\ \hline
UTF-8 & UTF-8\\ \hline
VIQR & \\ \hline
VISCII & \\ \hline
Ventura-International & \\ \hline
Ventura-Math & \\ \hline
Ventura-US & \\ \hline
Windows-31J & \\ \hline
dk-us & \\ \hline
greek-ccitt & \\ \hline
greek7 & \\ \hline
greek7-old & \\ \hline
hp-roman8 & \\ \hline
iso-ir-90 & \\ \hline
latin-greek & \\ \hline
latin-lap & \\ \hline
macintosh & macintosh\\ \hline
us-dk & \\ \hline
videotex-suppl & \\ \hline
windows-1250 & windows-1250\\ \hline
windows-1251 & windows-1251\\ \hline
windows-1252 & windows-1252\\ \hline
windows-1253 & windows-1253\\ \hline
windows-1254 & windows-1254\\ \hline
windows-1255 & windows-1255\\ \hline
windows-1256 & windows-1256\\ \hline
windows-1257 & windows-1257\\ \hline
windows-1258 & windows-1258\\ \hline
windows-874 & windows-874\\ \hline
\end{longtable}

\section{Annex B: Known encodings not present in IANA}

Lists of encoding known to some platforms but not registered to IANA.
This might be incomplete as generating the list proved challenging.
These might still be supported through the \tcode{other} mib, but are not
suitable for interexchange.

\subsection{Windows}
\begin{itemize}
\item 710 Arabic - Transparent Arabic
\item 72  DOS-720	Arabic (Transparent ASMO); Arabic (DOS)
\item 737 ibm737	OEM Greek (formerly 437G); Greek (DOS)
\item 875 cp875	IBM EBCDIC Greek Modern
\item 1361	Johab	Korean (Johab)
\item 57002	x-iscii-de	ISCII Devanagari
\item 57003	x-iscii-be	ISCII Bangla
\item 57004	x-iscii-ta	ISCII Tamil
\item 57005	x-iscii-te	ISCII Telugu
\item 57006	x-iscii-as	ISCII Assamese
\item 57007	x-iscii-or	ISCII Odia
\item 57008	x-iscii-ka	ISCII Kannada
\item 57009	x-iscii-ma	ISCII Malayalam
\item 57010	x-iscii-gu	ISCII Gujarati
\item 57011	x-iscii-pa	ISCII Punjabi
\end{itemize}

\subsection{Iconv}
\begin{itemize}
\item CP1131
\item CP1133
\item GEORGIAN-ACADEMY
\item GEORGIAN-PS
\item CN-GB-ISOIR165
\item Johab
\item MacArabic
\item MacCentralEurope
\item MacCroatian
\item MacCyrillic
\item MacGreek
\item MacHebrew
\item MacIceland
\item MacRoman
\item MacRomania
\item MacThai
\item MacTurkish
\item MacUkraine


\end{itemize}


\begin{thebibliography}{9}

\bibitem[N4830]{N4830}
Richard Smith
\emph{Working Draft, Standard for Programming Language C++}\newline
\url{https://wg21.link/n4830}


\bibitem[N2346]{N2346}
\emph{Working Draft, Standard for Programming Language C}\newline
\url{ http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2346.pdf}


\bibitem[rfc3808]{rfc3808}
I. McDonald
\emph{IANA Charset MIB}\newline
\url{https://tools.ietf.org/html/rfc3808}

\bibitem[rfc2978]{rfc2978}
N. Freed
\emph{IANA Charset Registration Procedures}\newline
\url{https://tools.ietf.org/html/rfc2978}

\bibitem[Character Sets]{mib}
IANA
\emph{Character Sets}\newline
\url{https://www.iana.org/assignments/character-sets/character-sets.xhtml}



\bibitem[iconv encodings]{iconv}
GNU project
\emph{Iconv Encodings}\newline
\url{http://git.savannah.gnu.org/cgit/libiconv.git/tree/lib/encodings.def}

\bibitem[P1868]{P1868}
Victor Zverovich
\emph{Clarifying units of width and precision in std::format}\newline
\url{http://wg21.link/P1868}


\end{thebibliography}

\end{document}
