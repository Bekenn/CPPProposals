% !TeX program = luatex
% !TEX encoding = UTF-8


\documentclass{wg21}

\title{A plan for better template meta programming facilities in C++26}
\docnumber{D2632R0}
\audience{EWG}
\author{Corentin Jabot}{corentin.jabot@gmail.com}

\usepackage{color, colortbl}
\begin{document}
\maketitle

\section{Abstract}

Features such as concepts, \tcode{if constexpr}, and template parameters packs have made Template Meta Programming more powerful and accessible than it was 15 years ago, or even 5 years ago.

However, some programs are still very difficult, if not impossible, to express. Using template meta programming often requires a high level of expertise.
Shortcomings of the core language have been addressed through library features with high compile-time costs and poor user experience.

These problems can be solved by extending the core language or lifting restrictions therein.
The overarching goal is to present a set of features to make generic programming and template metaprogramming easier, faster to compile, and with better compile time diagnostics.

Individual features described in this document are or will be the object of separate proposals from different authors.


\section{Revisions}

\section{Scope and Goals}

\subsection{Not a paradigm shift}

The C++ committee likes big, bold complex, and paradigm-shifting proposals, like concepts and reflection.
This is no such proposal.
Most of the proposed features and highlighted proposals are logical extensions or generalizations of existing features.
Most are patterns that many people have tried to express only to find they can't.
As such the combined goal of the presented features is not as much to make C++ more exciting as it is to make it less surprising and less frustrating.

\subsection{Iterrative Improvements}

This paper touches on pack handling, template template parameters, type deduction, diagnostics, \tcode{constexpr} features, etc.
The features presented have various degrees of maturity and implementation experience.
We need to find a balance between having a good long-term vision of the design space, and incremental improvements, such that well-understood features,
are not held back by more controversial or less mature proposals.
It is not our intention to present a large proposal, but several small to medium-sized proposals with compounded benefits.
We should strive to standardize many of these individual features for C++26.

\subsection{Interraction with reflection}

There is some overlap between what is considered Template Meta Programming, \tcode{constexpr} facilities, and reflection.
The features presented in this paper are orthogonal to reflection (\paper{P1240R2}) and do not intend to compete with reflection features.
As reflection can be used as a mechanism to manipulate types, there will inevitably be some problems that can be solved by both reflection
and template metaprogramming techniques, or a combination of the two. The best tool to use for a given task will be context-dependent,
and this paper does not try to hold any particular tool as the best.
Waiting for reflection should not stop us from improving the rest of the language.

\subsection{Circle}

Many of the features presented in this paper were designed and implemented in Circle by Sean Baxter.
There is a lot of commonality between this paper and the work presented by Sean Baxter at CppNow in May 2022.
This is very much intentional: We were really impressed by this body of work and the underlying philosophy that the language should be incrementally improved
to fit the need of library and user types, rather than relying on arcane, slow to compile, hard to diagnose template meta-programming heroics.


\section{Template parameters}

\subsection{Universal template parameters}

\ednote{TODO}

\subsection{Variable and concept template template parameters}

\ednote{TODO}

\section{Parameter Packs}

Packs are fundamentally sequences of expressions or types.
There exist, however no standard facilities to iterate, index, search, or modify these sequences.
Most techniques to manipulate these sequences rely on recursion and rely on the instantiation of a number of types that is linear - sometimes quadratic - with the size of the packs, leading to high development costs and long compile times.
By improving language support for packs we can, all at once improve compile times, diagnostic messages, and ease of development.

\subsection{Indexing}

One of the most fundamental operations that can be done with a sequence is to index it:
Given an index \tcode{n} and a pack of types, we want to know the \tcode{n}th type, and given a pack of expressions, we want the nth expression.

Here is a meta-programming facility extracting the Nth type:

\begin{colorblock}
template <std::size_t I, typename T, typename ...Ts>
struct nth_element_impl {
    using type = typename nth_element_impl<I-1, Ts...>::type;
};

template <typename T, typename ...Ts>
struct nth_element_impl<0, T, Ts...> {
    using type = T;
};

template <std::size_t I, typename ...Ts>
using nth_element = typename nth_element_impl<I, Ts...>::type;
\end{colorblock}

This code was taken from a \href{https://ldionne.com/2015/11/29/efficient-parameter-pack-indexing/}{blog post} written by Louis Dione in 2015.
This is the most straightforward approach presented.

It's a recursive solution, which is already non-trivial to write for a lot of C++ developers and it is the simple solution presented.
Most importantly, Louis's benchmark shows that this is very slow to compile.

The conclusion of the article, led to Clang implementing a built-in \tcode{__type_pack_element} builtin.

\begin{colorblock}
template <std::size_t N, typename... T>
using nth_element = __type_pack_element<N, T...>;
\end{colorblock}

\href{https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100157}{GCC is considering} a similar facility.

An \href{https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100157}{internet search reveals} a large number of people searching for an answer to this exact problem.

Both \paper{P1858R2} and Circle propose to solve this problem with a pack subscripting operator:

\begin{colorblock}
template<std::size_t N, typename... T>
auto get(T&&... args) -> std::remove_cvref_t<T...[N]> // Indexes a pack of type {
    return args...[N]; // Indexes a pack of expression
}
\end{colorblock}

This can then be used to implement \tcode{std::get} like facilities, simplify standard and library times interfaces, etc.
The following code, for example, implement \tcode{std::variant::variant()}.

\begin{colorblock}
template<class... Types>
class variant {
public:
    constexpr variant()
    noexcept(std::is_nothrow_default_constructible_v<Types...[0]>)
    requires(std::is_default_constructible_v<Types...[0]>);

};
\end{colorblock}

\subsubsection{Negative Indexing}

Both Circle and \paper{P1858R2} propose negative indexing

\begin{colorblock}
template <typename... T>
using Last = T...[-1];
static_assert(std::same_as<Last<int, double, long>, long>);
\end{colorblock}

\tcode{T...[-1]} is equivalent to \tcode{T...[sizeof...(T)-1]}.


This is fairly useful as getting the last element of a pack is a frequent operation.


Pack indexing is covered in more detail in \paper{P1858R2}. \paper{P1858R2} Demonstrate how pack indexing can be used to simplify
\tcode{std::tuple} and tuple-adjacent facilities.

The proposed syntax is valid today however, \href{https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1858r2.html#pack-indexing-ambiguity}{as explained by Barry},
The current meaning (declaring a pack of C arrays without a name) is neither super useful, nor used, nor implemented by all compilers (\href{https://godbolt.org/z/6obhffPTP}{[Compiler Explorer]}).

Pack indexing can be standardized and implemented independently of other features proposed in this paper.

\ednote{mention how C\# handles negative indexes}

\subsection{Pack slicing}

Slicing, or subsetting a pack is also a fairly common operation.
In particular, many constraints or requirements apply to all elements but the first, or all elements but the last.

For examples, \tcode{std::ranges::cartesian_product_view}, and almost all supporting functions is defined as

\begin{colorblock}
template<input_range First, forward_range...Vs>
class cartesian_product_view : public view_interface<cartesian_product_view<First, Vs...>> {};
\end{colorblock}

Because of the different requirements on \tcode{First} and the necessity to be able to extract \tcode{First}
is many places.

Having the ability to take a subset of the pack can simplify that code:

\begin{colorblock}
template<input_range...Vs>
requires (forward_range<Vs...[1:]> && ...)
class cartesian_product_view : public view_interface<cartesian_product_view<Vs...>> {};
\end{colorblock}

Circle supports a third step parameter, which can be used to stride the pack, or reverse it,
and that seems less useful. It is not proposed by \paper{P1858R2}.

It is important to note that slicing yields a pack rather than its elements, so there might be dots on both sides

\begin{colorblock}
auto f(int a, int b);
int g(auto... pack) {
    return f(pack...[1:3]...); // pack...[1:3] slices the pack and ... expands it
}
\end{colorblock}

\subsection{Member Packs}

The ability to declare a pack as a member is covered in \paper{P1858R2}.
This is a critical ability for the implementation of \tcode{mdspan}, \tcode{tuple}, \tcode{variant}, etc.
Current implementation strategies for these classes rely on inheritance as it is possible to inherit from a pack.
But, in addition to creating a large number of templates and therefore slow compile times, such a structure make any further access to the members
difficult to implement.

\begin{colorblock}
template <typename...T>
class tuple {
    [[no_unique_address]] T ...elem;
};
\end{colorblock}

This of course needs to work for unions too

\begin{colorblock}
template <typename...T>
class variant {
    union {
        T ...member;
    };
    std::size_t active_index;
};
\end{colorblock}

Supporting packs as members requires:

\begin{itemize}
\item The ability to declare a pack of members - the syntax here is consistent with function parameter pack declaration
\item Tweaking the CTAD rules for aggregate so that they can support deducing the size of the pack
\item Supporting initializing a pack in the member initializer list. However, this requires special consideration. We might want to not initialize the whole pack in the same way.

\begin{colorblock}
template <typename...T>
struct s {
     T ...member;
     s() : member()... {}; // default construct a pack
     s(auto... args) : member(args)... {}; // with arguments
     s() : member...[0](42), member()... {}; // handle one of the member differently
};
\end{colorblock}

\item Default member initializer: We probably want to support initializing a member pack with a pack ( such that each member is initialized with a different value). This is of lesser importance.

\end{itemize}

C++ already supports member packs. But only in a limited capacity: they can appear in
the closure object of a lambda expression.
As demonstrated by Eric Niebler, this can be leveraged to implement a \tcode{std::tuple}-like type.
Despite the challenge of implementation (due, once again to the lack of pack indexing, etc),
leveraging the ability to declare member packs in lambdas results in 1.6x faster compile times
\href{https://build-bench.com/b/xRgaBoiALe2hMmdYtiJnGCfePIA}{[Benchmark]}.

This demonstrates the need for making this ability a first-class feature.

\subsection{Pack in non pack contexts}

\ednote{TODO}

\subsection{Packs in structured bindings}

cf \paper{P2484R0}

\ednote{TODO}

\subsection{Non-trailing packs}

cf \paper{P2347R0}

\ednote{TODO}

\subsection{Integer sequences and their indexing}

Circle offers the following facilities to generate a list of integers as a pack of variables:

\begin{itemize}
\item \tcode{int...(N)} : Generate a pack of \tcode{N} consecutive integers starting at 0
\item \tcode{int...(begin:end:step)} : Generate a pack of integers in the range \range{begin}{end} with a step of \tcode{step}.
\end{itemize}

These features are nice to have but far from necessary.

First, it is important to note that most use cases for integer sequences can be replaced by other features presented in this paper,
such as pack indexing and expansion statements, and that, once we have these facilities, it is not clear that the need for a
pack of integers will be frequent enough to warrant a language feature.

Second, the syntax chosen by Circle is entirely workable but also a bit surprising.
Ideally, we would want a pack size type to be \tcode{std::size_t}, and so the token \tcode{int...} may lead to confusion.

But lastly, it is not clear that producing a pack in that way is the better solution.
It is for example possible to extend \tcode{std::integer_sequence} to be compatible with the tuple protocole.

\begin{colorblock}
namespace std {
    template <class T, T... N>
    struct tuple_size<integer_sequence<T, N...>>
    : integral_constant<size_t, sizeof...(N)>
    { };

    template <size_t I,  class T, T... N>
    struct tuple_element<I, integer_sequence<T, N...>> {
        using type = T;
    };

    template <std::size_t I,  class T, T... N>
    constexpr auto get(std::integer_sequence<T, N...>) {
        return N...[I];
    }
}
\end{colorblock}

But taking this idea further, we can observe that any constexpr random access range can be turned into a destructurable type, and therefore, a pack.

\begin{colorblock}
template<auto Rng>
requires std::ranges::random_access_range<decltype(Rng)>
struct destructurable_range {
    using value_type = std::ranges::range_value_t<decltype(Rng)>;
    using reference  = std::ranges::range_reference_t<decltype(Rng)>;
    static constexpr auto & range = Rng;

    template <std::size_t I>
    constexpr auto get() {
        return range[I];
    }
};

namespace std {
    template <auto Rng>
    struct tuple_size<destructurable_range<Rng>>
    : integral_constant<size_t, ranges::size(destructurable_range<Rng>::range)>
    { };
    template <size_t I,  auto Rng>
    struct tuple_element<I, destructurable_range<Rng>> {
        using type = typename destructurable_range<Rng>::value_type;
    };
}
\end{colorblock}

This lets us use any range algorithm to produce a sequence:

\begin{colorblock}
auto [... elems] = destructurable_range<std::views::iota(3, 10)>{};
return (0 + ... + elems);
\end{colorblock}


This however relies on ranges being structural types (see \paper{P2484R0}).
There is at least the intent that \tcode{std::vector} should be a structural type so, at least the following should be supported:

\begin{colorblock}
auto [... elems] = destructurable_range<std::views::iota(3, 10) | std::ranges::to<vector>>{};
return (0 + ... + elems);
\end{colorblock}

\subsection{Index of the current expansion}

Usage experience in Circle shows that it is very frequently useful
to know the current index of an expansion.

For example, lets consider this \tcode{std::tuple} constructor constructing from a tuple-like type
(requirements omitted for simplicity).

\begin{colorblock}
template<typename... Ts>
struct tuple {
    Ts ...elem;
    template<typename A, typename B>
    tuple(std::pair<A, B> && u)
    : elem(std::get</*????*/>(std::forward<decltype(u)>(u)))... { }
};
\end{colorblock}

We want to initialize each member \tcode{elem} (which is a pack), with the corresponding member of the \placeholder{tupkle-like} object.
In some contexts, we could use a combination of expansion statements, \tcode{iota}, and pack indexing.
However, in addition to being verbose and not super ergonomic, in some contexts, such as in member initializers, it's not possible at all.
Ideally, we would want to be able to expand the index of the current expansion, as to call \tcode{get<0>(u), get<1>(u)}, etc.

This can be achieved, with the feature presented so far, with a library solution.
We can introduce an \tcode{index_sequence} to that effect. We use the following utility for readability and to avoid constructing multiple objects in the expansion

\begin{colorblock}
template <template auto... Args>
constexpr inline std::make_index_sequence<sizeof...(Args)> pack_index;
\end{colorblock}

Which can then be used to generate an index for each expansion

\begin{colorblock}
template<typename... Ts>
struct tuple {
    Ts ...elem;
    template<typename A, typename B>
    tuple(std::pair<A, B> && u)
    : elem(std::get<std::pack_index<Ts...>.[:]>(std::forward<decltype(u)>(u)))... { }
};
\end{colorblock}

Note that because \tcode{index_sequence} is a tuple-like/destructurable type and not a pack, we need to index into that type explicitly using \tcode{.[:]}.
But this is not ideal. While workable, it has some usability issues and certainly is not as compile-time performant as it could be.

Because it comes up very frequently, Circle has a dedicated language feature to yield the index of the current expansion.
Circle spells this feature \tcode{int...}.

\begin{colorblock}
template<typename... Ts>
struct tuple {
Ts ...elem;

template<typename A, typename B>
tuple(std::pair<A, B> && u)
 // elem...[0](std::get<0>(forward<decltype(u)>(u))), elem...[1](std::get<1>(forward<decltype(u)>(u)))
: elem(std::get<int...>(std::forward<decltype(u)>(u)))...
{ }
};
\end{colorblock}

There again the \tcode{int...} works - and is unambiguous even if \tcode{int...} can already appear in a template parameter list.
However, it could be confusing given it certainly yields a \tcode{size_t} rather than an \tcode{int}.

An alternative would be to use \tcode{[:]} which is consistent with \tcode{tuple.[:]} and not used in another context.
It also does not have an ellipsis which improves readability.
The specific syntax can be left to bikeshedding, the important point is that indexing an expansion is a very useful, and common operation,
which the core language should support.


\subsection{Pack aliases}

One interesting feature introduced in \paper{P1858R2} is the ability to declare a pack alias.
A compelling use case is presented in \paper{P2120R0}

\begin{colorblock}
    template <typename... Ts>
    class tuple {
        [[no_unique_addres]] Ts... elems;
    public:
        using ...tuple_elements = Ts;
        template <size_t I>
        constexpr const auto& get() const& {
            return elems...[I];
        }
    };
\end{colorblock}

This could be used by the language and the library as a simplification of the tuple protocol.
It could also be used to implement meta algorithms.

\begin{colorblock}
    template<typename...T>
    using ...unique_types = __builtin_unique_types<T...>;
\end{colorblock}

We could assume \tcode{__builtin_unique_types} is a builtin that deduplicate the types in \tcode{T...} and produces a pack.
Given that this is a common operation in the sender/receiver world, such a builtin would be useful.

In effect, currently, all meta algorithms operating on packs can only be manipulated through type lists,
and using \tcode{apply}/\tcode{quote} meta functions, as for example in MP11 or Eric Niebler's \tcode{meta} library.

Pack aliases allow meta-algorithm whose results are types.
This has the potential to simplify meta-programming heavy libraries, including much of the sender/receiver machinery.


For completeness, lets see if we can implement \tcode{unique_types} using reflection.
We are going to make some assumptions:

\begin{itemize}
    \item \tcode{std::set} is constexpr (it currently isn't).
    \item \tcode{std::vector<std::meta::info>} is a structural types.
\end{itemize}

\begin{colorblock}
template <std::meta::info i>
using reify =  typename[:i:];

template<auto range_of_meta_info>
using ...unique_types_impl = reify<rng.[:]>...;

template<typename...T>
using ...unique_types =
    unique_types_impl<destructurable_range<[] {
                std::vector<std::meta::info> v{^T...};
                auto [last, end] = std::ranges::unique(v);
                v.erase(last, end);
                return v;
            }()>{}>;
\end{colorblock}

In the above code, we first reflect on types - \tcode{meta::info} then contains a \tcode{meta::info} object for each type.
We can use regular algorithms to remove duplicates.
This deduplicated vector can then be lifted back to the template/type world by using an NTTP. We wrap it in \tcode{destructurable_range}
so that the vector - which is a constexpr random access sized range - acts as a destructurable type.
Which we can then expand and reify, giving us, a pack of types back.


\subsubsection{Pack Aliases in Sender/Receivers}

Senders/Receivers \paper{P2300R5} need a mechanism to check whether a given sender can be connected to a receiver.
In effect, a sender may produce different value types, and each such value is itself multiple arguments.

This is explained in \href{https://github.com/facebookexperimental/libunifex/blob/main/doc/concepts.md}{libunifex}'s documentation

\begin{colorblock}
    struct some_typed_sender {
        template<template<typename...> class Variant, template<typename...> class Tuple>
        using value_types = Variant<Tuple<int>,
        Tuple<std::string, int>,
        Tuple<>>;
    };
\end{colorblock}
This sender supports the following methods:
\begin{itemize}
    \item \tcode{set_value(R\&\&, int)}
    \item \tcode{set_value(R\&\&, std::string, int)}
    \item \tcode{set_value(R\&\&)}
\end{itemize}
To query these set of value types the documentation advises using the following pattern

\begin{colorblock}
    typename unifex::sender_traits<some_typed_sender>::template value_types<std::variant, std::tuple>
\end{colorblock}

Every subsequent manipulation of these types - such as concatenation, deduplication, etc - which are common operations needs to
use a mix of \tcode{apply} and \tcode{quote} meta functions.

Pack aliases can let us simplify the interface.

\begin{colorblock}
    template <typename... T>
    struct sender_args {
        using... types = T;
    };

    template <typename... T>
    using ...pack = T;

    struct some_typed_sender {
        using ...value_types = pack<
            sender_args<int>,
            sender_args<std::string, int>,
            sender_args<>
        >;
    };
\end{colorblock}

\subsection{Single level of packness}

\tcode{unifex::sender_traits<some_typed_sender>::value_types} is a pack of \tcode{sender_args}, and \tcode{sender_args} represents a
pack of types. Pack of types?
This is tempting, but here probably lies madness.
The author spent some time trying to figure out how multiple levels of packness could possibly work in the general case. For example, could we
write a \tcode{sender_of} concept as a one-liner?

\begin{colorblock}
    template<class S, class... Ts>
    concept sender_of = ((same_as<Ts,
    typename unifex::sender_traits<some_typed_sender>::value_types::types && ...) || ...);
\end{colorblock}

I don't think there is a good model to make that work, and it should probably not be attempted.
It is almost always possible to construct a wrapper such that there is never more than one level of packness.

\begin{colorblock}
    template<class S, class Args>
    concept sender_of_impl =
    (same_as<Args, unifex::sender_traits<some_typed_sender>::value_types::types> && ...);

    template<class S, class... Ts>
    concept sender_of = sender_of_impl<S, sender_args<Ts...>>;
\end{colorblock}


Some operations would benefit from multi level pack supports, namely \tcode{concat/join}-like operations (\tcode{tuple_cat} for example).
We do not have a perfect solution to this.

Circle uses what it calls "argument-for".

\begin{quoteblock}
\emph{argument-for} is a  \emph{generic-argument} construct. It loops over types, non-types, templates, a counter or a multi-dimensional set of counters, from inside an argument list. Circle hasn't yet added syntax for nested pack expansion; it's possible, but complicated. argument-for is the tool for effecting this same thing.
\end{quoteblock}

This is an interesting feature which is a limited form of code injection (see \paper{P2237R0}) to produce types and expressions imperatively.

With this, \tcode{tuple_cat} can be implemented as follow:

\begin{colorblock}
    template<class... Tuples>
    constexpr tuple<
    for typename Ti : Tuples =>
        typename std::remove_cvref_t<Ti>::tuple_elements...
    >
    tuple_cat(Tuples&&... tpls) {
        return {
            for i, typename Ti : Tuples => std::forward<Ti>(tpls...[i])...
        };
    }
\end{colorblock}

It might be interesting to explore this in the future depending on how reflection and code injection evolves.
It is the most novel feature presented here, and as powerful as it could be, it has a less compelling cost/benefit than other features presented in this paper.
Reflection should be good enough as the imperative mechanism, and we should avoid having too many ways to do the same operations.
We certainly should revisit that question if reflection does not progress or proves unsuitable.

\subsection{Packs as return values}

Because tuple and packs are isomorphic, Supporting packs as return values does not have semantic or expressiveness benefits over returning a tuple.

\begin{colorblock}
tuple<int, int> f();
void g(auto...);

int main() {
    g(f().[:]...); // expands the return value of f() into g.
}
\end{colorblock}

However, Lewis Baker noticed that this inhibits RVO and that there may be value in supporting packs as return values so that RVO can be supported.

A possible solution would be

\begin{colorblock}
void g(auto...);
auto f() -> ...(int, float) {
    return ...(42, 3.14f);
}

auto [i, f] = f();
g(f()...); // performs rvo
\end{colorblock}


More research is necessary.

\section{Control flow statements/expressions}

\subsection{Expansion statements}

\ednote{todo}
cf \paper{P1306R1}

\subsection{Constexpr conditional: \tcode{constexpr?}}

Circle has a constexpr ternary conditional operator.
It is the ternary equivalent to \tcode{if constexpr}.
Circle spells that operator \tcode{??}

\begin{colorblock}
@\placeholder{constant-expression}@ ?? a : b
\end{colorblock}

If \placeholder{constant-expression} is true, the expression is equivalent to \tcode{a}, otherwise \tcode{b}.
Unlike the regular ternary operator, there are no common type requirements between the two branches.
Like \tcode{if constexpr}, the branch that will not be evaluated is discarded - and need not be semantically valid.

This constexpr equivalent to \tcode{?:} is very useful where \tcode{if constexpr} might prove impractical to use, such as
in a member initializer list - It can be emulated with an immediately invoked lambda.

The following example illustrates how this operator is used inside Circle's \tcode{mdspan} implementation:

\begin{colorblock}
template<size_t... Extents>
struct extents {
    [[no_unique_address]] storage_t<Extents> ...m;

    template<SizeType... IndexTypes>
    constexpr extents(IndexTypes... exts) :
        m( dynamic_extent == Extents ??  exts...[find_dynamic_index<[:]>] : Extents)... { }
};
\end{colorblock}

To avoid conflicts with \paper{P2561R0}, but also to improve readability, we propose \tcode{constexpr?} for the syntax of this new operator instead.

\begin{colorblock}
@\placeholder{constant-expression}@ constexpr? a : b
\end{colorblock}

This is a nice to have feature, that simplifies code that can be written differently, but it is also an easy feature to specify and implement.

\subsection{multi-conditional: \tcode{...?  : }}

\begin{colorblock}
@\placeholder{expended-pack-of-convertible-to-bool-expressions}@ ...? pack_of_expression : expression
\end{colorblock}

This operator, present in Circle, works like a conditional operator but operates on an expended pack of conditions, and a pack of expression.
And return the corresponding expression for the first true condition. The else expression is returned when no condition is true:

\begin{colorblock}
int find_true(auto... b) {
    return b ...? int... : -1;
}

int main() {
    assert(find_true() == -1);
    assert(find_true(false) == -1);
    assert(find_true(true) == 0);
    assert(find_true(false, true) == 1);
    assert(find_true(false, true, true) == 1);
}
\end{colorblock}

With a pack of boolean and b a pack of expression, all of size 3, the following expression:

\begin{colorblock}
a... ...? b : c
\end{colorblock}

Is equivalent to

\begin{colorblock}
a...[0]? b...[0] : a...[1] ? b...[1] : a...[2] ? b...[2] : c;
\end{colorblock}


There is a surprisingly high number of use cases for such an operator.
It's a nice way to find a correspondence between a runtime condition and a compile-time table.

\begin{colorblock}
template <typename...Ts>
class variant {
    union {
        Ts ...member;
    };
    std::size_t active_index;
    ~variant() {
        _index == [:] ...? member.~Ts() : std::unreachable();
    }
};
\end{colorblock}

This is roughly semantically equivalent to:

\begin{colorblock}
template <typename...Ts>
class variant {
    ~variant() {
        template for(constexpr auto idx : pack_index<Ts...> )  {
            if(idx == active_index) {
                member...[idx].~Ts...[idx](); ?
                break;
            }
        }
    }
};
\end{colorblock}

\subsection{Constexpr multi-conditional \tcode{... constexpr?:}}

\tcode{... constexpr?:} is the logical combination of \tcode{...?:} and \tcode{constexpr?:}

Like  \tcode{constexpr?:}, it evaluates conditions at compile time, does not require common type and the branch not taken are discarded,
and like \tcode{...?:}, the (constant) conditions, and the expressions are packs.

\begin{colorblock}
template<typename Arg, typename... Fn>
auto call_first(Arg&& arg, Fn&&... f) {
    return std::invocable<Fn, Arg> ...constexpr? f(std::forward<Arg>(arg)) : []<typename...> {
        static_assert(false, "No valid function");
    }();
}
\end{colorblock}

\tcode{... constexpr?:} is less compelling than either \tcode{...?:} and  \tcode{constexpr?:}, but it falls out naturally of these two things,
and should be considered for completeness.

Note that, for better compatibility with packs and code patterns like the one above, Circle treats \tcode{static_assert} as an expression.

\section{Algorithms on packs}

We have already seen how pack aliases alleviate the need for many meta-programming facilities,
such as \tcode{quote}.
Indeed, we can write algorithms manipulating packs of types, rather than type lists.
This makes a huge difference.
We can also use reflection to use iterative programming, and existing range algorithms.

This does not mean there isn't some value for part of the algorithms presented in \tcode{P0949R0}
to be standardized, in a form that yields packs when relevant.
It also does not mean that a \tcode{type_list} type would not be useful.
Indeed, it allows separating different packs.

\begin{colorblock}
template<typename... Types>
struct type_list{
    using ...types = Types;
};

template<typename... Types>
struct concat;
template<typename... Types, typename... UTypes>
struct concat<type_list<Types...>, type_list<UTypes...>> {
    using ...types = type_list<Types..., UTypes...>...;
};
\end{colorblock}

The standard should consider providing standard meta algorithms for some common operations to allow an implementation to provide them as built-ins. primes candidate would be \tcode{unique}, and N-arry \tcode{join}.

% \subsection{Circle's \tcode{.filter} meta function}


\section{Other improvements desirable to improve template meta programming and generic programming}

\subsection{std::is_structured_type}

A type trait indicating whether a given type can be destructured can be useful, for example, to implement a generic
formatter/serializer.

\subsection{\tcode{constexpr} structured bindings}

Structured bindings are one of the rare features not supported in \tcode{constexpr} contexts.
As we make structured bindings more useful, by supporting packs.

This is discussed in \paper{P1481R0}(Nicolas Lesser).

\subsection{\tcode{std::forward} in the language}

In generic library, \tcode{std::forward<decltype(x)>(x)} is rather tedious to write, and
many prominent C++ experts suggest defining a macro.

\begin{colorblock}
#define FWD(x) std::forward<decltype(x)>(x)
\end{colorblock}

Others resort to using static_cast (or C casts!) - in part for performance reasons.
Note that both GCC and Clang now understand \tcode{std::forward} in the front end to guarantee it never generates code,
improving debug performances.

\paper{P0644R1} (Barry Revzin) proposes a very nice solution to this problem.

\subsection{Diagnostics improvements}

Two common complaints about meta-programming are the compile times,
and the diagnostics messages.
The various presented thus far improve both issues. By lifting common features in the compiler,
we can reduce drastically compile times (a lot fewer types need to be created when instantiating \tcode{tuple}, for example), and improve diagnostics message (again, because the code becomes much simpler).

However, more can be done to improve diagnostics.

\subsubsection{\tcode{static_assert} using expressions as messages}

Being able to pass string-like expressions (ranges of \tcode{char}, or \tcode{char8_t}) to \tcode{static_assert},
would allow libraries to construct better diagnostic messages.

\begin{colorblock}
template <std::string str>
constexpr auto ctre_compile() {
   constexpr std::expected<regex, error> res = do_compile(str);
   if constexpr(!res) {
       static_assert(res, std::format(u8"Invalid regex '{}': {} at column {}",
                                      str, res.error().message(), res.error().column()));
   }
}
\end{colorblock}

\subsubsection{\tcode{static_assert} pack}

Circle treats \tcode{static_assert} a bit like an expression to support it in multi conditionals, and to have packs of \tcode{static_assert}.

\begin{colorblock}
template<class... Types>
constexpr bool operator<(const variant<Types...>& v,  const variant<Types...>& w) {
    static_assert(requires{ (bool)(get<[:]>(v) < get<[:]>(w)); },
        std::format("{} has no operator<", std::meta::name_of(^Types)))...;
}
\end{colorblock}

There have also been efforts to support \tcode{static_assert} in non dependant contexts \paper{P2593R0},
and \paper{P2593R0} explores a mechanism that could be adapted to support user-crafted warnings.

\section{How do these things fit together?}

The features presented in this paper do not compete with one another, nor do they compete with one another.
They also do not compete with reflection, nor do they compete with one another.
We should make the simplest things simple, and the more complicated things, slightly more involved.

Reflection, for example, can be used to implement type traits. It allows to express more complex or stateful algorithms but doesn't have the expressivity of a fold expression.

Yet, we have to admit that there are a lot of moving pieces.

\subsection{Structured Types, \tcode{std::tuple}, ranges, packs}

\tcode{std::tuple} is a standard structured type. That is, a type that holds variables of heterogenous (non-type-erased) types,
and which can be decomposed - using structured binding or the tuple-protocol, at compile time.

A pack then is an unstructured list of types or variables, which makes a tuple a way to wrap a pack.
A tuple and a pack of variables are isomorphic, and a type list and a pack of types are also isomorphic (a tuple can also be used as a type list).

Whether a wrapper is useful (and whether one should use a pack or a tuple) is context-dependent.
Functions and algorithms usually require a tuple or another kind of structured type.

Ranges are homogeneous and mutable types, so at first glance unrelated.
However, a constexpr range can be turned into a tuple or a pack. and a homogenous pack can be turned into a range.

Further, using reflection, packs of types or heterogenous packs of values can be turned into a range of their reflection, and back again.
This gives us a bridge between the template meta-programming world and the imperative world.
Various reflection papers have proposed short-hand syntax to reify ranges of \tcode{meta::info} into a pack.
But this can be emulated using NTTP.
However, to make this work, we need something along the lines of \paper{P2484r0}

\subsection{On native types}

\subsubsection{Language variants}

\paper{P0095R2} proposes a new kind of entity representing a variant, in the core language.
However, the problems presented in the paper, are not as much as with \tcode{std::variant} as they are with \tcode{std::visit}.
The paper also admits that the tradeoffs made by \tcode{std::variant} are not always ideal and proposes a different set of tradeoffs... which
way also not be ideal.

The solution, in our mind, is not to move high-level opinionated constructs in the core language, but rather to make these types easier to write,
and to support pattern matching, in the same way, the tuple protocol enables structured bindings for user types.

\subsubsection{Language tuples}

\paper{P2163R0}

\ednote{TODO}

\section{Priorities and status}

The following table attempts to classify the features discussed in this paper by some order of priority.
This is based on both the usefulness of individual features and their maturity/risk.

Tier 1 features are extremely well understood, can be standardized independently of one another (as long as we maintain consistency),
They have a great cost/benefits ratio.
Pack alias in particular can be used by sender/receiver.
Other features in tier 1 can simplify drastically, and improve the compile times of standard types.

Tier 2 features have more complexity or more risks associated with them, or slightly less usefulness.
Both Tier 1 and Tier 2 features should target C++23.

Tier 3 features may be useful but carry more risk and need more research. They could be considered for a future C++ version.

Tier 4 features either seem redundant with other features (existing or in that list) or have a level of complexity/low return on investment.

\definecolor{Tier1}{rgb}{0.675, 0.950, 0.739}
\definecolor{Tier2}{rgb}{0.950, 0.960, 0.346}
\definecolor{Tier3}{rgb}{1.00, 0.728, 0.320}
\definecolor{Tier4}{rgb}{0.960, 0.329, 0.259}
\renewcommand{\arraystretch}{1.5}
\setlength\LTleft{-20mm}
\begin{longtable}{p{80mm}p{30mm}p{30mm}p{50mm}}\hline
    \hline
    Feature & Paper & In Circle? & Other\\
    \midrule
    \midrule
    \textbf{Tier 1} \\

    \rowcolor{Tier1}Pack Indexing & \paper{P1858R2} & \checkmark &\\
    \rowcolor{Tier1}Member Pack& \paper{P1858R2} &  \checkmark &\\
    \rowcolor{Tier1}Pack Aliases& \paper{P1858R2} &  \checkmark &  \\
    \rowcolor{Tier1}Packs in structured bindings& \paper{P1858R2} &  \checkmark & Implemented in clang \\
    \rowcolor{Tier1}Unpacking structured types& \paper{P1858R2} &  \checkmark &  \\
    \rowcolor{Tier1}\tcode{constexpr} structured bindings & \paper{P1481R0} &  \checkmark &  \\
    \rowcolor{Tier1}\tcode{static_assert(false)} & \paper{P2593R0}  & \checkmark  &  Implemented in GCC \\
    \rowcolor{Tier1}\tcode{constexpr}/pack ternary&  & \checkmark  (...??) &  \\
    \rowcolor{Tier1}Index of the current expansion&  & \checkmark  (int...) &  \\
    \rowcolor{Tier1}Expansion statements& \paper{P1306R1} & \checkmark &  \\
    \midrule
    \midrule
    \textbf{Tier 2} \\
    \rowcolor{Tier2}Reflection& \paper{P1240R2} & \checkmark &  \\
    \rowcolor{Tier2}Non-transient constexpr allocation & \paper{P1974R0} & & \\
    \rowcolor{Tier2}Generalized structural types & \paper{P2484R0} & & \\
    \rowcolor{Tier2}Deducing forwarding reference& \paper{P2481R1} & \checkmark &  \\
    \rowcolor{Tier2}Pack Slicing& \paper{P1858R2} & \checkmark &  \\
    \rowcolor{Tier2}Universal template parameters & \paper{P1985R1} & \checkmark & \\
    \rowcolor{Tier2}Variable template template params & & \checkmark & \\
    \rowcolor{Tier2}Concept template template params & & \checkmark & \\
    \rowcolor{Tier2}Deleting variable templates  & \paper{P2041R1} & &\\
    \rowcolor{Tier2}Packs outside of templates& \paper{P1858R2} &  \checkmark &  \\
    \rowcolor{Tier2}~ & \paper{P2277R0} &  ~ & ~ \\
    \hline
    \rowcolor{Tier2}Non-trailing parameter packs deduction& \paper{P2347R0} &  & Implemented in Clang \\
    \hline
    \rowcolor{Tier2}\tcode{std::forward} in the language& \paper{P0644R1} &  &  \\
    \rowcolor{Tier2} Simplified structured bindings protocol & \paper{P2120R0} & & \\
    \hline
    \rowcolor{Tier2}CPO for \tcode{std::get} & & & \\
    \hline
    \rowcolor{Tier2}\tcode{std::is_structured_type} &  &  \checkmark (\tcode{__is_structured_type}) &  \\
    \hline
    \rowcolor{Tier2}\tcode{static_assert} with expression as message &  &  &  \\
    \hline
    \rowcolor{Tier2}\tcode{static_assert} packs &  & \checkmark&  \\
    \midrule
    \midrule
    \textbf{Tier 3} \\
    \rowcolor{Tier3}Packs as return value&  &  &  \\
    \rowcolor{Tier3}Destructuring aggregates/C-arrays& \paper{P2141R0} \paper{P2580R0}  &  &  \\
    \rowcolor{Tier3}Pack literals&  &  &  \\
    \rowcolor{Tier3}Default values for pack&  &  &  \\
    \rowcolor{Tier3}Meta algorithms (\tcode{unique}, etc)&  &  &  \\
    \rowcolor{Tier3}Regular \tcode{void} & \paper{P0146R1} && \\
    \rowcolor{Tier3}Algorithms on packs in the language&  & \checkmark &  \\
    \rowcolor{Tier3}Code injection/Circle Imperative arguments&  & \checkmark &  \\

    \midrule
    \midrule
    \textbf{Not deemed worthy} \\
    \rowcolor{Tier4}Multiple levels of pack expansions&  &  &  \\
    \rowcolor{Tier4}Language variants&  &  &  \\
    \rowcolor{Tier4}Pack of variables declaration&  &  &  \\
    \rowcolor{Tier4}Index sequences in the core language&  & \checkmark &  \\
    \rowcolor{Tier4}Step for pack slicing&  & \checkmark &  \\
    \rowcolor{Tier4}Dot syntax on types/enums/basic types&  & \checkmark &  \\
    \hline
\end{longtable}


\section{References}
\renewcommand{\section}[2]{}%
\bibliographystyle{plain}
\bibliography{wg21, extra}

\begin{thebibliography}{9}

\bibitem[N4885]{N4885}
Thomas Köppe
\emph{Working Draft, Standard for Programming Language C++}\newline
\url{https://wg21.link/N4885}


\end{thebibliography}

\end{document}
