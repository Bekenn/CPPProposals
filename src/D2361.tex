% !TeX document-id = {9322a846-f757-4574-9231-a2e85c743b21}
% !TeX program = luatex
% !TEX encoding = UTF-8


\RequirePackage{luatex85}%
\documentclass{wg21}


\RequirePackageWithOptions{fontspec}
\usepackage{newunicodechar}

\setmainfont{Noto Sans}

\title{Unevaluated strings literals}
\docnumber{P2361R0}
\audience{SG-16, EWG}
\author{Corentin Jabot}{corentin.jabot@gmail.com}
\authortwo{Aaron Ballman}{aaron.ballman@gmail.com}

\usepackage{tikz}
\usepackage[twitter]{emoji}

\begin{document}

\maketitle

\section{Abstract}

\grammarterm{string-literal}{s} can appear in a context where they are not used to
initialize a character array, but are used at compile time for diagnostic messages,
preprocessing, and other implementation-defined behaviors.
This paper clarifies how compilers should handle these strings.


\section{Motivation}

A \tcode{string-literal} can appear in \tcode{_Pragma}, \tcode{asm}, \tcode{extern},
\tcode{static_assert}, \tcode{[[deprecated]]} and \tcode{[[nodiscard]]} attributes...

In all of these cases, the strings are exclusively used at compile time by the compiler, and are as such not evaluated in phase 6.
This means they should not be converted to the narrow encoding or any literal encoding specified by an encoding prefix (L, u, U, u8).

Their encoding should therefore not be constrained or otherwise specified,
except that these strings can contain any Unicode characters.

\section{Proposal}

We propose than in all of these cases:
\begin{itemize}
\item No prefix is allowed
\item The string is not converted to the execution encoding.
\item \tcode{universal-character-name} and \tcode{simple-escape-sequence} (except \tcode{\textbackslash 0} ) are replaced by
the corresponding Unicode codepoints, and other escape sequences are ill-formed.
\end{itemize}

This last point is important. Because the encoding the compiler will convert these strings to is not known, and because UCNs can represent any Unicode characters,
numeric-escape-sequences have no use beyond forcing the compiler to contend with invalid
code units in diagnostic messages.

All of these changes are breaking changes.
However, a survey of open source projects tend to show that none of the restrictions added
impact existing code.

\textbf{This proposal does not specify how unevaluated string literals are presented in diagnostic messages}.

\section{Alternative considered}

\subsection{Allowing and ignoring any prefix}

This is arguably the status quo.
The issue is that it is hard to teach. Users should be able to expect for example that L"X"
is always in the wide execution encoding.
It could be argued that \tcode{"foo"} not being in the narrow-encoding is also confusing, however, there is precedence for that in headers names (which are already not \grammarterm{string-literals}{s}).

\subsection{Allowing prefixes and encode all strings using that prefix}

his is both implementer- and user-hostile It would force users to use any of u, u8, U
on all of their \tcode{static_assert} which contain non-ASCII characters as it is the only way to obtain a portable encoding.
It has the advantage of being mostly consistent (all strings except those in headers names would be encoded using the encoding associated with their prefix) but would break
existing code using non-ASCII characters in \tcode{static_assert} and attributes and
litter C++ code with these prefixes, which seems to be a net negative.

\section{Compilers survey}

\subsection{_Pragma}

In \tcode{_Pragma} directives, the standard specifies that the \tcode{L} prefix is ignored.
In C, all encoding prefixes are ignored. This divergence is highlighted in \paper{CWG897}.
MSVC does not support \tcode{_Pragma(L"")}.  Only Clang supports other prefixes in \tcode{_Pragma}.

Out of the 90 millions lines of code of the 1300+ open source projects available on vcpkg, a
single use of that feature was found within clang’s lexer test suite, for a total of 2000 uses
of \tcode{_Pragma}. Similarly, the only uses of \tcode{_Pragma (u8"")}, \tcode{_Pragma (u"")}, \tcode{_Pragma (U"")}, etc were
found in Clang’s test suite (both because these are valid C and because neither GCC nor Clang
are conforming, only \tcode{L""} is described as valid by the C++ standard).

\subsection{Attributes}

Clang does not support strings with an encoding prefix in attributes, other compilers accept them.

\pagebreak

\subsection{\tcode{static_assert}}

All compilers support strings with an encoding prefix in static assert.
MSVC appears to convert the string to the encoding associated with that prefix before displaying it, producing mojibake if a string
cannot be represented in the literal encoding.
The following diagnostics are emmited by MSVC with \tcode{/execution-charset:ascii}:
\begin{quoteblock}
\begin{codeblock}
static_assert(false, "Your code is on @\emoji{1F525}@");

<source>(1): warning C4566: character represented by universal-character-name 
'\u00F0'  cannot be represented in the current code page (20127)
<source>(1): warning C4566: character represented by universal-character-name 
'\u0178'  cannot be represented in the current code page (20127)
<source>(1): warning C4566: character represented by universal-character-name 
'\u201D' cannot be represented in the current code page (20127)
<source>(1): warning C4566: character represented by universal-character-name
'\u00A5' cannot be represented in the current code page (20127)
<source>(1): error C2338: ????


static_assert(false, u8"Your code is on @\emoji{1F525}@");
<source>(1): error C2002: invalid wide-character constant
\end{codeblock}
\end{quoteblock}
\subsection{\tcode{extern} \& \tcode{asm}}

No compiler support strings with an encoding prefix in extern and asm statements.

\subsection{\tcode{\#line}}

GCC and  Clang do not support encoding prefix in \tcode{\#line} directives.

\section{Future direction}

This proposal does not prevent supporting constant expression in \tcode{static_assert} or attributes in
the future; we can imagine the following grammar:

\begin{bnf}
    \nontermdef{static_assert-declaration}\br
    \keyword{static_assert} \terminal{(} constant-expression \terminal{)} \terminal{;}\br
    \keyword{static_assert} \terminal{(} constant-expression \terminal{,} unevaluated-string-literal \terminal{)} \terminal{;}\br
    \keyword{static_assert} \terminal{(} constant-expression \terminal{,} constant-expression \terminal{)} \terminal{;}
\end{bnf}

Those may make \tcode{static_assert(true, u8"foo");} valid again as \tcode{u8"foo"} would be a valid constant expression.


\section{Implementability}

This proposal requires implentations to keep around a non-encoded string for diagnostic purposes.
This has recently come up in a clang patch to support EBCDIC as the literal encoding.
To support diagnostics in this context, especially on a non-EBCDIC platform the original sequence of characters must be retained.
This proposal offers a well-specified, portable mechanism to solve this problem.

\section{Wording Challenges}

Strings are handled in phase 5 and 6 before the program is parsed,
which might force us to have a "reversal" of these phases.

\section{Previous works}

\paper{P2246R1} removes wording specific to attributes mandating that diagnostic with characters
from the basic characters are displayed in diagnostic messages, which was not implementable.

\section{Wording}

\ednote{The wording is relative to N4885 + \paper{P2314R2} applied}


\rSec1[lex.phases]{Phases of translation}%

\ednote{Modify "[lex.phases]/p1.6" as follow}

\begin{enumerate}
\setcounter{enumi}{5}
\item Adjacent \grammarterm{string-literal}s are concatenated and a null character is appended to the result as specified in [lex.string].
\added{Adjacent \grammarterm{unevaluated-string-literal}s are concatenated}.
\end{enumerate}


\rSec1[lex.pptoken]{Preprocessing tokens}

\ednote{Modify "5.4 Preprocessing tokens" as follow}

\indextext{token!preprocessing|(}%
\begin{bnf}
    \nontermdef{preprocessing-token}\br
    header-name\br
    import-keyword\br
    module-keyword\br
    export-keyword\br
    identifier\br
    pp-number\br
    character-literal\br
    user-defined-character-literal\br
    string-literal\br
    \added{unevaluated string-literal}\br
    user-defined-string-literal\br
    preprocessing-op-or-punc\br
    \textnormal{each non-whitespace character that cannot be one of the above}
\end{bnf}

\pnum
Each preprocessing token that is converted to a token\iref{lex.token}
shall have the lexical form of a keyword, an identifier, a literal,
or an operator or punctuator.

\pnum
A preprocessing token is the minimal lexical element of the language in translation
phases 3 through 6. The categories of preprocessing token are: header names,
placeholder tokens produced by preprocessing \tcode{import} and \tcode{module} directives
(\grammarterm{import-keyword}, \grammarterm{module-keyword}, and \grammarterm{export-keyword}),
identifiers, preprocessing numbers, character literals (including user-defined character
literals), string literals (including user-defined string literals \added{and unevaluated string literals}), preprocessing
operators and punctuators, and single non-whitespace characters that do not lexically
match the other preprocessing token categories. If a \tcode{'} or a \tcode{"} character
matches the last category, the behavior is undefined. Preprocessing tokens can be
separated by
\indextext{whitespace}%
whitespace;
\indextext{comment}%
this consists of comments\iref{lex.comment}, or whitespace
characters (space, horizontal tab, new-line, vertical tab, and
form-feed), or both. As described in \ref{cpp}, in certain
circumstances during translation phase 4, whitespace (or the absence
thereof) serves as more than preprocessing token separation. Whitespace
can appear within a preprocessing token only as part of a header name or
between the quotation characters in a character literal or
string literal..




\rSec2[lex.string]{String literals}

\ednote{Modify "[lex.string]" as follow}

\begin{bnf}
    \nontermdef{string-literal}\br
    \opt{encoding-prefix} \terminal{"} \opt{s-char-sequence} \terminal{"}\br
    \opt{encoding-prefix} \terminal{R} raw-string
\end{bnf}

\begin{addedblock}
\begin{bnf}
    \nontermdef{unevaluated string-literal}\br
    \terminal{"} \opt{s-char-sequence} \terminal{"}\br
    \terminal{R} raw-string
\end{bnf}
\end{addedblock}

\begin{bnf}
    \nontermdef{s-char-sequence}\br
    s-char\br
    s-char-sequence s-char
\end{bnf}

\begin{bnf}
    \nontermdef{s-char}\br
    basic-s-char\br
    escape-sequence\br
    universal-character-name
\end{bnf}

\begin{bnf}
    \nontermdef{basic-s-char}\br
    \textnormal{any member of the basic source character set except the double-quote \terminal{"}, backslash \terminal{\textbackslash}, or new-line character}
\end{bnf}

\begin{bnf}
    \nontermdef{raw-string}\br
    \terminal{"} \opt{d-char-sequence} \terminal{(} \opt{r-char-sequence} \terminal{)} \opt{d-char-sequence} \terminal{"}
\end{bnf}

\begin{bnf}
    \nontermdef{r-char-sequence}\br
    r-char\br
    r-char-sequence r-char
\end{bnf}

\begin{bnf}
    \nontermdef{r-char}\br
    \textnormal{any member of the source character set, except a right parenthesis \terminal{)} followed by}\br
    \bnfindent\textnormal{the initial \grammarterm{d-char-sequence} (which may be empty) followed by a double quote \terminal{"}.}
\end{bnf}

\begin{bnf}
    \nontermdef{d-char-sequence}\br
    d-char\br
    d-char-sequence d-char
\end{bnf}

\begin{bnf}
    \nontermdef{d-char}\br
    \textnormal{any member of the basic source character set except:}\br
    \bnfindent\textnormal{space, the left parenthesis \terminal{(}, the right parenthesis \terminal{)}, the backslash \terminal{\textbackslash}, and the control characters}\br
    \bnfindent\textnormal{representing horizontal tab, vertical tab, form feed, and newline.}
\end{bnf}

[...]

\pnum
\indextext{concatenation!string}%
In translation phase 6\iref{lex.phases}, adjacent \grammarterm{string-literal}{s} are concatenated. If
both \grammarterm{string-literal}{s} have the same \grammarterm{encoding-prefix}, the resulting concatenated \grammarterm{string-literal} has
that \grammarterm{encoding-prefix}. If one \grammarterm{string-literal} has no \grammarterm{encoding-prefix}, it is treated as a \grammarterm{string-literal} of
the same \grammarterm{encoding-prefix} as the other operand. If a UTF-8 string literal token is adjacent to a
wide string literal token, the program is ill-formed. Any other concatenations are
conditionally-supported with \impldef{concatenation of some types of \grammarterm{string-literal}s}
behavior.
\added{Adjacent \grammarterm{unevaluated string-literal}{s} are concatenated}.

\begin{note}
    This concatenation is an interpretation, not a conversion.
    Because the interpretation happens in translation phase 6
    (after the string literal contents have been encoded in
    the \grammarterm{string-literal}'s associated character encoding),
    a \grammarterm{string-literal}'s initial rawness
    has no effect on the interpretation or well-formedness of the concatenation.
\end{note}

[...]

\pnum
Evaluating a \grammarterm{string-literal} results in a string literal object
with static storage duration\iref{basic.stc}.
\indextext{string!distinct}%
Whether all \grammarterm{string-literal}s are distinct (that is, are stored in
nonoverlapping objects) and whether successive evaluations of a
\grammarterm{string-literal} yield the same or a different object is
unspecified.
\begin{note}
    \indextext{literal!string!undefined change to}%
    The effect of attempting to modify a \grammarterm{string-literal} is undefined.
\end{note}

\pnum
String literal objects are initialized with
the sequence of code unit values
corresponding to the \grammarterm{string-literal}'s sequence of
\grammarterm{s-char}s (for a non-raw string literal) and
\grammarterm{r-char}s (for a raw string literal)
in order as follows:
\begin{itemize}
    \item
    The sequence of characters denoted by each contiguous sequence of
    \grammarterm{basic-s-char}s,
    \grammarterm{r-char}s,
    \grammarterm{simple-escape-sequence}s\iref{lex.ccon}, and
    \grammarterm{universal-character-name}s\iref{lex.charset}
    is encoded to a code unit sequence
    using the \grammarterm{string-literal}'s associated character encoding.
    If a character lacks representation in the associated character encoding, then:
    \begin{itemize}
        \item
        If the \grammarterm{string-literal}'s \grammarterm{encoding-prefix}
        is absent or \tcode{L},
        then the \grammarterm{string-literal} is conditionally-supported and
        an
        \impldef{code unit sequence for non-representable \grammarterm{string-literal}}
        code unit sequence is encoded.
        \item
        Otherwise, the \grammarterm{string-literal} is ill-formed.
    \end{itemize}
    When encoding a stateful character encoding,
    implementations should encode the first such sequence
    beginning with the initial encoding state and
    encode subsequent sequences
    beginning with the final encoding state of the prior sequence.
    \begin{note}
        The encoded code unit sequence can differ from
        the sequence of code units that would be obtained by
        encoding each character independently.
    \end{note}
    \item
    Each \grammarterm{numeric-escape-sequence}\iref{lex.ccon}
    that specifies an integer value $v$
    contributes a single code unit with a value as follows:
    \begin{itemize}
        \item
        If $v$ does not exceed the range of representable values of
        the \grammarterm{string-literal}'s array element type,
        then the value is $v$.
        \item
        Otherwise,
        if the \grammarterm{string-literal}'s \grammarterm{encoding-prefix}
        is absent or \tcode{L}, and
        $v$ does not exceed the range of representable values of
        the corresponding unsigned type for the underlying type of
        the \grammarterm{string-literal}'s array element type,
        then the value is the unique value of
        the \grammarterm{string-literal}'s array element type \tcode{T}
        that is congruent to $v$ modulo $2^N$, where $N$ is the width of \tcode{T}.
        \item
        Otherwise, the \grammarterm{string-literal} is ill-formed.
    \end{itemize}
    When encoding a stateful character encoding,
    these sequences should have no effect on encoding state.
    \item
    Each \grammarterm{conditional-escape-sequence}\iref{lex.ccon}
    contributes an
    \impldef{code unit sequence for \grammarterm{conditional-escape-sequence}}
    code unit sequence.
    When encoding a stateful character encoding,
    it is
    \impldef{effect of \grammarterm{conditional-escape-sequence} on encoding state}
    what effect these sequences have on encoding state.
\end{itemize}

\ednote{Add after "[lex.string]/p10"}

\begin{addedblock}
Each \grammarterm{universal-character-name} and each \grammarterm{simple-escape-sequence} in an \grammarterm{unevaluated-string-literal} is replaced by the member of the translation set it denotes.
An \grammarterm{unevaluated string-literal} which contains the null character, a \grammarterm{numeric-escape-sequence}
or a \grammarterm{conditional-escape-sequence} is ill-formed.

An \grammarterm{unevaluated-string-literal} is never evaluated and its interpretation depends on the context in which they appear.
\end{addedblock}

\ednote{"translation set" is defined in \paper{P2314R2} in [lex.phases]}


\rSec1[dcl.dcl]{Declarations}%

\rSec1[dcl.pre]{Preamble}

\begin{bnf}
    \nontermdef{simple-declaration}\br
    decl-specifier-seq \opt{init-declarator-list} \terminal{;}\br
    attribute-specifier-seq decl-specifier-seq init-declarator-list \terminal{;}\br
    \opt{attribute-specifier-seq} decl-specifier-seq \opt{ref-qualifier} \terminal{[} identifier-list \terminal{]} initializer \terminal{;}
\end{bnf}

\begin{bnf}
    \nontermdef{static_assert-declaration}\br
    \keyword{static_assert} \terminal{(} constant-expression \terminal{)} \terminal{;}\br
    \keyword{static_assert} \terminal{(} constant-expression \terminal{,} \added{unevaluated-}string-literal \terminal{)} \terminal{;}
\end{bnf}

[...]

\pnum
\indextext{\idxgram{static_assert}}%
In a \grammarterm{static_assert-declaration}, the
\grammarterm{constant-expression} shall be
a contextually converted constant expression
of type \tcode{bool}\iref{expr.const}.
If the value of the expression when
so converted is \tcode{true}, the declaration has no
effect. Otherwise, the program is ill-formed, and the resulting
diagnostic message\iref{intro.compliance} shall include the text of
the \grammarterm{\added{unevaluated-}string-literal}, if one is supplied,
except that characters not in the basic
source character set\iref{lex.charset} are not required to appear in
the diagnostic message.
\begin{example}
\begin{codeblock}
    static_assert(sizeof(int) == sizeof(void*), "wrong pointer size");
\end{codeblock}\end{example}

\rSec1[dcl.asm]{The \tcode{asm} declaration}%
\indextext{declaration!\idxcode{asm}}%
\indextext{assembler}%
\indextext{\idxcode{asm}!implementation-defined}

\pnum
An \tcode{asm} declaration has the form

\begin{bnf}
    \nontermdef{asm-declaration}\br
    \opt{attribute-specifier-seq} \keyword{asm} \terminal{(} \added{unevaluated-}string-literal \terminal{)} \terminal{;}
\end{bnf}

The \tcode{asm} declaration is conditionally-supported; its meaning is
\impldef{meaning of \tcode{asm} declaration}.
The optional \grammarterm{attribute-specifier-seq} in
an \grammarterm{asm-declaration} appertains to the \tcode{asm} declaration.
\begin{note}
    Typically it is used to pass information through the implementation to
    an assembler.
\end{note}

\rSec1[dcl.link]{Linkage specifications}%
\indextext{specification!linkage|(}

\pnum
All functions and variables whose names have external linkage
and all function types
have a \defn{language linkage}.
\begin{note}
    Some of the properties associated with an entity with language linkage
    are specific to each implementation and are not described here. For
    example, a particular language linkage might be associated with a
    particular form of representing names of objects and functions with
    external linkage, or with a particular calling convention, etc.
\end{note}
The default language linkage of all function types, functions, and
variables is \Cpp{} language linkage. Two function types with
different language linkages are distinct types even if they are
otherwise identical.

\pnum
Linkage\iref{basic.link} between \Cpp{} and  non-\Cpp{} code fragments can
be achieved using a \grammarterm{linkage-specification}:

\indextext{\idxgram{linkage-specification}}%
\indextext{specification!linkage!\idxcode{extern}}%
%
\begin{bnf}
    \nontermdef{linkage-specification}\br
    \keyword{extern} \added{unevaluated-}string-literal \terminal{\{} \opt{declaration-seq} \terminal{\}}\br
    \keyword{extern} \added{unevaluated-}string-literal declaration
\end{bnf}

The \grammarterm{\added{unevaluated-}string-literal} indicates the required language linkage.
This document specifies the semantics for the
\grammarterm{\added{unevaluated-}string-literal}{s} \tcode{"C"} and \tcode{"C++"}. Use of a
\grammarterm{\added{unevaluated-}string-literal} other than \tcode{"C"} or \tcode{"C++"} is
conditionally-supported, with \impldef{semantics of linkage specifiers} semantics.
\begin{note}
    Therefore, a linkage-specification with a \grammarterm{\added{unevaluated-}string-literal} that
    is unknown to the implementation requires a diagnostic.
\end{note}
\begin{note}
    It is recommended that the spelling of the \grammarterm{\added{unevaluated-}string-literal} be
    taken from the document defining that language. For example, \tcode{Ada}
    (not \tcode{ADA}) and \tcode{Fortran} or \tcode{FORTRAN}, depending on
    the vintage.
\end{note}

\pnum
\indextext{specification!linkage!implementation-defined}%
Every implementation shall provide for linkage to the C programming language,
\indextext{C!linkage to}%
\tcode{"C"}, and \Cpp{}, \tcode{"C++"}.
\begin{example}
    \begin{codeblock}
        complex sqrt(complex);          // \Cpp{} language linkage by default
        extern "C" {
            double sqrt(double);          // C language linkage
        }
    \end{codeblock}
\end{example}

// [...]

\rSec1[dcl.attr]{Attributes}%
\rSec2[dcl.attr.deprecated]{Deprecated attribute}%

\pnum
The \grammarterm{attribute-token} \tcode{deprecated} can be used to mark names and entities
whose use is still allowed, but is discouraged for some reason.
\begin{note}
    In particular,
    \tcode{deprecated} is appropriate for names and entities that are deemed obsolescent or
    unsafe.
\end{note}
It shall appear at most once in each \grammarterm{attribute-list}. An
\grammarterm{attribute-argument-clause} may be present and, if present, it shall have the form:

\begin{ncbnf}
    \terminal{(} \added{unevaluated-}string-literal \terminal{)}
\end{ncbnf}

\begin{note}
    The \grammarterm{\added{unevaluated-}string-literal} in the \grammarterm{attribute-argument-clause}
    can be used to explain the rationale for deprecation and/or to suggest a replacing entity.
\end{note}

\rSec2[dcl.attr.nodiscard]{Nodiscard attribute}%
\indextext{attribute!nodiscard}

\pnum
The \grammarterm{attribute-token} \tcode{nodiscard}
may be applied to the \grammarterm{declarator-id}
in a function declaration or to the declaration of a class or enumeration.
It shall appear at most once in each \grammarterm{attribute-list}.
An \grammarterm{attribute-argument-clause} may be present
and, if present, shall have the form:

\begin{ncbnf}
    \terminal{(} \added{unevaluated-}string-literal \terminal{)}
\end{ncbnf}

\pnum
A name or entity declared without the \tcode{nodiscard} attribute
can later be redeclared with the attribute and vice-versa.
\begin{note}
    Thus, an entity initially declared without the attribute
    can be marked as \tcode{nodiscard}
    by a subsequent redeclaration.
    However, after an entity is marked as \tcode{nodiscard},
    later redeclarations do not remove the \tcode{nodiscard}
    from the entity.
\end{note}
Redeclarations using different forms of the attribute
(with or without the \grammarterm{attribute-argument-clause}
or with different \grammarterm{attribute-argument-clause}s)
are allowed.

\pnum
A \defnadj{nodiscard}{type} is
a (possibly cv-qualified) class or enumeration type
marked \tcode{nodiscard} in a reachable declaration.
A \defnadj{nodiscard}{call} is either
\begin{itemize}
    \item
    a function call expression\iref{expr.call}
    that calls a function declared \tcode{nodiscard} in a reachable declaration or
    whose return type is a nodiscard type, or
    \item
    an explicit type
    conversion~(\ref{expr.type.conv}, \ref{expr.static.cast}, \ref{expr.cast})
    that constructs an object through
    a constructor declared \tcode{nodiscard} in a reachable declaration, or
    that initializes an object of a nodiscard type.
\end{itemize}

Recommanded:
Appearance of a nodiscard call as
a potentially-evaluated discarded-value expression\iref{expr.prop}
is discouraged unless explicitly cast to \tcode{void}.
Implementations should issue a warning in such cases.
\begin{note}
    This is typically because discarding the return value
    of a nodiscard call has surprising consequences.
\end{note}
The \grammarterm{\added{unevaluated-}string-literal}
in a \tcode{nodiscard} \grammarterm{attribute-argument-clause}
should be used in the message of the warning
as the rationale for why the result should not be discarded.


\rSec1[cpp]{Preprocessing directives}%

\rSec1[cpp.pre]{Preamble}

\begin{bnf}
    \nontermdef{preprocessing-file}\br
    \opt{group}\br
    module-file
\end{bnf}

\begin{bnf}
    \nontermdef{module-file}\br
    \opt{pp-global-module-fragment} pp-module \opt{group} \opt{pp-private-module-fragment}
\end{bnf}

\begin{bnf}
    \nontermdef{pp-global-module-fragment}\br
    \keyword{module} \terminal{;} new-line \opt{group}
\end{bnf}

\begin{bnf}
    \nontermdef{pp-private-module-fragment}\br
    \keyword{module} \terminal{:} \keyword{private} \terminal{;} new-line \opt{group}
\end{bnf}

\begin{bnf}
    \nontermdef{group}\br
    group-part\br
    group group-part
\end{bnf}

\begin{bnf}
    \nontermdef{group-part}\br
    control-line\br
    if-section\br
    text-line\br
    \terminal{\#} conditionally-supported-directive
\end{bnf}

\begin{bnf}\obeyspaces
    \nontermdef{control-line}\br
    \terminal{\# include} pp-tokens new-line\br
    pp-import\br
    \terminal{\# define } identifier replacement-list new-line\br
    \terminal{\# define } identifier lparen \opt{identifier-list} \terminal{)} replacement-list new-line\br
    \terminal{\# define } identifier lparen \terminal{... )} replacement-list new-line\br
    \terminal{\# define } identifier lparen identifier-list \terminal{, ... )} replacement-list new-line\br
    \terminal{\# undef  } identifier new-line\br
    \terminal{\# line   } pp-tokens new-line\br
    \terminal{\# error  } \opt{pp-tokens} new-line\br
    \terminal{\# pragma } \opt{pp-tokens} new-line\br
    \terminal{\# }new-line
\end{bnf}

\begin{bnf}
    \nontermdef{if-section}\br
    if-group \opt{elif-groups} \opt{else-group} endif-line
\end{bnf}

\begin{bnf}\obeyspaces
    \nontermdef{if-group}\br
    \terminal{\# if     } constant-expression new-line \opt{group}\br
    \terminal{\# ifdef  } identifier new-line \opt{group}\br
    \terminal{\# ifndef } identifier new-line \opt{group}
\end{bnf}

\begin{bnf}
    \nontermdef{elif-groups}\br
    elif-group\br
    elif-groups elif-group
\end{bnf}

\begin{bnf}\obeyspaces
    \nontermdef{elif-group}\br
    \terminal{\# elif   } constant-expression new-line \opt{group}
\end{bnf}

\begin{bnf}\obeyspaces
    \nontermdef{else-group}\br
    \terminal{\# else   } new-line \opt{group}
\end{bnf}

\begin{bnf}\obeyspaces
    \nontermdef{endif-line}\br
    \terminal{\# endif  } new-line
\end{bnf}

\begin{bnf}
    \nontermdef{text-line}\br
    \opt{pp-tokens} new-line
\end{bnf}

\begin{bnf}
    \nontermdef{conditionally-supported-directive}\br
    pp-tokens new-line
\end{bnf}

\begin{bnf}
    \nontermdef{lparen}\br
    \descr{a \terminal{(} character not immediately preceded by whitespace}
\end{bnf}

\begin{bnf}
    \nontermdef{identifier-list}\br
    identifier\br
    identifier-list \terminal{,} identifier
\end{bnf}

\begin{bnf}
    \nontermdef{replacement-list}\br
    \opt{pp-tokens}
\end{bnf}

\begin{bnf}
    \nontermdef{pp-tokens}\br
    preprocessing-token\br
    pp-tokens preprocessing-token
\end{bnf}

\begin{bnf}
    \nontermdef{new-line}\br
    \descr{the new-line character}
\end{bnf}

\pnum
A \defn{preprocessing directive} consists of a sequence of preprocessing tokens
that satisfies the following constraints:
At the start of translation phase 4,
the first token in the sequence,
referred to as a \defnadj{directive-introducing}{token},
begins with the first character in the source file
(optionally after whitespace containing no new-line characters) or
follows whitespace containing at least one new-line character,
and is

\begin{itemize}
    \item
    a \tcode{\#} preprocessing token, or

    \item
    an \keyword{import} preprocessing token
    immediately followed on the same logical line by a
    \grammarterm{header-name},
    \tcode{<},
    \grammarterm{identifier},
    \grammarterm{\added{unevaluated-}string-literal}, or
    \tcode{:}
    preprocessing token, or

    \item
    a \keyword{module} preprocessing token
    immediately followed on the same logical line by an
    \grammarterm{identifier},
    \tcode{:}, or
    \tcode{;}
    preprocessing token, or

    \item
    an \keyword{export} preprocessing token
    immediately followed on the same logical line by
    one of the two preceding forms.
\end{itemize}

The last token in the sequence is the first token within the sequence that
is immediately followed by whitespace containing a new-line character.
\begin{footnote}
    Thus,
    preprocessing directives are commonly called ``lines''.
    These ``lines'' have no other syntactic significance,
    as all whitespace is equivalent except in certain situations
    during preprocessing (see the
    \tcode{\#}
    character string literal creation operator in~\ref{cpp.stringize}, for example).
\end{footnote}
\begin{note}
    A new-line character ends the preprocessing directive even if it occurs
    within what would otherwise be an invocation of a function-like macro.
\end{note}

\begin{example}
    \begin{codeblock}
        #                       // preprocessing directive
        module ;                // preprocessing directive
        export module leftpad;  // preprocessing directive
        import <string>;        // preprocessing directive
        export import "squee";  // preprocessing directive
        import rightpad;        // preprocessing directive
        import :part;           // preprocessing directive

        module                  // not a preprocessing directive
        ;                       // not a preprocessing directive

        export                  // not a preprocessing directive
        import                  // not a preprocessing directive
        foo;                    // not a preprocessing directive

        export                  // not a preprocessing directive
        import foo;             // preprocessing directive (ill-formed at phase 7)

        import ::               // not a preprocessing directive
        import ->               // not a preprocessing directive
    \end{codeblock}
\end{example}

\pnum
A sequence of preprocessing tokens is only a \grammarterm{text-line}
if it does not begin with a directive-introducing token.
A sequence of preprocessing tokens is only a \grammarterm{conditionally-supported-directive}
if it does not begin with any of the directive names
appearing after a \tcode{\#} in the syntax.
A \grammarterm{conditionally-supported-directive} is
conditionally-supported with
\impldef{additional supported forms of preprocessing directive}
semantics.

\pnum
At the start of phase 4 of translation,
the \grammarterm{group} of a \grammarterm{pp-global-module-fragment} shall
contain neither a \grammarterm{text-line} nor a \grammarterm{pp-import}.

\pnum
When in a group that is skipped\iref{cpp.cond}, the directive
syntax is relaxed to allow any sequence of preprocessing tokens to occur between
the directive name and the following new-line character.

\pnum
The only whitespace characters that shall appear
between preprocessing tokens
within a preprocessing directive
(from just after the directive-introducing token
through just before the terminating new-line character)
are space and horizontal-tab
(including spaces that have replaced comments
or possibly other whitespace characters
in translation phase 3).

\pnum
The implementation can
process and skip sections of source files conditionally,
include other source files,
import macros from header units,
and replace macros.
These capabilities are called
\defn{preprocessing},
because conceptually they occur
before translation of the resulting translation unit.

\pnum
The preprocessing tokens within a preprocessing directive
are not subject to macro expansion unless otherwise stated.

\begin{example}
    In:
    \begin{codeblock}
        #define EMPTY
        EMPTY   #   include <file.h>
    \end{codeblock}
    the sequence of preprocessing tokens on the second line is \textit{not}
    a preprocessing directive, because it does not begin with a \tcode{\#} at the start of
    translation phase 4, even though it will do so after the macro \tcode{EMPTY}
    has been replaced.
\end{example}

\rSec1[cpp.cond]{Conditional inclusion}%
\indextext{preprocessing directive!conditional inclusion}%
\indextext{inclusion!conditional|see{preprocessing directive, conditional inclusion}}

\indextext{\idxcode{defined}}%
\begin{bnf}
    \nontermdef{defined-macro-expression}\br
    \terminal{defined} identifier\br
    \terminal{defined (} identifier \terminal{)}
\end{bnf}

\begin{bnf}
    \nontermdef{h-preprocessing-token}\br
    \textnormal{any \grammarterm{preprocessing-token} other than \terminal{>}}
\end{bnf}

\begin{bnf}
    \nontermdef{h-pp-tokens}\br
    h-preprocessing-token\br
    h-pp-tokens h-preprocessing-token
\end{bnf}

\begin{bnf}
    \nontermdef{header-name-tokens}\br
    \added{unevaluated-}string-literal\br
    \terminal{<} h-pp-tokens \terminal{>}
\end{bnf}

\indextext{\idxxname{has_include}}%
\begin{bnf}
    \nontermdef{has-include-expression}\br
    \terminal{\xname{has_include}} \terminal{(} header-name \terminal{)}\br
    \terminal{\xname{has_include}} \terminal{(} header-name-tokens \terminal{)}
\end{bnf}

\indextext{\idxxname{has_cpp_attribute}}%
\begin{bnf}
    \nontermdef{has-attribute-expression}\br
    \terminal{\xname{has_cpp_attribute} (} pp-tokens \terminal{)}
\end{bnf}

\pnum
The expression that controls conditional inclusion
shall be an integral constant expression except that
identifiers
(including those lexically identical to keywords)
are interpreted as described below
\begin{footnote}
    Because the controlling constant expression is evaluated
    during translation phase 4,
    all identifiers either are or are not macro names ---
    there simply are no keywords, enumeration constants, etc.
\end{footnote}
and it may contain zero or more \grammarterm{defined-macro-expression}{s} and/or
\grammarterm{has-include-expression}{s} and/or
\grammarterm{has-attribute-expression}{s} as unary operator expressions.

\pnum
A \grammarterm{defined-macro-expression} evaluates to \tcode{1}
if the identifier is currently defined
as a macro name
(that is, if it is predefined
or if it has one or more active macro definitions\iref{cpp.import},
for example because
it has been the subject of a
\tcode{\#define}
preprocessing directive
without an intervening
\tcode{\#undef}
directive with the same subject identifier), \tcode{0} if it is not.

\pnum
The second form of \grammarterm{has-include-expression}
is considered only if the first form does not match,
in which case the preprocessing tokens are processed just as in normal text.


\rSec1[cpp.line]{Line control}%
\indextext{preprocessing directive!line control}%
\indextext{\idxcode{\#line}|see{preprocessing directive, line control}}

\pnum
\removed{The \grammarterm{string-literal} of a
\tcode{\#line}
directive, if present,
shall be a character string literal.
}
\pnum
The
\defn{line number}
of the current source line is one greater than
the number of new-line characters read or introduced
in translation phase 1\iref{lex.phases}
while processing the source file to the current token.

\pnum
A preprocessing directive of the form
\begin{ncsimplebnf}
    \terminal{\# line} digit-sequence new-line
\end{ncsimplebnf}
causes the implementation to behave as if
the following sequence of source lines begins with a
source line that has a line number as specified
by the digit sequence (interpreted as a decimal integer).
If the digit sequence specifies zero
or a number greater than 2147483647,
the behavior is undefined.

\pnum
A preprocessing directive of the form

\begin{ncsimplebnf}
    \terminal{\# line} digit-sequence \changed{\terminal{"} \opt{s-char-sequence} \terminal{"}}{unevaluated-string-literal} new-line
\end{ncsimplebnf}

sets the presumed line number similarly and changes the
presumed name of the source file to be the contents
of the character string literal.

\pnum
A preprocessing directive of the form

\begin{ncsimplebnf}
    \terminal{\# line} pp-tokens new-line
\end{ncsimplebnf}

(that does not match one of the two previous forms)
is permitted.
The preprocessing tokens after
\tcode{line}
on the directive are processed just as in normal text
(each identifier currently defined as a macro name is replaced by its
replacement list of preprocessing tokens).
If the directive resulting after all replacements does not match
one of the two previous forms, the behavior is undefined;
otherwise, the result is processed as appropriate.

\rSec1[cpp.pragma.op]{Pragma operator}%
\indextext{macro!pragma operator}%
\indextext{operator!pragma|see{macro, pragma operator}}

\pnum
A unary operator expression of the form:

\begin{ncbnf}
    \terminal{_Pragma} \terminal{(} \added{unevaluated-}string-literal \terminal{)}
\end{ncbnf}

is processed as follows: The \grammarterm{\added{unevaluated-}string-literal} is \defnx{destringized}{destringization} by
\removed{deleting the \tcode{L} prefix, if present,} deleting the leading and trailing
double-quotes \removed{,replacing each escape sequence \tcode{\textbackslash"} by a double-quote, and
replacing each escape sequence \tcode{\textbackslash\textbackslash} by a single
backslash}. The resulting sequence of characters is processed through translation phase 3
to produce preprocessing tokens that are executed as if they were the
\grammarterm{pp-tokens} in a pragma directive. The original four preprocessing
tokens in the unary operator expression are removed.

\pnum
\begin{example}
\begin{codeblock}
    #pragma listing on "..\listing.dir"
\end{codeblock}
can also be expressed as:
\begin{codeblock}
    _Pragma ( "listing on \"..\\listing.dir\"" )
\end{codeblock}
The latter form is processed in the same way whether it appears literally
as shown, or results from macro replacement, as in:
\begin{codeblock}
    #define LISTING(x) PRAGMA(listing on #x)
    #define PRAGMA(x) _Pragma(#x)

    LISTING( ..\listing.dir )
\end{codeblock}
\end{example}


\section{Acknowledgments}

Thank you to Peter Brett who offered valuable feedback on this paper!


\section{References}

\bibliographystyle{plain}
\bibliography{wg21}


\renewcommand{\section}[2]{}%
\begin{thebibliography}{9}

\bibitem[N4885]{N4885}
Thomas Köppe
\emph{Working Draft, Standard for Programming Language C++}\newline
\url{https://wg21.link/N4885}

\end{thebibliography}

\end{document}
