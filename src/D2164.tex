% !TeX program = luatex
% !TEX encoding = UTF-8


\documentclass{wg21}

\title{\tcode{views::enumerate}}
\docnumber{P2164R7}
\audience{LEWG, SG-9}
\author{Corentin Jabot}{corentin.jabot@gmail.com}

\definecolor{addtuplecolor}{rgb}{0.72, 0.53, 0.04}
\newcommand{\addedtuple}[1]{\textcolor{addtuplecolor}{\uline{#1}}}

\begin{document}
\maketitle
\paperquote{A struct with 2 members, how hard can it be?!}

\section{Abstract}

We propose a view \tcode{enumerate} whose value type is a struct with 2 members \tcode{index} and \tcode{value}
representing respectively the position and value of the elements in the adapted range.

\section{Revisions}

\subsection{R7}
\begin{itemize}
    \item This version asks LEWG to choose between \tcode{tuple} or \tcode{enumerate_result} as the reference and value types of \tcode{enumerate_view}.
    The approach presented in previous revisions of having a value type and a reference type of different types proved not workable.
    We need to pick one of the two options. Wording is provided for both.

    \item Add missing \tcode{iter_move} and \tcode{iter_swap} functions.
    \item Add the markup for freestanding
    \item Add feature test macro
    \item Formatting fixes.
\end{itemize}

\subsection{R6}
Wording changes:
\begin{itemize}
    \item Add \tcode{enumerate_result} to the list of \tcode{tuple-like} types
    \item Because \tcode{enumerate_view::iterator::operator*} returns values,  \tcode{enumerate_view::iterator}
    cannot be a \tcode{Cpp17ForwardIterator}. Change \tcode{iterator_category} and add \tcode{iterator_concept} accordingly.
\end{itemize}

\subsection{R5}

Instead of adding complexity to \tcode{enumerate_result}, we assume changes made by \paper{P2165R2}.
\paper{P2165R2} makes \tcode{pair} constructible from \placeholder{pair-like} objects, and associative containers deduction guides work
with ranges of \placeholder{pair-like} objects.
With these changes, \tcode{enumerate_result} can remain a simple aggregate. We just need to implement the tuple protocol for it (\tcode{get}, \tcode{tuple_element}, \tcode{tuple_size}).

\paper{P2165R2} ensures a common reference exists between \tcode{enumerate_result} and \tcode{std::tuple} as long as one exists between each element.

\tcode{count_type} is renamed to \tcode{index_type}. I am not sure why I ever chosed \tcode{count_type} as the initial name.

\subsection{R4}

This revision is intended to illustrate the effort necessary to support named fields for \tcode{index} and \tcode{value}.
In previous revisions, the value and reference types were identical, a regrettable blunder that made the wording and implementation efforts smaller than they are.
\tcode{reference} and \tcode{value_type} types however needs to be different, if only to make the \tcode{ranges::to} presented in this very paper.

If that direction is acceptable, better wording will be provided to account for these new \tcode{reference} and \tcode{value_type} types.

This revision also gets rid of the \tcode{const} \tcode{index} value as LEWG strongly agreed that it was a terrible idea to begin with, one that would make composition with other views cumbersome.

\subsection{R3}

\begin{itemize}
    \item Typos and minor wording improvements
\end{itemize}

\subsection{R2, following mailing list reviews}
\begin{itemize}
    \item Make \tcode{value_type} different from  \tcode{reference} to match other views
    \item Remove inconsistencies between the wording and the description
    \item Add relevant includes and namespaces to the examples
\end{itemize}


\subsection{R1}
\begin{itemize}
\item Fix the index type
\end{itemize}

\section{Tony tables}
\begin{center}
\begin{tabular}{l|l}
Before & After\\ \hline

\begin{minipage}[t]{0.5\textwidth}
\begin{colorblock}

std::vector days{"Mon", "Tue",
  "Wed", "Thu", "Fri", "Sat", "Sun"};

int idx = 0;
for(const auto & d : days) {
    print("{} {} \n", idx, d);
    idx++;
}

\end{colorblock}
\end{minipage}
&
\begin{minipage}[t]{0.5\textwidth}
\begin{colorblock}
#include <ranges>

std::vector days{"Mon", "Tue",
  "Wed", "Thu", "Fri", "Sat", "Sun"};

for(const auto & e : std::views::enumerate(days)) {
    print("{} {} \n", e.index, e.value);
}

\end{colorblock}
\end{minipage}
\\\\ \hline

\end{tabular}
\end{center}

\section{Motivation}

The impossibility to extract an index from a range-based for loop leads to the use of non-range-based \tcode{for} loops, or the introduction of a variable in the outer scope. This is both more verbose and error-prone: in the example above, the type of \tcode{idx} is incorrect.

\tcode{enumerate} is a library solution solving this problem, enabling the use of range-based for loops in more cases.

It also composes nicely with other range facilities:
The following creates a map from a vector using the position of each element as key.

\begin{colorblock}
my_vector | views::enumerate | ranges::to<map>;
\end{colorblock}

This feature exists in some form in Python, Rust, Go (backed into the language), and in many C++ libraries: ranges-v3, folly, boost::ranges (\tcode{indexed}).


The existence of this feature or lack thereof is the subject of recurring StackOverflow questions.


\section{Design}

\subsection{\tcode{std::tuple} vs aggregate with name members}

Following the trend of using meaningful names instead of returning pairs or tuples, one option is to use a struct with named public members.
\begin{colorblock}
struct enumerate_result {
    count index;
    T value;
};
\end{colorblock}

This design was previously discussed by LEWGI in Belfast in the context of \paper{P1894R0}, and many people have expressed a desire for such struct with names.

\begin{colorblock}
std::vector<double> v;
enumerate(view) | to<std::vector>(); // std::vector<std::tuple<std::size_t, double>>.
enumerate(view) | to<std::map>();    // std::map<std::size_t, double>.
\end{colorblock}

\subsubsection{Why not just always return a \tcode{tuple} and rely on structure binding?}

If a range reference type is convertible to the index type,
it is error-prone whether one should write

\begin{colorblock}
for(auto && [value, index] : view | std::views::enumerate)
for(auto && [index, value] : view | std::views::enumerate)
\end{colorblock}

Having named members avoids this issue.
The feedback I keep getting is "we should use a struct if we can". Which is consistent with previous LEWG guidelines to avoid using pair
when a more meaningful type is possible.


\subsubsection{Why use a tuple?}

The drawback of using a distinct type is that
\begin{colorblock}
auto vec = enumerate(view) | ranges::to<std::vector>();
\end{colorblock}

would produce a \tcode{vector<enumerate_result<std::size_t, range_value_t<decltype(view)>>}

where ideally, I think it should produce a tuple.

\subsection{Why not \tcode{enumerate_result} as reference type and \tcode{tuple} as value type?}

This was the approached proposed by the previous revision of the paper and my preferred solution. Best of both world.
It only has a smal drawback: it doesn't work.

Many algorithms end up requiring \tcode{invocable<F\&, iter_value_t<I>\&> \&\& invocable<F\&, iter_reference_t<I>>} (where F is a function),
which would require \tcode{std::tuple<std::size_t, Foo>\&} to be convertible to \tcode{enumerate_result<std::size_t, Foo>}.

In practice, this means that many algorithms are not utilisable if reference and values are not the same type

\begin{colorblock}
std::ranges:::find(enumerate(/*...*/), [](auto const& p) { // constraints not satisfied.
    return /*...*/;
})
\end{colorblock}

This is simply not acceptable.

Tomasz also observed that it would interract pourly with \tcode{as_const}.

\begin{colorblock}
for (auto const& p : enumerate(/*...*/)) {
    something(p.value); // OK
}

for (auto const& p : enumerate(/*...*/) | views|as_const) {
    something(p.value); // KO decltype(p) is tuple<std::size_t, const Foo&>
}
\end{colorblock}

Which is... not great.
The unfortunate \tcode{invocable<F\&, iter_value_t<I>\&>} constraints exists as some algorithms (not find) may constructs value types out of the elements of the range.

\subsection{Where do we go from here?}

We need to choose between using \tcode{tuple} or \tcode{enumerate_result}, and that type would be used for both the value type and the reference type.

\textbf{POLL: Does LEWG prefer using \tcode{enumerate_result} (Option 1) rather than a \tcode{tuple} (Option 2) as the value and reference type of \tcode{enumerate_view::iterator}?}

The wording provides both options.

\subsection{Why not \tcode{zip(iota, view)}?}
Zipping the view with iota \href{https://github.com/ericniebler/range-v3/issues/1141}{does not actually work}
(see also \href{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2214r0.html#enumerates-first-range}{\paper{P2214R0}}),
and a custom \tcode{index_view} would need to be used as the first range composed with \tcode{zip}, so a custom \tcode{enumerate} view with
appropriately named members is not adding a lot of work.

\tcode{enumerate} as presented here is slightly less work for the compiler, but both solutions generate similar assembly.

\subsection{index_type}

\tcode{index_type} is defined as follow:
\begin{itemize}
    \item \tcode{ranges::range_size_t<Base>} if \tcode{Base} models \tcode{ranges::sized_range}
    \item Otherwise, \tcode{make_unsigned_t<ranges::range_difference_t<Base>>}
\end{itemize}

This is consistent with ranges-v3 and allows the view to support both sized and non-sized ranges.


\subsection{Performance}

An optimizing compiler can generate the same machine code for \tcode{views::enumerate} as it would for an equivalent \tcode{for} loop.  \href{https://godbolt.org/z/2Kxo8d}{Compiler Explorer} \ednote{This implementation is a prototype not fully reflective of the proposed design}.


\subsection{Implementation}

This proposal has been implemented (\href{https://github.com/cor3ntin/rangesnext/blob/master/include/cor3ntin/rangesnext/enumerate.hpp}{Github})
There exist an implementation in ranges-v3 (where the enumerate view uses zip_with and a pair value type).

\section{Proposal}

We propose a view \tcode{enumerate} whose value type is a struct with 2 members \tcode{index} and \tcode{value}
representing respectively the position and value of the elements in the adapted range.

\section{Wording}

\ednote{This wording covers 2 options, depending LEWG wishes.\\
\addedTwo{In blue, Option 1 adds \tcode{enumerate_result} as the value and reference types of \tcode{enumerate_view}.}\\
\addedtuple{In brown, Option 2 uses std::tuple instead.}\\
\added{Common wording in blue-green}.}


\rSec1[ranges.syn]{Header \tcode{<ranges>} synopsis}

\begin{codeblock}

template<class R>
using keys_view = elements_view<R, 0>;                                          // freestanding
template<class R>
using values_view = elements_view<R, 1>;                                        // freestanding

namespace views {
    template<size_t N>
    inline constexpr @\unspecnc@ elements = @\unspecnc@;                          // freestanding
    inline constexpr auto keys = elements<0>;                                       // freestanding
    inline constexpr auto values = elements<1>;                                     // freestanding
}
\end{codeblock}
\begin{addedblock}
\begin{addedblockTwo}
\begin{codeblock}

template <typename Index, class Value>
requires @\placeholder{is-integer-like}@<Index>
struct enumerate_result; // freestanding

template<size_t I, class Index, class Value>
constexpr tuple_element_t<I, enumerate_result<Index, Value>>&
get(enumerate_result<Index, Value>&) noexcept;  // freestanding

template<size_t I, class Index, class Value>
constexpr tuple_element_t<I, enumerate_result<Index, Value>>&&
get(enumerate_result<Index, Value>&&) noexcept; // freestanding

template<size_t I, class Index, class Value>
constexpr const tuple_element_t<I, enumerate_result<Index, Value>>&
get(const enumerate_result<Index, Value>&) noexcept; // freestanding

template<size_t I, class Index, class Value>
constexpr const tuple_element_t<I, enumerate_result<Index, Value>>&&
get(const enumerate_result<Index, Value>&&) noexcept; // freestanding

\end{codeblock}
\end{addedblockTwo}

\begin{codeblock}
template <input_range View>
requires view<View>
class enumerate_view; // freestanding

namespace views { inline constexpr @\unspecnc@ enumerate = @\unspecnc@; }      // freestanding
\end{codeblock}
\end{addedblock}
\begin{codeblock}


// \ref{range.zip}, zip view
template<input_range... Views>
requires (view<Views> && ...) && (sizeof...(Views) > 0)
class zip_view;                                                                   // freestanding

template<class... Views>
inline constexpr bool enable_borrowed_range<zip_view<Views...>> =               // freestanding
(enable_borrowed_range<Views> && ...);

namespace views { inline constexpr @\unspecnc@ zip = @\unspecnc@; }               // freestanding

@\textcolor{noteclr}{[...]}@

}

namespace std {
    namespace views = ranges::views;                                                  // freestanding

    template<class T> struct tuple_size;                                              // freestanding
    template<size_t I, class T> struct tuple_element;                                 // freestanding

    template<class I, class S, ranges::subrange_kind K>
    struct tuple_size<ranges::subrange<I, S, K>>                                      // freestanding
    : integral_constant<size_t, 2> {};
    template<class I, class S, ranges::subrange_kind K>
    struct tuple_element<0, ranges::subrange<I, S, K>> {                              // freestanding
        using type = I;                                                                 // freestanding
    };
    template<class I, class S, ranges::subrange_kind K>
    struct tuple_element<1, ranges::subrange<I, S, K>> {                              // freestanding
        using type = S;                                                                 // freestanding
    };
    template<class I, class S, ranges::subrange_kind K>
    struct tuple_element<0, const ranges::subrange<I, S, K>> {                        // freestanding
        using type = I;                                                                 // freestanding
    };
    template<class I, class S, ranges::subrange_kind K>
    struct tuple_element<1, const ranges::subrange<I, S, K>> {                        // freestanding
        using type = S;                                                                 // freestanding
    };

    \end{codeblock}
    \begin{addedblockTwo}
    \begin{codeblock}

    template<class Index, class Value>
    struct tuple_size<ranges::enumerate_result<Index, Value>> : integral_constant<size_t, 2> { };

    template<size_t I, class Index, class Value>
    struct tuple_element<I, ranges::enumerate_result<Index, Value>> {
        using type =  @\seebelow@;
    };

    template<template<class> class TQual, template<class> class UQual,
    typename Index, typename Type, typename Type2>
    struct basic_common_reference<ranges::enumerate_result<Index, Type>,
    ranges::enumerate_result<Index, Type2>, TQual, UQual> {
        using type = ranges::enumerate_result<Index, std::common_reference_t<Type, Type2>>;
    };
    \end{codeblock}
    \end{addedblockTwo}
    \begin{codeblock}

    struct from_range_t { explicit from_range_t() = default; };                       // freestanding
    inline constexpr from_range_t from_range{};                                       // freestanding
}


\end{codeblock}

\rSec2[tuple.like]{Concept \exposconcept{tuple-like}}

% FIXME: \exposconcept{} is not allowed in \indexlibrarymember
\indexlibrarymember{\placeholder{tuple-like}}{tuple}%
\begin{itemdecl}
    template <typename T>
    concept @\defexposconcept{tuple-like}@ = @\seebelownc@;           // \expos
\end{itemdecl}

\begin{itemdescr}
    \pnum
    A type \tcode{T} models and satisfies
    the exposition-only concept \exposconcept{tuple-like}
    if \tcode{std::remove_cvref_t<T>} is a specialization of
    \tcode{array}, \tcode{pair}, \tcode{tuple}, \addedTwo{\tcode{ranges::enumerate\char`_result}, }or \tcode{ranges::subrange}.
\end{itemdescr}


\begin{addedblock}


\ednote{Add the following new section before [range.zip]}

\rSec2[range.enumerate]{Enumerate view}

\rSec3[range.enumerate.overview]{Overview}

\pnum
\tcode{enumerate_view} presents a \libconcept{view} with a value type that represents both the position and value of the adapted \libconcept{view}'s value-type.

\pnum
The name \tcode{views::enumerate} denotes a
range adaptor object\iref{range.adaptor.object}.
Given the subexpressions \tcode{E}
the expression \tcode{views::enumerate(E)} is expression-equivalent to \tcode{enumerate_view\{E\}}.

\pnum
\begin{example}
\begin{codeblock}
vector<int> vec{ 1, 2, 3 };
for (auto [index, value] : enumerate(vec) )
    cout << index << ":" << value ' '; // prints: 0:1 1:2 2:3
\end{codeblock}
\end{example}

\begin{addedblockTwo}

\ednote{The following wording (in blue) is for Option 1: Use a distinct type for enumerate result}

\rSec3[range.enumerate.result]{Class template \tcode{enumerate_result}}

\begin{codeblock}
namespace std {

namespace ranges {
    template <integral Index, class Value>
    struct enumerate_result {
        Index index;
        Value value;

        constexpr bool operator==(const enumerate_result &) const = default;

        template<typename OtherValue>
        explicit(@\seebelow@) operator enumerate_result<Index, OtherValue>() const &;
        template<typename OtherValue>
        explicit(@\seebelow@) operator enumerate_result<Index, OtherValue>() &;
        template<typename OtherValue>
        explicit(@\seebelow@) operator enumerate_result<Index, OtherValue>() const &&;
        template<typename OtherValue>
        explicit(@\seebelow@) operator enumerate_result<Index, OtherValue>() &&;
    };
}


}

\end{codeblock}

\begin{itemdecl}
template<typename OtherValue>
explicit(@\seebelow@) operator enumerate_result<Index, OtherValue>() const &;
template<typename OtherValue>
explicit(@\seebelow@) operator enumerate_result<Index, OtherValue>() &;
template<typename OtherValue>
explicit(@\seebelow@) operator enumerate_result<Index, OtherValue>() const &&;
template<typename OtherValue>
explicit(@\seebelow@) operator enumerate_result<Index, OtherValue>() &&;
\end{itemdecl}

\begin{itemdescr}
Let ValueRef be the type \tcode{COPYCV(decltype(*this), Value)\&} for \&-qualified overload, and \tcode{COPYCV(decltype(*this), Value)} overloads. ([[meta.trans.other]]).

\constraints
\begin{itemize}
\item \tcode{std::is_constructible_v<OtherValue, \tcode{ValueRef}>} is \tcode{true}, and
\item \tcode{std::reference_constructs_from_temporary_v<OtherValue, \tcode{ValueRef}>} is \tcode{false}.
\end{itemize}

\returns \tcode{\{index, OtherValue(std::forward<ValueRef>(value))\}}.

\remarks

The expression inside \tcode{explicit}  is equivalent to:

\tcode{!std::is_convertible_v<ValueRef, OtherValue>}.

\end{itemdescr}

\rSec3[range.enumerate.result.tuple]{Tuple protocol for \tcode{enumerate_result}}


\begin{itemdecl}
template<size_t I, class Index, class Value>
struct tuple_element<I, ranges::enumerate_result<Index, Value>> {
    using type = @\seebelow@;
};
\end{itemdecl}

\begin{itemdescr}
    \mandates \tcode{I < 2}.

    \ctype The type \tcode{Index} if \tcode{I} is \tcode{0}, otherwise the type \tcode{Value}.
\end{itemdescr}


\begin{itemdecl}
template<size_t I, class Index, class Value>
constexpr tuple_element_t<I, enumerate_result<Index, Value>>&
get(enumerate_result<Index, Value>& r) noexcept;

template<size_t I, class Index, class Value>
constexpr tuple_element_t<I, enumerate_result<Index, Value>>&&
get(enumerate_result<Index, Value>&& r) noexcept;

template<size_t I, class Index, class Value>
constexpr const tuple_element_t<I, enumerate_result<Index, Value>>&
get(const enumerate_result<Index, Value>& r) noexcept;

template<size_t I, class Index, class Value>
constexpr const tuple_element_t<I, enumerate_result<Index, Value>>&&
get(const enumerate_result<Index, Value>&& r) noexcept;
\end{itemdecl}

\begin{itemdescr}
    \mandates \tcode{I < 2}.
    \returns
    \begin{itemize}
        \item if {I} is 0, returns a reference to \tcode{r.index}.
        \item if {I} is 1, returns a reference to \tcode{r.value}.
    \end{itemize}
\end{itemdescr}

\end{addedblockTwo}


\rSec3[range.enumerate.view]{Class template \tcode{enumerate_view}}


\begin{codeblock}
    template<@\libconcept{input_range}@ V>
    requires view<V>
    class enumerate_view : public view_interface<enumerate_view<V>> {

      private:
        V @\exposid{base_}@ = {};

        template <bool Const>
        class @\exposid{iterator}@; // \expos
        template <bool Const>
        struct @\exposid{sentinel}@; // \expos

       public:

        constexpr enumerate_view() = default;
        constexpr enumerate_view(V base);

        constexpr auto begin() requires (!simple_view<V>)
        { return @\exposid{iterator}@<false>(ranges::begin(base_), 0); }

        constexpr auto begin()\textbf{} const requires simple_view<V>
        { return @\exposid{iterator}@<true>(ranges::begin(base_), 0); }

        constexpr auto end()
        { return @\exposid{sentinel}@<false>{end(base_)}; }

        constexpr auto end()
        requires common_range<V> && sized_range<V>
        { return @\exposid{iterator}@<false>{ranges::end(base_),
                 static_cast<range_difference_t<V>>(size()) }; }

        constexpr auto end() const
        requires range<const V>
        { return @\exposid{sentinel}@<true>{ranges::end(base_)}; }

        constexpr auto end() const
        requires common_range<const V> && sized_range<V>
        { return @\exposid{iterator}@<true>{ranges::end(base_),
                 static_cast<range_difference_t<V>>(size())}; }

        constexpr auto size()
        requires sized_range<V>
        { return ranges::size(base_); }

        constexpr auto size() const
        requires sized_range<const V>
        { return ranges::size(base_); }


        constexpr V base() const & requires copy_constructible<V> { return @\exposid{base_}@; }
        constexpr V base() && { return move(@\exposid{base_}@); }
    };
    template<class R>
    enumerate_view(R&&) -> enumerate_view<views::all_t<R>>;
}
\end{codeblock}



\begin{itemdecl}
    constexpr enumerate_view(V base);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Initializes \exposid{base_} with \tcode{move(base)}.
\end{itemdescr}

\rSec3[range.enumerate.iterator]{Class \tcode{enumerate_view::\exposid{iterator}}}

\begin{codeblock}
namespace std::ranges {
    template<@\libconcept{input_range}@ V>
    requires view<V>
    template<bool Const>
    class enumerate_view<V>::@\exposid{iterator}@ {

        using @\exposid{Base}@ = conditional_t<Const, const V, V>;
        using index_type = @\seebelow@;

        iterator_t<@\exposid{Base}@> @\exposid{current_}@ = iterator_t<@\exposid{Base}@>();
        index_type  @\exposid{pos_}@ = 0;


      public:
        using iterator_category = input_iterator_tag;
        using iterator_concept  = @\seebelow@;

        @\ednote{The following wording (in blue) is for Option 1}@


        @\addedTwo{using reference  = enumerate_result<index\_type, range\_reference\_t<\exposid{Base}>>;}@
        @\addedTwo{using value_type = enumerate_result<index_type, range_value_t<\exposid{Base}>>;}@

        @\ednote{The following wording (in brown) is for Option 2}@

        @\addedtuple{using reference  = tuple<index\_type, range\_reference\_t<\exposid{Base}>>;}@
        @\addedtuple{using value_type = tuple<index_type, range_value_t<\exposid{Base}>>;}@

        using difference_type = range_difference_t<@\exposid{Base}@>;

        @\exposid{iterator}@() = default;
        constexpr explicit @\exposid{iterator}@(iterator_t<@\exposid{Base}@> current, range_difference_t<@\exposid{Base}@> pos);
        constexpr iterator(@\exposid{iterator}@<!Const> i)
        requires Const && convertible_to<iterator_t<V>, iterator_t<@\exposid{Base}@>>;


        constexpr iterator_t<@\exposid{Base}@> base() const&
        requires copyable<iterator_t<@\exposid{Base}@>>;
        constexpr iterator_t<@\exposid{Base}@> base() &&;

        constexpr decltype(auto) operator*() const {
             return reference{ @\exposid{pos_}@, *@\exposid{current_}@};
        }

        constexpr @\exposid{iterator}@& operator++();
        constexpr void operator++(int) requires (!forward_range<@\exposid{Base}@>);
        constexpr @\exposid{iterator}@ operator++(int) requires forward_range<@\exposid{Base}@>;

        constexpr @\exposid{iterator}@& operator--() requires bidirectional_range<@\exposid{Base}@>;
        constexpr @\exposid{iterator}@ operator--(int) requires bidirectional_range<@\exposid{Base}@>;

        constexpr @\exposid{iterator}@& operator+=(difference_type x)
        requires random_access_range<@\exposid{Base}@>;
        constexpr @\exposid{iterator}@& operator-=(difference_type x)
        requires random_access_range<@\exposid{Base}@>;

        constexpr decltype(auto) operator[](difference_type n) const
        requires random_access_range<@\exposid{Base}@>
        { return reference{static_cast<difference_type>(@\exposid{pos_}@ + n), *(@\exposid{current_}@ + n) }; }


        friend constexpr bool operator==(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
        requires equality_comparable<iterator_t<@\exposid{Base}@>>;

        friend constexpr bool operator<(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
        requires random_access_range<@\exposid{Base}@>;
        friend constexpr bool operator>(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
        requires random_access_range<@\exposid{Base}@>;
        friend constexpr bool operator<=(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
        requires random_access_range<@\exposid{Base}@>;
        friend constexpr bool operator>=(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
        requires random_access_range<@\exposid{Base}@>;
        friend constexpr auto operator<=>(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
        requires random_access_range<@\exposid{Base}@> && three_way_comparable<iterator_t<@\exposid{Base}@>>;

        friend constexpr iterator operator+(const @\exposid{iterator}@& x, difference_type y)
        requires random_access_range<@\exposid{Base}@>;
        friend constexpr @\exposid{iterator}@ operator+(difference_type x, const @\exposid{iterator}@& y)
        requires random_access_range<@\exposid{Base}@>;
        friend constexpr @\exposid{iterator}@ operator-(const @\exposid{iterator}@& x, difference_type y)
        requires random_access_range<@\exposid{Base}@>;
        friend constexpr difference_type operator-(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
        requires random_access_range<@\exposid{Base}@>;

        friend constexpr decltype(auto) iter_move(const @\exposid{iterator}@& i)
        noexcept(noexcept(ranges::iter_move(i.@\exposid{current_}@))) {
            return enumerate_result<index_type,
                       range_rvalue_reference_t<Base>>{@\exposid{pos}@, ranges::iter_move(i.@\exposid{current_}@)};
        }

        friend constexpr void iter_swap(const iterator& x, const iterator& y)
        noexcept(noexcept(ranges::iter_swap(x.@\exposid{current_}@, y.@\exposid{current_}@)))
        requires indirectly_swappable<iterator_t<@\exposid{Base}@>> {
            std::swap(x.@\exposid{pos_}@, y.@\exposid{pos_}@);
            ranges::iter_swap(x.@\exposid{current_}@, y.@\exposid{current_}@);
        }
    };

    };
}
\end{codeblock}

\tcode{iterator::iterator_concept} is defined as follows:
\begin{itemize}
\item If \exposid{Base} models \libconcept{random_access_range},
    then \tcode{iterator_concept} denotes \tcode{random_access_iterator_tag}.
    \item
    Otherwise, if \exposid{Base} models \libconcept{bidirectional_range},
    then \tcode{iterator_concept} denotes \tcode{bidirectional_iterator_tag}.
    \item
    Otherwise, if \exposid{Base} models \libconcept{forward_range},
    then \tcode{iterator_concept} \tcode{iterator_concept} denotes \tcode{forward_iterator_tag}.
     \item
    Otherwise, \tcode{iterator_concept} denotes \tcode{input_iterator_tag}.
\end{itemize}

\tcode{iterator::index_type} is defined as follow:
\begin{itemize}
    \item \tcode{ranges::range_size_t<\exposid{Base}>} if \tcode{\exposid{Base}} models \tcode{ranges::sized_range}
    \item Otherwise, \tcode{\placeholder{make-unsigned-like-t}<ranges::range_difference_t<\exposid{Base}>>}
\end{itemize}



\begin{itemdecl}
    constexpr explicit @\exposid{iterator}@(iterator_t<@\exposid{Base}@> current, range_difference_t<@\exposid{Base}@> pos = 0);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Initializes \tcode{current_} with \tcode{move(current)} and \exposid{pos} with \tcode{static_cast<index_type>(pos)}.
\end{itemdescr}

\begin{itemdecl}
    constexpr @\exposid{iterator}@(@\exposid{iterator}@<!Const> i)
    requires Const && @\libconcept{convertible_to}@<iterator_t<V>, iterator_t<@\exposid{Base}@>>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Initializes \exposid{current_} with \tcode{move(i.\exposid{current_})} and \exposid{pos} with \tcode{i.\exposid{pos}}.
\end{itemdescr}

\begin{itemdecl}
    constexpr iterator_t<@\exposid{Base}@> base() const&
    requires copyable<iterator_t<@\exposid{Base}@>>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to: \tcode{return \exposid{current_};}
\end{itemdescr}

\begin{itemdecl}
    constexpr iterator_t<@\exposid{Base}@> base() &&;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to: \tcode{return move(\exposid{current_});}
\end{itemdescr}

\begin{itemdecl}
    constexpr @\exposid{iterator}@& operator++();
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to:
    \begin{codeblock}
        ++@\exposid{pos_}@;
        ++@\exposid{current_}@;
        return *this;
    \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
    constexpr void operator++(int) requires (!@\libconcept{forward_range}@<@\exposid{Base}@>);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to:
    \begin{codeblock}
        ++@\exposid{pos_}@;
        ++@\exposid{current_}@;
    \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
    constexpr @\exposid{iterator}@ operator++(int) requires @\libconcept{forward_range}@<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to:
    \begin{codeblock}
        auto temp = *this;
        ++@\exposid{pos}@;
        ++@\exposid{current_}@;
        return temp;
    \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
    constexpr @\exposid{iterator}@& operator--() requires @\libconcept{bidirectional_range}@<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to:
    \begin{codeblock}
        --@\exposid{pos_}@;
        --@\exposid{current_}@;
        return *this;
    \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
    constexpr @\exposid{iterator}@ operator--(int) requires @\libconcept{bidirectional_range}@<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to:
    \begin{codeblock}
        auto temp = *this;
        --@\exposid{current_}@;
        --@\exposid{pos_}@;
        return temp;
    \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
    constexpr @\exposid{iterator}@& operator+=(difference_type n);
    requires @\libconcept{random_access_range}@<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to:
    \begin{codeblock}
        @\exposid{current_}@ += n;
        @\exposid{pos_}@ += n;
        return *this;
    \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
    constexpr @\exposid{iterator}@& operator-=(difference_type n)
    requires @\libconcept{random_access_range}@<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to:
    \begin{codeblock}
        @\exposid{current_}@ -= n;
        @\exposid{pos_}@ -= n;
        return *this;
    \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
    friend constexpr bool operator==(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
    requires equality_comparable<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to: \tcode{return x.\exposid{current_} == y.\exposid{current_};}
\end{itemdescr}

\begin{itemdecl}
    friend constexpr bool operator<(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
    requires @\libconcept{random_access_range}@<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to: \tcode{return x.\exposid{current_} < y.\exposid{current_};}
\end{itemdescr}

\begin{itemdecl}
    friend constexpr bool operator>(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
    requires @\libconcept{random_access_range}@<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to: \tcode{return y < x;}
\end{itemdescr}

\begin{itemdecl}
    friend constexpr bool operator<=(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
    requires @\libconcept{random_access_range}@<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to: \tcode{return !(y < x);}
\end{itemdescr}

\begin{itemdecl}
    friend constexpr bool operator>=(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
    requires @\libconcept{random_access_range}@<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to: \tcode{return !(x < y);}
\end{itemdescr}

\begin{itemdecl}
    friend constexpr auto operator<=>(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
    requires @\libconcept{random_access_range}@<@\exposid{Base}@> && @\libconcept{three_way_comparable}@<iterator_t<@\exposid{Base}@>>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to: \tcode{return x.\exposid{current_} <=> y.\exposid{current_};}
\end{itemdescr}

\begin{itemdecl}
    friend constexpr @\exposid{iterator}@ operator+(const @\exposid{iterator}@& x, difference_type y)
    requires @\libconcept{random_access_range}@<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to: \tcode{return \exposid{iterator}\{x\} += y;}
\end{itemdescr}

\begin{itemdecl}
    friend constexpr @\exposid{iterator}@ operator+(difference_type x, const @\exposid{iterator}@& y)
    requires @\libconcept{random_access_range}@<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to: \tcode{return y + x;}
\end{itemdescr}

\begin{itemdecl}
    constexpr @\exposid{iterator}@ operator-(const @\exposid{iterator}@& x, difference_type y)
    requires @\libconcept{random_access_range}@<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to: \tcode{return iterator\{x\} -= y;}
\end{itemdescr}

\begin{itemdecl}
    constexpr difference_type operator-(const @\exposid{iterator}@& x, const @\exposid{iterator}@& y)
    requires @\libconcept{random_access_range}@<@\exposid{Base}@>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to: \tcode{return x.\exposid{current_} - y.\exposid{current_};}
\end{itemdescr}


\rSec3[range.enumerate.sentinel]{Class template \tcode{enumerate_view::\exposid{sentinel}}}

\begin{codeblock}
namespace std::ranges {
    template<input_range V, size_t N>
    requires view<V>
    template<bool Const>
    class enumerate_view<V, N>::@\exposid{sentinel}@ {                 // \expos
        private:
        using @\exposid{Base}@ = conditional_t<Const, const V, V>;      // \expos
        sentinel_t<@\exposid{Base}@> @\exposid{end_}@ = sentinel_t<@\exposid{Base}@>();         // \expos
        public:
        @\exposid{sentinel}@() = default;
        constexpr explicit @\exposid{sentinel}@(sentinel_t<@\exposid{Base}@> end);
        constexpr @\exposid{sentinel}@(@\exposid{sentinel}@<!Const> other)
        requires Const && convertible_to<sentinel_t<V>, sentinel_t<@\exposid{Base}@>>;

        constexpr sentinel_t<@\exposid{Base}@> base() const;

        friend constexpr bool operator==(const @\exposid{iterator}@<Const>& x, const @\exposid{sentinel}@& y);

        friend constexpr range_difference_t<@\exposid{Base}@>
        operator-(const @\exposid{iterator}@<Const>& x, const @\exposid{sentinel}@& y)
        requires sized_sentinel_for<sentinel_t<@\exposid{Base}@>, iterator_t<@\exposid{Base}@>>;

        friend constexpr range_difference_t<@\exposid{Base}@>
        operator-(const @\exposid{sentinel}@& x, const @\exposid{iterator}@<Const>& y)
        requires sized_sentinel_for<sentinel_t<@\exposid{Base}@>, iterator_t<@\exposid{Base}@>>;
    };
}
\end{codeblock}

\begin{itemdecl}
    constexpr explicit @\exposid{sentinel}@(sentinel_t<@\exposid{Base}@> end);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Initializes \exposid{end_} with \tcode{end}.
\end{itemdescr}

\begin{itemdecl}
    constexpr @\exposid{sentinel}@(@\exposid{sentinel}@<!Const> other)
    requires Const && @\libconcept{convertible_to}@<sentinel_t<V>, sentinel_t<@\exposid{Base}@>>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Initializes \exposid{end_} with \tcode{move(other.\exposid{end_})}.
\end{itemdescr}

\begin{itemdecl}
    constexpr sentinel_t<@\exposid{Base}@> base() const;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to: \tcode{return \exposid{end_};}
\end{itemdescr}

\begin{itemdecl}
    friend constexpr bool operator==(const @\exposid{iterator}@<Const>& x, const @\exposid{sentinel}@& y);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to: \tcode{return x.\exposid{current_} == y.\exposid{end_};}
\end{itemdescr}

\begin{itemdecl}
    friend constexpr range_difference_t<@\exposid{Base}@>
    operator-(const @\exposid{iterator}@<Const>& x, const @\exposid{sentinel}@& y)
    requires sized_sentinel_for<sentinel_t<@\exposid{Base}@>, iterator_t<@\exposid{Base}@>>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to: \tcode{return x.\exposid{current_} - y.\exposid{end_};}
\end{itemdescr}

\begin{itemdecl}
    friend constexpr range_difference_t<@\exposid{Base}@>
    operator-(const @\exposid{sentinel}@& x, const @\exposid{iterator}@<Const>& y)
    requires sized_sentinel_for<sentinel_t<@\exposid{Base}@>, iterator_t<@\exposid{Base}@>>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to: \tcode{return x.\exposid{end_} - y.\exposid{current_};}
\end{itemdescr}

\subsection{Feature test macro}

\ednote{define \tcode{__cpp_lib_ranges_enumerate} set to the date of adoption in \tcode{<version>} and \tcode{<ranges>}}.

\end{addedblock}


\section{Acknowledgments}

Thanks a lot to \tcode{Tomasz Kamiński} for finding defects in the design proposed in earlier revisions, as well as his invaluable wording feedbacks.
Thanks to Barry Revzin and Christopher Di Bella for their inputs on the design.

\section{References}
\renewcommand{\section}[2]{}%
\bibliographystyle{plain}
\bibliography{wg21, extra}

\begin{thebibliography}{9}

\bibitem[N4885]{N4885}
Thomas Köppe
\emph{Working Draft, Standard for Programming Language C++}\newline
\url{https://wg21.link/N4885}


\end{thebibliography}
\end{document}