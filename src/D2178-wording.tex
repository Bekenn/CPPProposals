% !TeX program = luatex
% !TEX encoding = UTF-8


\RequirePackage{luatex85}
\documentclass{wg21}



\title{Reformulating Lexing in terms of unicode}
\docnumber{Not}
\audience{LEWG}
\author{Corentin Jabot}{corentin.jabot@gmail.com}

\newcommand{\paper}[1]{ \href{https://wg21.link/#1}{#1} \cite{#1}}

\begin{document}
\maketitle

\paperquote{}


\section{Intent of changes}

\begin{itemize}
\item Make lossy conversion ill-formed as per P1854
\item Mandate support for UFT-8 source files (\paper{N3463})
\item Mandate that unicode encoded source are not normalized in phase 1
\item Mandate that conversion to unicode encoded literals doesn't normalize
\item Specify that conversion to non-unicode encoded literals may result in a different number of code points
\item Specify th behavior of a \ at the end of the file
\item Specify what constitute a new line
\item Universal character names are substituted to codepoints in phase 2, internal representation is unicode
\item Apply changes from P2029
\end{itemize}

TODO:

\begin{itemize}
\item use more terminology from P1859
\item remove remaining reference to basic source character set
\end{itemize}

Issue fixed
\begin{itemize}
    \item \paper{CWG1332}
    \item \paper{CWG1655}
    \item \paper{CWG1335}
    \item \paper{CWG578}
    \item \paper{CWG1403}
    \item \paper{CWG411}
\end{itemize}




\section{Wording}

\rSec1[syntax]{Syntax notation}

\pnum
\indextext{notation!syntax|(}%
In the syntax notation used in this document, syntactic
categories are indicated by \grammarterm{italic} type, and literal words
and characters in \tcode{constant} \tcode{width} type. Alternatives are
listed on separate lines except in a few cases where a long set of
alternatives is marked by the phrase ``one of''. If the text of an alternative is too long to fit on a line, the text is continued on subsequent lines indented from the first one.
An optional terminal or non-terminal symbol is indicated by the subscript
``\opt{\relax}'', so
\begin{ncbnf}
    \terminal{\{} \opt{expression} \terminal{\}}
\end{ncbnf}
indicates an optional expression enclosed in braces.%

\begin{addedblock}
Unless otherwise specified, the glyphs used to describe the syntax notation refer to codepoint in the Basic Latin Unicode block described in ISO/IEC 10646. 
\end{addedblock}

\pnum
Names for syntactic categories have generally been chosen according to
the following rules:
\begin{itemize}
    \item \grammarterm{X-name} is a use of an identifier in a context that
    determines its meaning (e.g., \grammarterm{class-name},
    \grammarterm{typedef-name}).
    \item \grammarterm{X-id} is an identifier with no context-dependent meaning
    (e.g., \grammarterm{qualified-id}).
    \item \grammarterm{X-seq} is one or more \grammarterm{X}'s without intervening
    delimiters (e.g., \grammarterm{declaration-seq} is a sequence of
    declarations).
    \item \grammarterm{X-list} is one or more \grammarterm{X}'s separated by
    intervening commas (e.g., \grammarterm{identifier-list} is a sequence of
    identifiers separated by commas).
\end{itemize}%
\indextext{notation!syntax|)}


\rSec1[intro.defs]{Terms and definitions}

\pnum
\indextext{definitions|(}%
For the purposes of this document,
the terms and definitions
given in ISO/IEC 2382-1:1993,
the terms, definitions, and symbols
given in ISO 80000-2:2009,
and the following apply.

\pnum
ISO and IEC maintain terminological databases
for use in standardization
at the following addresses:
\begin{itemize}
    \item ISO Online browsing platform: available at \url{https://www.iso.org/obp}
    \item IEC Electropedia: available at \url{http://www.electropedia.org/}
\end{itemize}

\pnum

\pnum
Terms that are used only in a small portion of this document
are defined where they are used and italicized where they are
defined.


\rSec3[defns.multibyte]{multibyte character}

sequence of one or more \changed{bytes}{code units} representing a member of the
\changed{extended character set of either the source or the execution environment}{that character\'s associated character set}

\begin{removedblock}
\begin{note}
    The extended character set is a superset of the basic character
    set lex.charset.
\end{note}
\end{removedblock}


\begin{addedblock}
\rSec3[defns.unicode]{Unicode}

Unicode and Unicode character set refers to the character set described in ISO/IEC 10646.  

\end{addedblock}


\rSec1[lex]{Lexical conventions}

\gramSec[gram.lex]{Lexical conventions}


\rSec1[lex.phases]{Phases of translation}%

\pnum
\indextext{translation!phases|(}%
The precedence among the syntax rules of translation is specified by the
following phases.\footnote{Implementations must behave as if these separate phases
    occur, although in practice different phases might be folded together.}

\begin{enumerate}
    \item
    \begin{removedblock}
    \indextext{character!source file}%
    \indextext{character set!basic source}%
    Physical source file characters are mapped, in an
    \impldef{mapping physical source file characters to basic source character set} manner,
    to the basic source character set (introducing new-line characters for end-of-line
    indicators) if necessary.
    The set of physical source file characters accepted is \impldef{physical source file
        characters}.
    Any
    source file character not in the basic source character
    set\iref{lex.charset} is replaced by the
    \indextext{universal character name}\grammarterm{universal-character-name} that
    designates that character. An implementation may use any internal
    encoding, so long as an actual extended character encountered in the
    source file, and the same extended character expressed in the source
    file as a \grammarterm{universal-character-name} (e.g., using the \tcode{\textbackslash
        uXXXX} notation), are handled equivalently
    except where this replacement is reverted\iref{lex.pptoken} in a raw string literal.

    \end{removedblock}
    \begin{addedblock}

    If the physical source character is the Unicode character set, each code point in the source file is converted to the internal representation of that same code point. Codepoints that are surrogate codepoints or invalid code points are ill-formed.
    
    Otherwise, each abstract character in the source file is mapped in an implementation-defined manner to a sequence of Unicode codepoint representing the same abstract character.
    (introducing new-line characters for end-of-line indicators if necessary).
    
    An implementation may use any internal encoding able to represent uniquely any Unicode codepoint.
    If an abstract character in the source file is not representable in the Unicode character set, the program is ill-formed.
    
    An implementation supports source files representing a sequence of UTF-8 code units. Any additional physical source file character sets accepted are implementation-defined. How the the character set of a source is determined is implementation defined.
    

\end{addedblock}
    \item
\begin{addedblock}
    Each implementation-defined line termination sequence of characters is replaced by a new-line character (U+000A).
\end{addedblock}
    Each instance of a backslash character (\textbackslash)
    immediately followed by a new-line character \added{or at the end of a file} is deleted, splicing
    physical source lines to form logical source lines. Only the last
    backslash on any physical source line shall be eligible for being part
    of such a splice.
    Except for splices reverted in a raw string literal, if a splice results in
    a character sequence that matches the
    syntax of a \grammarterm{universal-character-name}, the behavior is
    undefined. A source file that is not empty and that does not end in a new-line
    character, or that ends in a new-line character immediately preceded by a
    backslash character before any such splicing takes place,
    shall be processed as if an additional new-line character were appended
    to the file.
    
    
    \begin{addedblock}
    Sequences of whitespace characters at the end of each line are removed.
    
    Each \grammarterm{universal-character-name} is replaced by the unicode code point it designates.
    \end{addedblock}

    \item The source file is decomposed into preprocessing
    tokens\iref{lex.pptoken} and sequences of white-space characters
    (including comments). A source file shall not end in a partial
    preprocessing token or in a partial comment.\footnote{A partial preprocessing
        token would arise from a source file
        ending in the first portion of a multi-character token that requires a
        terminating sequence of characters, such as a \grammarterm{header-name}
        that is missing the closing \tcode{"}
        or \tcode{>}. A partial comment
        would arise from a source file ending with an unclosed \tcode{/*}
        comment.}
    Each comment is replaced by one space character. New-line characters are
    retained. Whether each nonempty sequence of white-space characters other
    than new-line is retained or replaced by one space character is
    unspecified. The process of dividing a source file's
    characters into preprocessing tokens is context-dependent.
    \begin{example}
        See the handling of \tcode{<} within a \tcode{\#include} preprocessing
        directive.
    \end{example}

    \item Preprocessing directives are executed, macro invocations are
    expanded, and \tcode{_Pragma} unary operator expressions are executed.
    If a character sequence that matches the syntax of a
    \grammarterm{universal-character-name} is produced by token
    concatenation\iref{cpp.concat}, the behavior is undefined. A
    \tcode{\#include} preprocessing directive causes the named header or
    source file to be processed from phase 1 through phase 4, recursively.
    All preprocessing directives are then deleted.

    \item 
    \begin{removedblock}Each basic source character set member in a \grammarterm{character-literal} or a
    \grammarterm{string-literal}, as well as each escape sequence and \grammarterm{universal-character-name} in a
    \grammarterm{character-literal} or a non-raw string literal, is converted to the corresponding
    member of the execution character set~(\ref{lex.ccon}, \ref{lex.string}); if
    there is no corresponding member, it is converted to an \impldef{converting
        characters from source character set to execution character set} member other
    than the null (wide) character.\footnote{\removed{An implementation need not convert all
        non-corresponding source characters to the same execution character.}}
    \end{removedblock}
    
    \begin{addedblock}
        Each codepoint in a \grammarterm{character-literal} or a \grammarterm{string-literal}, is converted to a sequence of code units in the literal's associated character encoding representing the same abstract character. If the abstract character is not representable in the literal associated character set, the program is ill-formed.
        If that literal's associated character encoding encodes the Unicode character set, the converted sequence of code units represents the same code points as the internal representation.  
        
        Each escape sequence in a \grammarterm{character-literal} or a non-raw string literal, is converted to the corresponding
        member of the execution character set.
    \end{addedblock}

    \item Adjacent string literal tokens are concatenated.

    \item White-space characters separating tokens are no longer
    significant. Each preprocessing token is converted into a
    token\iref{lex.token}. The resulting tokens are syntactically and
    semantically analyzed and translated as a translation unit.
    \begin{note}
        The process of analyzing and translating the tokens may occasionally
        result in one token being replaced by a sequence of other
        tokens\iref{temp.names}.
    \end{note}
    It is
    \impldef{whether the sources for
        module units and header units
        on which the current translation unit has an interface
        dependency are required to be available during translation}
    whether the sources for
    module units and header units
    on which the current translation unit has an interface
    dependency (\ref{module.unit}, \ref{module.import})
    are required to be available.
    \begin{note}
        Source files, translation
        units and translated translation units need not necessarily be stored as
        files, nor need there be any one-to-one correspondence between these
        entities and any external representation. The description is conceptual
        only, and does not specify any particular implementation.
    \end{note}

    \item Translated translation units and instantiation units are combined
    as follows:
    \begin{note}
        Some or all of these may be supplied from a
        library.
    \end{note}
    Each translated translation unit is examined to
    produce a list of required instantiations.
    \begin{note}
        This may include
        instantiations which have been explicitly
        requested\iref{temp.explicit}.
    \end{note}
    The definitions of the
    required templates are located. It is \impldef{whether source of translation units must
        be available to locate template definitions} whether the
    source of the translation units containing these definitions is required
    to be available.
    \begin{note}
        An implementation could encode sufficient
        information into the translated translation unit so as to ensure the
        source is not required here.
    \end{note}
    All the required instantiations
    are performed to produce
    \defn{instantiation units}.
    \begin{note}
        These are similar
        to translated translation units, but contain no references to
        uninstantiated templates and no template definitions.
    \end{note}
    The
    program is ill-formed if any instantiation fails.

    \item All external entity references are resolved. Library
    components are linked to satisfy external references to
    entities not defined in the current translation. All such translator
    output is collected into a program image which contains information
    needed for execution in its execution environment.%
    \indextext{translation!phases|)}
\end{enumerate}

\rSec1[lex.charset]{Character sets}

\pnum
\indextext{character set|(}%

\begin{removedblock}
The \defnx{basic source character set}{character set!basic source} consists of 96 characters: the space character,
the control characters representing horizontal tab, vertical tab, form feed, and
new-line, plus the following 91 graphical characters:\footnote{\removed{The glyphs for
    the members of the basic source character set are intended to
    identify characters from the subset of ISO/IEC 10646 which corresponds to the ASCII
    character set. However, because the mapping from source file characters to the source
    character set (described in translation phase 1) is specified as
    \impldef{mapping from physical source file characters to basic source character set},
    an implementation is required to document how the basic source characters are
    represented in source files.}}
\begin{codeblock}
    a b c d e f g h i j k l m n o p q r s t u v w x y z
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
    0 1 2 3 4 5 6 7 8 9
    _ { } [ ] # ( ) < > % : ; . ? * + - / ^ & | ~ ! = , @\textbackslash@ " '
\end{codeblock}

\end{removedblock}

\pnum
The \grammarterm{universal-character-name} construct provides a way to name
other characters.

\begin{bnf}
    \nontermdef{hex-quad}\br
    hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
\end{bnf}

\begin{bnf}
    \nontermdef{universal-character-name}\br
    \terminal{\textbackslash u} hex-quad\br
    \terminal{\textbackslash U} hex-quad hex-quad
\end{bnf}

A \grammarterm{universal-character-name}
designates the character in ISO/IEC 10646 (if any)
whose code point is the hexadecimal number represented by
the sequence of \grammarterm{hexadecimal-digit}s
in the \grammarterm{universal-character-name}.
The program is ill-formed if that number is not a code point
or if it is a surrogate code point.
Noncharacter code points and reserved code points
are considered to designate separate characters distinct from
any ISO/IEC 10646 character.
If a \grammarterm{universal-character-name} outside
the \grammarterm{c-char-sequence}, \grammarterm{s-char-sequence}, or
\grammarterm{r-char-sequence} of
a \grammarterm{character-literal} or \grammarterm{string-literal}
(in either case, including within a \grammarterm{user-defined-literal})
corresponds to a \changed{control character or
to a character in the basic
source character set}{character in the Basic Latin Unicode Block}, the program is ill-formed.\footnote{A sequence of characters resembling a \grammarterm{universal-character-name} in an
    \grammarterm{r-char-sequence}\iref{lex.string} does not form a
    \grammarterm{universal-character-name}.}
\begin{note}
    \removed{ISO/IEC 10646 code points are integers in the range $[0, \mathrm{10FFFF}]$ (hexadecimal).}
    A surrogate code point is a value in the range $[\mathrm{D800}, \mathrm{DFFF}]$ (hexadecimal).
    \removed{A control character is a character whose code point is
    in either of the ranges $[0, \mathrm{1F}]$ or $[\mathrm{7F}, \mathrm{9F}]$ (hexadecimal).}
\end{note}

\begin{addedblock}
The \defnx{basic character set}{character set!basic execution} contains the following characters:

\begin{codeblock}
   U+0000 NULL
   U+0007 BELL
   U+0008 BACKSPACE
   U+0009 CHARACTER TABULATION
   U+000A LINE FEED 
   U+000B LINE TABULATION
   U+000C FORM FEED
   U+000D CARRIAGE RETURN 
   U+0020 SPACE
!  U+0021 EXCLAMATION MARK
"  U+0022 QUOTATION MARK
#  U+0023 NUMBER SIGN
%  U+0025 PERCENT SIGN
&  U+0026 AMPERSAND
'  U+0027 APOSTROPHE
(  U+0028 LEFT PARENTHESIS
)  U+0029 RIGHT PARENTHESIS
*  U+002A ASTERISK
+  U+002B PLUS SIGN
,  U+002C COMMA
-  U+002D HYPHEN-MINUS
.  U+002E FULL STOP
/  U+002F SOLIDUS
0  U+0030 DIGIT ZERO
1  U+0031 DIGIT ONE
2  U+0032 DIGIT TWO
3  U+0033 DIGIT THREE
4  U+0034 DIGIT FOUR
5  U+0035 DIGIT FIVE
6  U+0036 DIGIT SIX
7  U+0037 DIGIT SEVEN
8  U+0038 DIGIT EIGHT
9  U+0039 DIGIT NINE
:  U+003A COLON
;  U+003B SEMICOLON
<  U+003C LESS-THAN SIGN
=  U+003D EQUALS SIGN
>  U+003E GREATER-THAN SIGN
?  U+003F QUESTION MARK
A  U+0041 LATIN CAPITAL LETTER A
B  U+0042 LATIN CAPITAL LETTER B
C  U+0043 LATIN CAPITAL LETTER C
D  U+0044 LATIN CAPITAL LETTER D
E  U+0045 LATIN CAPITAL LETTER E
F  U+0046 LATIN CAPITAL LETTER F
G  U+0047 LATIN CAPITAL LETTER G
H  U+0048 LATIN CAPITAL LETTER H
I  U+0049 LATIN CAPITAL LETTER I
J  U+004A LATIN CAPITAL LETTER J
K  U+004B LATIN CAPITAL LETTER K
L  U+004C LATIN CAPITAL LETTER L
M  U+004D LATIN CAPITAL LETTER M
N  U+004E LATIN CAPITAL LETTER N
O  U+004F LATIN CAPITAL LETTER O
P  U+0050 LATIN CAPITAL LETTER P
Q  U+0051 LATIN CAPITAL LETTER Q
R  U+0052 LATIN CAPITAL LETTER R
S  U+0053 LATIN CAPITAL LETTER S
T  U+0054 LATIN CAPITAL LETTER T
U  U+0055 LATIN CAPITAL LETTER U
V  U+0056 LATIN CAPITAL LETTER V
W  U+0057 LATIN CAPITAL LETTER W
X  U+0058 LATIN CAPITAL LETTER X
Y  U+0059 LATIN CAPITAL LETTER Y
Z  U+005A LATIN CAPITAL LETTER Z
[  U+005B LEFT SQUARE BRACKET
\  U+005C REVERSE SOLIDUS
]  U+005D RIGHT SQUARE BRACKET
^  U+005E CIRCUMFLEX ACCENT
_  U+005F LOW LINE
a  U+0061 LATIN SMALL LETTER A
b  U+0062 LATIN SMALL LETTER B
c  U+0063 LATIN SMALL LETTER C
d  U+0064 LATIN SMALL LETTER D
e  U+0065 LATIN SMALL LETTER E
f  U+0066 LATIN SMALL LETTER F
g  U+0067 LATIN SMALL LETTER G
h  U+0068 LATIN SMALL LETTER H
i  U+0069 LATIN SMALL LETTER I
j  U+006A LATIN SMALL LETTER J
k  U+006B LATIN SMALL LETTER K
l  U+006C LATIN SMALL LETTER L
m  U+006D LATIN SMALL LETTER M
n  U+006E LATIN SMALL LETTER N
o  U+006F LATIN SMALL LETTER O
p  U+0070 LATIN SMALL LETTER P
q  U+0071 LATIN SMALL LETTER Q
r  U+0072 LATIN SMALL LETTER R
s  U+0073 LATIN SMALL LETTER S
t  U+0074 LATIN SMALL LETTER T
u  U+0075 LATIN SMALL LETTER U
v  U+0076 LATIN SMALL LETTER V
w  U+0077 LATIN SMALL LETTER W
x  U+0078 LATIN SMALL LETTER X
y  U+0079 LATIN SMALL LETTER Y
z  U+007A LATIN SMALL LETTER Z
{  U+007B LEFT CURLY BRACKET
|  U+007C VERTICAL LINE
}  U+007D RIGHT CURLY BRACKET
~  U+007E TILDE
\end{codeblock}


\end{addedblock}

\pnum
\begin{removedblock}
The \defnx{basic execution character set}{character set!basic execution} and the
\defnx{basic execution wide-character set}{wide-character set!basic execution}
shall each contain all the members of the
basic source character set, plus control characters representing alert,
backspace, and carriage return, plus a \defnx{null character}{character!null}
(respectively, \defnx{null wide character}{wide-character!null}), whose value is 0.

For each basic execution character set, the values of the
members shall be non-negative and distinct from one another. In both the
source and execution basic character sets, the value of each character
after \tcode{0} in the above list of decimal digits shall be one greater
than the value of the previous. The \defnx{execution character set}{character set!execution}
and the \defnx{execution wide-character set}{wide-character set!execution} are
\impldef{execution character set and execution wide-character set}
supersets of the
basic execution character set and the basic execution wide-character
set, respectively. The values of the members of the execution character sets
and the sets of additional members
are locale-specific.%
\indextext{character set|)}

\end{removedblock}
\begin{addedblock}
The \defnx{execution character set}{character set!execution}
and the \defnx{execution wide-character set}{wide-character set!execution} are
\impldef{execution character set and execution wide-character set}
supersets of the \defnx{basic character set}.
For each execution character set, the values of the
members shall be non-negative and distinct from one another and the value of each character
after \tcode{0} in the above list of decimal digits shall be one greater
than the value of the previous.
The value of the NULL character shall be 0.
The values of the other members of the execution character sets
and the sets of additional members are implementation-defined.%
\indextext{character set|)}
\end{addedblock}

\begin{addedblock}
The \defn{execution encoding} refers to the implementation-defined character encodings used to encode character and string literals in the \defn{execution character set}.

The \defn{execution wide-encoding} refers to the implementation-defined character encodings used to encode wide character and string literals in the \defn{execution wide-character set}.

\end{addedblock}


\rSec1[lex.pptoken]{Preprocessing tokens}

\indextext{token!preprocessing|(}%
\begin{bnf}
    \nontermdef{preprocessing-token}\br
    header-name\br
    import-keyword\br
    module-keyword\br
    export-keyword\br
    identifier\br
    pp-number\br
    character-literal\br
    user-defined-character-literal\br
    string-literal\br
    user-defined-string-literal\br
    preprocessing-op-or-punc\br
    \removed{\textnormal{\defn{each universal-character-name} that cannot be one of the above}}\br
    \textnormal{each non-white-space \changed{character}{codepoint} that cannot be one of the above}
\end{bnf}

\pnum
Each preprocessing token that is converted to a token\iref{lex.token}
shall have the lexical form of a keyword, an identifier, a literal,
or an operator or punctuator.

\pnum
A preprocessing token is the minimal lexical element of the language in translation
phases 3 through 6. The categories of preprocessing token are: header names,
placeholder tokens produced by preprocessing \tcode{import} and \tcode{module} directives
(\grammarterm{import-keyword}, \grammarterm{module-keyword}, and \grammarterm{export-keyword}),
identifiers, preprocessing numbers, character literals (including user-defined character
literals), string literals (including user-defined string literals), preprocessing
operators and punctuators, and single non-white-space \changed{characters}{codepoint} that do not lexically
match the other preprocessing token categories. If a \tcode{'} or a \tcode{"} character
matches the last category, the behavior is undefined. Preprocessing tokens can be
separated by
\indextext{space!white}%
white space;
\indextext{comment}%
this consists of comments\iref{lex.comment}, or white-space
characters (space, horizontal tab, new-line, vertical tab, and
form-feed), or both. As described in \ref{cpp}, in certain
circumstances during translation phase 4, white space (or the absence
thereof) serves as more than preprocessing token separation. White space
can appear within a preprocessing token only as part of a header name or
between the quotation characters in a character literal or
string literal.

\pnum
If the input stream has been parsed into preprocessing tokens up to a
given character:
\begin{itemize}
    \item
    \indextext{literal!string!raw}%
    If the next character begins a sequence of characters that could be the prefix
    and initial double quote of a raw string literal, such as \tcode{R"}, the next preprocessing
    token shall be a raw string literal. Between the initial and final
    double quote characters of the raw string, any transformations performed \changed{in phases
    1 and 2 (\grammarterm{universal-character-name}{s} and line splicing)}{in phase 2 (\grammarterm{universal-character-name}{s}, line termination replacement, line splicing and whitespace trimming)} are reverted; this reversion
    shall apply before any \grammarterm{d-char}, \grammarterm{r-char}, or delimiting
    parenthesis is identified. The raw string literal is defined as the shortest sequence
    of characters that matches the raw-string pattern
    \begin{ncbnf}
        \opt{encoding-prefix} \terminal{R} raw-string
    \end{ncbnf}

    \item Otherwise, if the next three characters are \tcode{<::} and the subsequent character
    is neither \tcode{:} nor \tcode{>}, the \tcode{<} is treated as a preprocessing token by
    itself and not as the first character of the alternative token \tcode{<:}.

    \item Otherwise,
    the next preprocessing token is the longest sequence of
    characters that could constitute a preprocessing token, even if that
    would cause further lexical analysis to fail,
    except that a \grammarterm{header-name}\iref{lex.header} is only formed
    \begin{itemize}
        \item
        after the \tcode{include} or \tcode{import} preprocessing token in an
        \tcode{\#include}\iref{cpp.include} or
        \tcode{import}\iref{cpp.import} directive, or

        \item
        within a \grammarterm{has-include-expression}.

    \end{itemize}
\end{itemize}

\begin{example}
    \begin{codeblock}
        #define R "x"
        const char* s = R"y";           // ill-formed raw string, not \tcode{"x" "y"}
    \end{codeblock}
\end{example}

\pnum
The \grammarterm{import-keyword} is produced
by processing an \tcode{import} directive\iref{cpp.import},
the \grammarterm{module-keyword} is produced
by preprocessing a \tcode{module} directive\iref{cpp.module}, and
the \grammarterm{export-keyword} is produced
by preprocessing either of the previous two directives.
\begin{note}
    None has any observable spelling.
\end{note}

\pnum
\begin{example}
    The program fragment \tcode{0xe+foo} is parsed as a
    preprocessing number token (one that is not a valid
    \grammarterm{integer-literal} or \grammarterm{floating-point-literal} token),
    even though a parse as three preprocessing tokens
    \tcode{0xe}, \tcode{+}, and \tcode{foo} might produce a valid expression (for example,
    if \tcode{foo} were a macro defined as \tcode{1}). Similarly, the
    program fragment \tcode{1E1} is parsed as a preprocessing number (one
    that is a valid \grammarterm{floating-point-literal} token),
    whether or not \tcode{E} is a macro name.
\end{example}

\pnum
\begin{example}
    The program fragment \tcode{x+++++y} is parsed as \tcode{x
        ++ ++ + y}, which, if \tcode{x} and \tcode{y} have integral types,
    violates a constraint on increment operators, even though the parse
    \tcode{x ++ + ++ y} might yield a correct expression.
\end{example}
\indextext{token!preprocessing|)}

\rSec1[lex.digraph]{Alternative tokens}

\pnum
\indextext{token!alternative|(}%
Alternative token representations are provided for some operators and
punctuators.\footnote{\indextext{digraph}%
    These include ``digraphs'' and additional reserved words. The term
    ``digraph'' (token consisting of two characters) is not perfectly
    descriptive, since one of the alternative \grammarterm{preprocessing-token}s is
    \tcode{\%:\%:} and of course several primary tokens contain two
    characters. Nonetheless, those alternative tokens that aren't lexical
    keywords are colloquially known as ``digraphs''. }

\pnum
In all respects of the language, each alternative token behaves the
same, respectively, as its primary token, except for its spelling.\footnote{Thus the ``stringized'' values\iref{cpp.stringize} of
    \tcode{[} and \tcode{<:} will be different, maintaining the source
    spelling, but the tokens can otherwise be freely interchanged. }
The set of alternative tokens is defined in
\tref{lex.digraph}.

\begin{tokentable}{Alternative tokens}{lex.digraph}{Alternative}{Primary}
    \tcode{<\%}             &   \tcode{\{}         &
    \tcode{and}             &   \tcode{\&\&}       &
    \tcode{and_eq}          &   \tcode{\&=}        \\ \rowsep
    \tcode{\%>}             &   \tcode{\}}         &
    \tcode{bitor}           &   \tcode{|}          &
    \tcode{or_eq}           &   \tcode{|=}         \\ \rowsep
    \tcode{<:}              &   \tcode{[}          &
    \tcode{or}              &   \tcode{||}         &
    \tcode{xor_eq}          &   \tcode{\textasciicircum=}    \\ \rowsep
    \tcode{:>}              &   \tcode{]}          &
    \tcode{xor}             &   \tcode{\textasciicircum}     &
    \tcode{not}             &   \tcode{!}          \\ \rowsep
    \tcode{\%:}             &   \tcode{\#}         &
    \tcode{compl}           &   \tcode{\~}         &
    \tcode{not_eq}          &   \tcode{!=}         \\ \rowsep
    \tcode{\%:\%:}          &   \tcode{\#\#}       &
    \tcode{bitand}          &   \tcode{\&}         &
    &                      \\
\end{tokentable}%
\indextext{token!alternative|)}

\rSec1[lex.token]{Tokens}

\indextext{token|(}%
\begin{bnf}
    \nontermdef{token}\br
    identifier\br
    keyword\br
    literal\br
    operator-or-punctuator
\end{bnf}

\pnum
\indextext{\idxgram{token}}%
There are five kinds of tokens: identifiers, keywords, literals,\footnote{Literals include strings and character and numeric literals.
}
operators, and other separators.
\indextext{white space}%
Blanks, horizontal and vertical tabs, newlines, formfeeds, and comments
(collectively, ``white space''), as described below, are ignored except
as they serve to separate tokens.
\begin{note}
    Some white space is
    required to separate otherwise adjacent identifiers, keywords, numeric
    literals, and alternative tokens containing alphabetic characters.
\end{note}
\indextext{token|)}

\rSec1[lex.comment]{Comments}

\pnum
\indextext{comment|(}%
\indextext{comment!\tcode{/*} \tcode{*/}}%
\indextext{comment!\tcode{//}}%
The characters \tcode{/*} start a comment, which terminates with the
characters \tcode{*/}. These comments do not nest.
\indextext{comment!\tcode{//}}%
The characters \tcode{//} start a comment, which terminates immediately before the
next new-line character. If there is a form-feed or a vertical-tab
character in such a comment, only white-space characters shall appear
between it and the new-line that terminates the comment; no diagnostic
is required.
\begin{note}
    The comment characters \tcode{//}, \tcode{/*},
    and \tcode{*/} have no special meaning within a \tcode{//} comment and
    are treated just like other characters. Similarly, the comment
    characters \tcode{//} and \tcode{/*} have no special meaning within a
    \tcode{/*} comment.
\end{note}
\indextext{comment|)}

\rSec1[lex.header]{Header names}

\indextext{header!name|(}%
\begin{bnf}
    \nontermdef{header-name}\br
    \terminal{<} h-char-sequence \terminal{>}\br
    \terminal{"} q-char-sequence \terminal{"}
\end{bnf}

\begin{bnf}
    \nontermdef{h-char-sequence}\br
    h-char\br
    h-char-sequence h-char
\end{bnf}

\begin{bnf}
    \nontermdef{h-char}\br
    \textnormal{any member of the source character set except new-line and \terminal{>}}
\end{bnf}

\begin{bnf}
    \nontermdef{q-char-sequence}\br
    q-char\br
    q-char-sequence q-char
\end{bnf}

\begin{bnf}
    \nontermdef{q-char}\br
    \textnormal{any member of the source character set except new-line and \terminal{"}}
\end{bnf}

\pnum
\begin{note}
    Header name preprocessing tokens only appear within
    a \tcode{\#include} preprocessing directive,
    a \tcode{__has_include} preprocessing expression, or
    after certain occurrences of an \tcode{import} token
    (see~\ref{lex.pptoken}).
\end{note}
The sequences in both forms of \grammarterm{header-name}{s} are mapped in an
\impldef{mapping header name to header or external source file} manner to headers or to
external source file names as specified in~\ref{cpp.include}.

\pnum
The appearance of either of the characters \tcode{'} or \tcode{\textbackslash} or of
either of the character sequences \tcode{/*} or \tcode{//} in a
\grammarterm{q-char-sequence} or an \grammarterm{h-char-sequence}
is conditionally-supported with \impldef{meaning of \tcode{'}, \tcode{\textbackslash},
    \tcode{/*}, or \tcode{//} in a \grammarterm{q-char-sequence} or an
    \grammarterm{h-char-sequence}} semantics, as is the appearance of the character
\tcode{"} in an \grammarterm{h-char-sequence}.\footnote{Thus, a sequence of characters
    that resembles an escape sequence might result in an error, be interpreted as the
    character corresponding to the escape sequence, or have a completely different meaning,
    depending on the implementation.}%
\indextext{header!name|)}

\rSec1[lex.ppnumber]{Preprocessing numbers}

\indextext{number!preprocessing|(}%
\begin{bnf}
    \nontermdef{pp-number}\br
    digit\br
    \terminal{.} digit\br
    pp-number identifier-continue\br
    \removed{pp-number \terminal{'} digit}\br
    \removed{pp-number \terminal{'} nondigit}\br
    \added{pp-number \terminal{'} identifier-continue
    }\br
    pp-number \terminal{e} sign\br
    pp-number \terminal{E} sign\br
    pp-number \terminal{p} sign\br
    pp-number \terminal{P} sign\br
    pp-number \terminal{.}
\end{bnf}

\pnum
Preprocessing number tokens lexically include
all \grammarterm{integer-literal} tokens\iref{lex.icon} and
all \grammarterm{floating-point-literal} tokens\iref{lex.fcon}.

\pnum
A preprocessing number does not have a type or a value; it acquires both
after a successful conversion to
an \grammarterm{integer-literal} token or
a \grammarterm{floating-point-literal} token.%
\indextext{number!preprocessing|)}

\rSec1[lex.name]{Identifiers}

\indextext{identifier|(}%
\begin{bnf}
    \nontermdef{identifier}\br
    identifier-start\br
    identifier identifier-continue\br
\end{bnf}

\begin{bnf}
   \nontermdef{identifier-start}\br
   \changed{nondigit}\br
   \added{_}\br
    universal-character-name of class XID_Start
\end{bnf}

\begin{bnf}
    \nontermdef{identifier-continue}\br
    \removed{nondigit}\br
    \removed{digit}\br
    universal-character-name of class XID_Continue
\end{bnf}

\begin{bnf}
    \begin{removedblock}
    \nontermdef{nondigit} \textnormal{one of}\br
    \terminal{a b c d e f g h i j k l m}\br
    \terminal{n o p q r s t u v w x y z}\br
    \terminal{A B C D E F G H I J K L M}\br
    \terminal{N O P Q R S T U V W X Y Z _}
\end{removedblock}
\end{bnf}

\begin{bnf}
    \nontermdef{digit} \textnormal{one of}\br
    \terminal{0 1 2 3 4 5 6 7 8 9}
\end{bnf}

\pnum
\indextext{name!length of}%
\indextext{name}%
The character classes XID_Start and XID_Continue are specified in UAX 44.
\footnote{On systems in which linkers cannot accept \changed{extended
    characters, an encoding of the \grammarterm{universal-character-name} may be used in
    forming valid external identifiers. For example, some otherwise unused
    character or sequence of characters may be used to encode the
    \tcode{\textbackslash u} in a \grammarterm{universal-character-name}. Extended
    characters}{some codepoints, an implementation defined scheme may be used in
    forming valid external identifiers. This} may produce a long external identifier, but \Cpp{} does not
    place a translation limit on significant characters for external
    identifiers. In \Cpp{}, upper- and lower-case letters are considered
    different for all identifiers, including external identifiers. }

\pnum
\indextext{\idxcode{import}}%
\indextext{\idxcode{final}}%
\indextext{\idxcode{module}}%
\indextext{\idxcode{override}}%
The identifiers in \tref{lex.name.special} have a special meaning when
appearing in a certain context. When referred to in the grammar, these identifiers
are used explicitly rather than using the \grammarterm{identifier} grammar production.
Unless otherwise specified, any ambiguity as to whether a given
\grammarterm{identifier} has a special meaning is resolved to interpret the
token as a regular \grammarterm{identifier}.

\begin{multicolfloattable}{Identifiers with special meaning}{lex.name.special}
    {llll}
    \keyword{final}           \\
    \columnbreak
    \keyword{import}          \\
    \columnbreak
    \keyword{module}          \\
    \columnbreak
    \keyword{override}        \\
\end{multicolfloattable}

\pnum
\indextext{\idxcode{_}|see{character, underscore}}%
\indextext{character!underscore!in identifier}%
\indextext{reserved identifier}%
In addition, some identifiers are reserved for use by \Cpp{}
implementations and shall
not be used otherwise; no diagnostic is required.
\begin{itemize}
    \item
    Each identifier that contains a double underscore
    \tcode{\unun}
    \indextext{character!underscore}%
    or begins with an underscore followed by
    an uppercase letter
    \indextext{uppercase}%
    is reserved to the implementation for any use.
    \item
    Each identifier that begins with an underscore is
    \indextext{character!underscore}%
    reserved to the implementation for use as a name in the global namespace.%
    \indextext{namespace!global}
\end{itemize}%
\indextext{identifier|)}

\rSec1[lex.key]{Keywords}

\begin{bnf}
    \nontermdef{keyword}\br
    \textnormal{any identifier listed in \tref{lex.key}}\br
    \grammarterm{import-keyword}\br
    \grammarterm{module-keyword}\br
    \grammarterm{export-keyword}
\end{bnf}

\pnum
\indextext{keyword|(}%
The identifiers shown in \tref{lex.key} are reserved for use
as keywords (that is, they are unconditionally treated as keywords in
phase 7) except in an \grammarterm{attribute-token}\iref{dcl.attr.grammar}.
\begin{note}
    The \keyword{register} keyword is unused but
    is reserved for future use.
\end{note}

\begin{multicolfloattable}{Keywords}{lex.key}
    {lllll}
    \keyword{alignas} \\
    \keyword{alignof} \\
    \keyword{asm} \\
    \keyword{auto} \\
    \keyword{bool} \\
    \keyword{break} \\
    \keyword{case} \\
    \keyword{catch} \\
    \keyword{char} \\
    \keyword{char8_t} \\
    \keyword{char16_t} \\
    \keyword{char32_t} \\
    \keyword{class} \\
    \keyword{concept} \\
    \keyword{const} \\
    \keyword{consteval} \\
    \keyword{constexpr} \\
    \columnbreak
    \keyword{constinit} \\
    \keyword{const_cast} \\
    \keyword{continue} \\
    \keyword{co_await} \\
    \keyword{co_return} \\
    \keyword{co_yield} \\
    \keyword{decltype} \\
    \keyword{default} \\
    \keyword{delete} \\
    \keyword{do} \\
    \keyword{double} \\
    \keyword{dynamic_cast} \\
    \keyword{else} \\
    \keyword{enum} \\
    \keyword{explicit} \\
    \keyword{export} \\
    \keyword{extern} \\
    \columnbreak
    \keyword{false} \\
    \keyword{float} \\
    \keyword{for} \\
    \keyword{friend} \\
    \keyword{goto} \\
    \keyword{if} \\
    \keyword{inline} \\
    \keyword{int} \\
    \keyword{long} \\
    \keyword{mutable} \\
    \keyword{namespace} \\
    \keyword{new} \\
    \keyword{noexcept} \\
    \keyword{nullptr} \\
    \keyword{operator} \\
    \keyword{private} \\
    \keyword{protected} \\
    \columnbreak
    \keyword{public} \\
    \keyword{register} \\
    \keyword{reinterpret_cast} \\
    \keyword{requires} \\
    \keyword{return} \\
    \keyword{short} \\
    \keyword{signed} \\
    \keyword{sizeof} \\
    \keyword{static} \\
    \keyword{static_assert} \\
    \keyword{static_cast} \\
    \keyword{struct} \\
    \keyword{switch} \\
    \keyword{template} \\
    \keyword{this} \\
    \keyword{thread_local} \\
    \keyword{throw} \\
    \columnbreak
    \keyword{true} \\
    \keyword{try} \\
    \keyword{typedef} \\
    \keyword{typeid} \\
    \keyword{typename} \\
    \keyword{union} \\
    \keyword{unsigned} \\
    \keyword{using} \\
    \keyword{virtual} \\
    \keyword{void} \\
    \keyword{volatile} \\
    \keyword{wchar_t} \\
    \keyword{while} \\
\end{multicolfloattable}

\pnum
Furthermore, the alternative representations shown in
\tref{lex.key.digraph} for certain operators and
punctuators\iref{lex.digraph} are reserved and shall not be used
otherwise.

\begin{floattable}{Alternative representations}{lex.key.digraph}
    {llllll}
    \topline
    \keyword{and}     &   \keyword{and_eq}  &   \keyword{bitand}  &   \keyword{bitor}   &   \keyword{compl}   &   \keyword{not} \\
    \keyword{not_eq}  &   \keyword{or}      &   \keyword{or_eq}   &   \keyword{xor}     &   \keyword{xor_eq}  &       \\
\end{floattable}%
\indextext{keyword|)}%


\rSec1[lex.operators]{Operators and punctuators}

\pnum
\indextext{operator|(}%
\indextext{punctuator|(}%
The lexical representation of \Cpp{} programs includes a number of
preprocessing tokens that are used in the syntax of the preprocessor or
are converted into tokens for operators and punctuators:

\begin{bnf}
    \nontermdef{preprocessing-op-or-punc}\br
    preprocessing-operator\br
    operator-or-punctuator
\end{bnf}

\begin{bnf}
    %% Ed. note: character protrusion would misalign various operators.
    \microtypesetup{protrusion=false}\obeyspaces
    \nontermdef{preprocessing-operator} \textnormal{one of}\br
    \terminal{\#        \#\#       \%:       \%:\%:}
\end{bnf}

\begin{bnf}
    \microtypesetup{protrusion=false}\obeyspaces
    \nontermdef{operator-or-punctuator} \textnormal{one of}\br
    \terminal{\{        \}        [        ]        (        )}\br
    \terminal{<:       :>       <\%       \%>       ;        :        ...}\br
    \terminal{?        ::       .        .*       ->       ->*      \~}\br
    \terminal{!        +        -        *        /        \%        \caret{}        \&        |}\br
    \terminal{=        +=       -=       *=       /=       \%=       \caret{}=       \&=       |=}\br
    \terminal{==       !=       <        >        <=       >=       <=>      \&\&       ||}\br
    \terminal{<<       >>       <<=      >>=      ++       --       ,}\br
    \terminal{and      or       xor      not      bitand   bitor    compl}\br
    \terminal{and_eq   or_eq    xor_eq   not_eq}
\end{bnf}

Each \grammarterm{operator-or-punctuator} is converted to a single token
in translation phase 7\iref{lex.phases}.%
\indextext{punctuator|)}%
\indextext{operator|)}

\rSec1[lex.literal]{Literals}%
\indextext{literal|(}

\rSec2[lex.literal.kinds]{Kinds of literals}

\pnum
\indextext{constant}%
\indextext{literal!constant}%
There are several kinds of literals.\footnote{The term ``literal'' generally designates, in this
    document, those tokens that are called ``constants'' in
    ISO C. }

\begin{bnf}
    \nontermdef{literal}\br
    integer-literal\br
    character-literal\br
    floating-point-literal\br
    string-literal\br
    boolean-literal\br
    pointer-literal\br
    user-defined-literal
\end{bnf}

\rSec2[lex.icon]{Integer literals}

\indextext{literal!integer}%
\begin{bnf}
    \nontermdef{integer-literal}\br
    binary-literal \opt{integer-suffix}\br
    octal-literal \opt{integer-suffix}\br
    decimal-literal \opt{integer-suffix}\br
    hexadecimal-literal \opt{integer-suffix}
\end{bnf}

\begin{bnf}
    \nontermdef{binary-literal}\br
    \terminal{0b} binary-digit\br
    \terminal{0B} binary-digit\br
    binary-literal \opt{\terminal{'}} binary-digit
\end{bnf}

\begin{bnf}
    \nontermdef{octal-literal}\br
    \terminal{0}\br
    octal-literal \opt{\terminal{'}} octal-digit
\end{bnf}

\begin{bnf}
    \nontermdef{decimal-literal}\br
    nonzero-digit\br
    decimal-literal \opt{\terminal{'}} digit
\end{bnf}

\begin{bnf}
    \nontermdef{hexadecimal-literal}\br
    hexadecimal-prefix hexadecimal-digit-sequence
\end{bnf}

\begin{bnf}
    \nontermdef{binary-digit} \textnormal{one of}\br
    \terminal{0  1}
\end{bnf}

\begin{bnf}
    \nontermdef{octal-digit} \textnormal{one of}\br
    \terminal{0  1  2  3  4  5  6  7}
\end{bnf}

\begin{bnf}
    \nontermdef{nonzero-digit} \textnormal{one of}\br
    \terminal{1  2  3  4  5  6  7  8  9}
\end{bnf}

\begin{bnf}
    \nontermdef{hexadecimal-prefix} \textnormal{one of}\br
    \terminal{0x  0X}
\end{bnf}

\begin{bnf}
    \nontermdef{hexadecimal-digit-sequence}\br
    hexadecimal-digit\br
    hexadecimal-digit-sequence \opt{\terminal{'}} hexadecimal-digit
\end{bnf}

\begin{bnf}
    \nontermdef{hexadecimal-digit} \textnormal{one of}\br
    \terminal{0  1  2  3  4  5  6  7  8  9}\br
    \terminal{a  b  c  d  e  f}\br
    \terminal{A  B  C  D  E  F}
\end{bnf}

\begin{bnf}
    \nontermdef{integer-suffix}\br
    unsigned-suffix \opt{long-suffix} \br
    unsigned-suffix \opt{long-long-suffix} \br
    long-suffix \opt{unsigned-suffix} \br
    long-long-suffix \opt{unsigned-suffix}
\end{bnf}

\begin{bnf}
    \nontermdef{unsigned-suffix} \textnormal{one of}\br
    \terminal{u  U}
\end{bnf}

\begin{bnf}
    \nontermdef{long-suffix} \textnormal{one of}\br
    \terminal{l  L}
\end{bnf}

\begin{bnf}
    \nontermdef{long-long-suffix} \textnormal{one of}\br
    \terminal{ll  LL}
\end{bnf}

\pnum
\indextext{literal!\idxcode{unsigned}}%
\indextext{literal!\idxcode{long}}%
\indextext{literal!base of integer}%
In an \grammarterm{integer-literal},
the sequence of
\grammarterm{binary-digit}s,
\grammarterm{octal-digit}s,
\grammarterm{digit}s, or
\grammarterm{hexadecimal-digit}s
is interpreted as a base $N$ integer as shown in table \tref{lex.icon.base};
the lexically first digit of the sequence of digits is the most significant.
\begin{note}
    The prefix and any optional separating single quotes are ignored
    when determining the value.
\end{note}

\begin{simpletypetable}
    {Base of \grammarterm{integer-literal}{s}}
    {lex.icon.base}
    {lr}
    \topline
    \lhdr{Kind of \grammarterm{integer-literal}} & \rhdr{base $N$} \\ \capsep
    \grammarterm{binary-literal} & 2 \\
    \grammarterm{octal-literal} & 8 \\
    \grammarterm{decimal-literal} & 10 \\
    \grammarterm{hexadecimal-literal} & 16 \\
\end{simpletypetable}

\pnum
The \grammarterm{hexadecimal-digit}s
\tcode{a} through \tcode{f} and \tcode{A} through \tcode{F}
have decimal values ten through fifteen.
\begin{example}
    The number twelve can be written \tcode{12}, \tcode{014},
    \tcode{0XC}, or \tcode{0b1100}. The \grammarterm{integer-literal}s \tcode{1048576},
    \tcode{1'048'576}, \tcode{0X100000}, \tcode{0x10'0000}, and
    \tcode{0'004'000'000} all have the same value.
\end{example}

\pnum
\indextext{literal!\idxcode{long}}%
\indextext{literal!\idxcode{unsigned}}%
\indextext{literal!integer}%
\indextext{literal!type of integer}%
\indextext{suffix!\idxcode{L}}%
\indextext{suffix!\idxcode{U}}%
\indextext{suffix!\idxcode{l}}%
\indextext{suffix!\idxcode{u}}%
The type of an \grammarterm{integer-literal} is
the first type in the list in \tref{lex.icon.type}
corresponding to its optional \grammarterm{integer-suffix}
in which its value can be represented.
An \grammarterm{integer-literal} is a prvalue.

\begin{floattable}{Types of \grammarterm{integer-literal}s}{lex.icon.type}{l|l|l}
    \topline
    \lhdr{\grammarterm{integer-suffix}} & \chdr{\grammarterm{decimal-literal}}  & \rhdr{\grammarterm{integer-literal} other than \grammarterm{decimal-literal}}   \\  \capsep
    none    &
    \tcode{int} &
    \tcode{int}\\
    &
    \tcode{long int} &
    \tcode{unsigned int}\\
    &
    \tcode{long long int} &
    \tcode{long int}\\
    &
    &
    \tcode{unsigned long int}\\
    &
    &
    \tcode{long long int}\\
    &
    &
    \tcode{unsigned long long int}\\\hline
    \tcode{u} or \tcode{U}  &
    \tcode{unsigned int}  &
    \tcode{unsigned int}\\
    &
    \tcode{unsigned long int}   &
    \tcode{unsigned long int}\\
    &
    \tcode{unsigned long long int}   &
    \tcode{unsigned long long int}\\\hline
    \tcode{l} or \tcode{L}  &
    \tcode{long int}  &
    \tcode{long int}\\
    &
    \tcode{long long int}       &
    \tcode{unsigned long int}\\
    &
    &
    \tcode{long long int}\\
    &
    &
    \tcode{unsigned long long int}\\\hline
    Both \tcode{u} or \tcode{U}   &
    \tcode{unsigned long int}  &
    \tcode{unsigned long int}\\
    and \tcode{l} or \tcode{L}  &
    \tcode{unsigned long long int}  &
    \tcode{unsigned long long int}\\\hline
    \tcode{ll} or \tcode{LL}  &
    \tcode{long long int}       &
    \tcode{long long int}\\
    &
    &
    \tcode{unsigned long long int}\\\hline
    Both \tcode{u} or \tcode{U}   &
    \tcode{unsigned long long int}  &
    \tcode{unsigned long long int}\\
    and \tcode{ll} or \tcode{LL}  &
    &
    \\
\end{floattable}

\pnum
If an \grammarterm{integer-literal}
cannot be represented by any type in its list and
an extended integer type\iref{basic.fundamental} can represent its value,
it may have that extended integer type.
If all of the types in the list for the \grammarterm{integer-literal}
are signed,
the extended integer type shall be signed.
If all of the types in the list for the \grammarterm{integer-literal}
are unsigned,
the extended integer type shall be unsigned.
If the list contains both signed and unsigned types,
the extended integer type may be signed or unsigned.
A program is ill-formed
if one of its translation units contains an \grammarterm{integer-literal}
that cannot be represented by any of the allowed types.

\rSec2[lex.ccon]{Character literals}

\indextext{literal!character}%
\begin{bnf}
    \nontermdef{character-literal}\br
    \opt{encoding-prefix} \terminal{'} c-char-sequence \terminal{'}
\end{bnf}

\begin{bnf}
    \nontermdef{encoding-prefix} \textnormal{one of}\br
    \terminal{u8}\quad\terminal{u}\quad\terminal{U}\quad\terminal{L}
\end{bnf}

\begin{bnf}
    \nontermdef{c-char-sequence}\br
    c-char\br
    c-char-sequence c-char
\end{bnf}

\begin{bnf}
    \nontermdef{c-char}\br
    \textnormal{any \changed{member of the basic source character set}{codepoint} except the single-quote \terminal{'}, backslash \terminal{\textbackslash}, or new-line character}\br
    escape-sequence\br
    \removed{universal-character-name}
\end{bnf}

\begin{bnf}
    \nontermdef{escape-sequence}\br
    simple-escape-sequence\br
    \added{numeric-escape-sequence}\br
    \removed{octal-escape-sequence}\br
    \removed{hexadecimal-escape-sequence}
\end{bnf}

\begin{bnf}
    \nontermdef{simple-escape-sequence} \textnormal{one of}\br
    \terminal{\textbackslash'}\quad\terminal{\textbackslash"}\quad\terminal{\textbackslash ?}\quad\terminal{\textbackslash\textbackslash}\br
    \terminal{\textbackslash a}\quad\terminal{\textbackslash b}\quad\terminal{\textbackslash f}\quad\terminal{\textbackslash n}\quad\terminal{\textbackslash r}\quad\terminal{\textbackslash t}\quad\terminal{\textbackslash v}
\end{bnf}

\begin{addedblock}
\begin{bnf}
\nontermdef{numeric-escape-sequence}\br
    octal-escape-sequence\br
    hexadecimal-escape-sequence\br
\end{bnf}
\end{addedblock}

\begin{bnf}
    \nontermdef{octal-escape-sequence}\br
    \terminal{\textbackslash} octal-digit\br
    \terminal{\textbackslash} octal-digit octal-digit\br
    \terminal{\textbackslash} octal-digit octal-digit octal-digit
\end{bnf}

\begin{bnf}
    \nontermdef{hexadecimal-escape-sequence}\br
    \terminal{\textbackslash x} hexadecimal-digit\br
    hexadecimal-escape-sequence hexadecimal-digit
\end{bnf}

\pnum

\begin{addedblock}
Table X specifies the kinds of \grammarterm{character-literals} and their properties. The type of a character-literal is the associated code unit type.
Each \grammarterm{character-literal} kind has an associated encoding and an associated characters set. \begin{note}A single \grammarterm{character-literal} may not be able to encode all members of its associated characters set.\end{note}
\grammarterm{multicharacter literals} are distinguished from \grammarterm{ordinary character literals} by the presence of a \grammarterm{c-char-sequence} that contains more than one \grammarterm{c-char}; \grammarterm{multicharacter literals} are conditionally supported.

\begin{floattable}{Types of \grammarterm{character-literal}s}{lex.icon.type}{c|c|c|c|c}

\topline
Kind & \grammarterm{encoding-prefix}  & code unit type & character encoding & example  \\ \capsep
\grammarterm{ordinary character literal} & none & \tcode{char} & execution encoding & 'v' \\
\grammarterm{multicharacter literal} & none & \tcode{char} & implementation-defined & '123' \\
\grammarterm{wide character literal} & none & \tcode{wchar_t} & execution wide-encoding & L'w' \\
\grammarterm{UTF-8  character literal} & u8 & \tcode{char8_t} & UTF-8  & u8'v' \\
\grammarterm{UTF-16 character literal} & u & \tcode{char16_t} & UTF-16 & u'v' \\
\grammarterm{UTF-32 character literal} & U & \tcode{char32_t} & UTF-32 & U'v' \\

\end{floattable}

The value of a character literal is as follows.
\begin{itemize}
\item The value of a \grammarterm{multicharacter literal} is implementation defined.

\item The value of a  \grammarterm{character literal} consisting of a single  \grammarterm{basic-c-char} or  \grammarterm{character-escape-sequence} is the code unit value of the specified codepoint encoded with the character literal's associated character encoding.

\item The value of a character literal consisting of multiple basic-c-char is the code unit value of a single code point representing the same abstract character as the literal's \grammarterm{c-char-sequence}. 

\item The value of a character literal consisting of a single numeric-escape-sequence is the numeric value of the octal or hexadecimal number. There is no limit to the number of digits in a hexadecimal sequence. A sequence of octal or hexadecimal digits is terminated by the first character that is not an octal digit or a hexadecimal digit, respectively. If the numeric value exceeds the range of the character literal's associated code unit type, then, the character literal is ill-formed.
  
\end{itemize}

A character literal whose associated character set is the Unicode character set and consisting of multiple basic-c-char or character-escape-sequence is ill-formed.

If a \grammarterm{character literal} that is not a \grammarterm{multicharacter literal} cannot be represented in a single code unit of that \grammarterm{character literal}'s associated encoding, the program is ill-formed.


\end{addedblock}

\begin{removedblock}
\indextext{literal!character}%
\indextext{literal!\idxcode{char16_t}}%
\indextext{literal!\idxcode{char32_t}}%
\indextext{literal!type of character}%
\indextext{literal!character!ordinary}%
A \grammarterm{character-literal} that does not begin with
\tcode{u8}, \tcode{u}, \tcode{U}, or \tcode{L}
is an \defn{ordinary character literal}.
An ordinary character literal that contains a
single \grammarterm{c-char} representable in the execution character
set has type \tcode{char}, with value equal to the
numerical value of the encoding of the \grammarterm{c-char} in the
execution character set. An ordinary character literal that contains
more than one \grammarterm{c-char} is a
\indextext{multicharacter literal|see{literal, multicharacter}}%
\defnadj{multicharacter}{literal}.
A multicharacter literal, or an ordinary character literal containing
a single \grammarterm{c-char} not representable in the execution
character set, is conditionally-supported, has type \tcode{int},
\indextext{literal!multicharacter!implementation-defined value of}%
and has an \impldef{value of multicharacter literal} value.

\pnum
\indextext{literal!character!UTF-8}%
A \grammarterm{character-literal} that
begins with \tcode{u8}, such as \tcode{u8'w'},
\indextext{prefix!\idxcode{u8}}%
is a \grammarterm{character-literal} of type \tcode{char8_t},
known as a \defn{UTF-8 character literal}.
The value of a UTF-8 character literal
is equal to its ISO/IEC 10646 code point value,
provided that the code point value
can be encoded as a single UTF-8 code unit.
\begin{note}
    That is, provided the code point value is in the range $[0, \mathrm{7F}]$ (hexadecimal).
\end{note}
If the value is not representable with a single UTF-8 code unit,
the program is ill-formed.
A UTF-8 character literal containing multiple \grammarterm{c-char}{s} is ill-formed.

\pnum
\indextext{literal!character!UTF-16}%
\indextext{type!\idxcode{char16_t}}%
A \grammarterm{character-literal} that
begins with the letter \tcode{u}, such as \tcode{u'x'},
\indextext{prefix!\idxcode{u}}%
is a \grammarterm{character-literal} of type \tcode{char16_t},
known as a \defn{UTF-16 character literal}.
The value of a UTF-16 character literal
is equal to its ISO/IEC 10646 code point value,
provided that the code point value is
representable with a single 16-bit code unit.
\begin{note}
    That is, provided the code point value is in the range $[0, \mathrm{FFFF}]$ (hexadecimal).
\end{note}
If the value is not representable
with a single 16-bit code unit, the program is ill-formed.
A UTF-16 character literal
containing multiple \grammarterm{c-char}{s} is ill-formed.

\pnum
\indextext{literal!character!UTF-32}%
\indextext{type!\idxcode{char32_t}}%
A \grammarterm{character-literal} that
begins with the letter \tcode{U}, such as \tcode{U'y'},
\indextext{prefix!\idxcode{U}}%
is a \grammarterm{character-literal} of type \tcode{char32_t},
known as a \defn{UTF-32 character literal}.
The value of a
UTF-32 character literal containing a single \grammarterm{c-char} is equal
to its ISO/IEC 10646 code point value.
A UTF-32 character literal containing
multiple \grammarterm{c-char}{s} is ill-formed.

\pnum
\indextext{literal!character!wide}%
\indextext{wide-character}%
\indexhdr{stddef.h}%
\indextext{type!\idxcode{wchar_t}}%
A \grammarterm{character-literal} that
begins with the letter \tcode{L}, such as \tcode{L'z'},
\indextext{prefix!\idxcode{L}}%
is a \defn{wide-character literal}. A wide-character literal has type
\tcode{wchar_t}.\footnote{They are intended for character sets where a character does
    not fit into a single byte. }
The value of a wide-character literal containing a single
\grammarterm{c-char} has value equal to the numerical value of the encoding
of the \grammarterm{c-char} in the execution wide-character set, unless the
\grammarterm{c-char} has no representation in the execution wide-character set, in which
case the value is \impldef{value of wide-character literal with single c-char that is
    not in execution wide-character set}.
\begin{note}
    The type \tcode{wchar_t} is able to
    represent all members of the execution wide-character set (see~\ref{basic.fundamental}).
\end{note}
The value
of a wide-character literal containing multiple \grammarterm{c-char}{s} is
\impldef{value of wide-character literal containing multiple characters}.


\pnum
Certain non-graphic characters, the single quote \tcode{'}, the double quote \tcode{"},
the question mark \tcode{?},
and the backslash
\indextext{backslash character}%
\indextext{\idxcode{\textbackslash}|see{backslash character}}%
\indextext{escape character|see{backslash character}}%
\tcode{\textbackslash}, can be represented according to [lex.ccon.esc].
\indextext{escape sequence!undefined}%
The double quote \tcode{"}  and the question mark \tcode{?}, can be
represented as themselves or by the escape sequences
\tcode{\textbackslash "} and \tcode{\textbackslash ?} respectively, but
the single quote \tcode{'} and the backslash \tcode{\textbackslash}
shall be represented by the escape sequences \tcode{\textbackslash'} and
\tcode{\textbackslash\textbackslash} respectively. Escape sequences in
which the character following the backslash is not listed in
\tref{lex.ccon.esc} are conditionally-supported, with \impldef{semantics of
    non-standard escape sequences} semantics. An escape sequence specifies a single
character.

\end{removedblock}

\begin{addedblock}The character specified by a simple-escape-sequence is specified in table 8\footnote{Using an escape sequence for a question mark
        is supported for compatibility with ISO \CppXIV{} and ISO C.}.
\end{addedblock}

\begin{floattable}{\changed{E}{Simple e}scape sequences}{lex.ccon.esc}
    {lll}
    \topline
    \changed{new-line}{NEW LINE}        &   \changed{NL(LF)}{U+000A}          &   \tcode{\textbackslash n}                \\
    \changed{horizontal tab}{CHARACTER TABULATION}  &   \changed{HT}{U+0009}              &   \tcode{\textbackslash t}                \\
    \changed{vertical tab}{LINE TABULATION}    &    \changed{VT}{U+000B}              &   \tcode{\textbackslash v}                \\
    \changed{backspace}{BACKSPACE}         &    \changed{BS}{U+0008}              &   \tcode{\textbackslash b}                \\
    \changed{carriage return}{CARRIAGE RETURN}   &    \changed{CR}{U+000D}              &   \tcode{\textbackslash r}                \\
    \changed{form feed}{FORM FEED}        &    \changed{FF}{U+000C}              &   \tcode{\textbackslash f}                \\
    \changed{alert}{BELL}            &    \changed{BEL}{U+0007}             &   \tcode{\textbackslash a}                \\
    \changed{backslash}{REVERSE SOLIDUS}        &   \textbackslash  &   \tcode{\textbackslash\textbackslash}    \\
    \changed{question mark}{QUESTION MARK}    &   ?               &   \tcode{\textbackslash ?}                \\
    \changed{single quote}{APOSTROPHE}     &   \tcode{'}       &   \tcode{\textbackslash\tcode{'}}         \\
    \changed{double quote}{QUOTATION MARK}    &   \tcode{"}       &   \tcode{\textbackslash\tcode{"}}         \\
    \removed{octal number}    &  \removed{ \numconst{ooo}}  &   \removed{\tcode{\textbackslash\numconst{ooo}}}    \\
    \removed{hex number}      &   \removed{\numconst{hhh}}  &   \removed{\tcode{\textbackslash x\numconst{hhh}}}  \\

\end{floattable}

\begin{removedblock}
\pnum
The escape
\indextext{number!octal}%
\tcode{\textbackslash\numconst{ooo}} consists of the backslash followed by one,
two, or three octal digits that are taken to specify the value of the
desired character. The escape
\indextext{number!hex}%
\tcode{\textbackslash x\numconst{hhh}}
consists of the backslash followed by \tcode{x} followed by one or more
hexadecimal digits that are taken to specify the value of the desired
character. There is no limit to the number of digits in a hexadecimal
sequence. A sequence of octal or hexadecimal digits is terminated by the
first character that is not an octal digit or a hexadecimal digit,
respectively.
\indextext{literal!implementation-defined value of char@implementation-defined value of \tcode{char}}%
The value of a \grammarterm{character-literal} is \impldef{value of \grammarterm{character-literal} outside range of
    corresponding type} if it falls outside of the \impldef{range defined for \grammarterm{character-literal}s}
range defined for \tcode{char} (for \grammarterm{character-literal}s with no prefix) or
\tcode{wchar_t} (for \grammarterm{character-literal}s prefixed by \tcode{L}).
\begin{note}
    If the value of a \grammarterm{character-literal} prefixed by
    \tcode{u}, \tcode{u8}, or \tcode{U}
    is outside the range defined for its type,
    the program is ill-formed.
\end{note}

\pnum
A \grammarterm{universal-character-name} is translated to the encoding, in the appropriate
execution character set, of the character named. If there is no such
encoding, the \grammarterm{universal-character-name} is translated to an
\impldef{encoding of universal character name not in execution character set} encoding.
\begin{note}
    In translation phase 1, a \grammarterm{universal-character-name} is introduced whenever an
    actual extended
    character is encountered in the source text. Therefore, all extended
    characters are described in terms of \grammarterm{universal-character-name}{s}. However,
    the actual compiler implementation may use its own native character set,
    so long as the same results are obtained.
\end{note}
\end{removedblock}

\rSec2[lex.fcon]{Floating-point literals}

\indextext{literal!floating-point}%
\begin{bnf}
    \nontermdef{floating-point-literal}\br
    decimal-floating-point-literal\br
    hexadecimal-floating-point-literal
\end{bnf}

\begin{bnf}
    \nontermdef{decimal-floating-point-literal}\br
    fractional-constant \opt{exponent-part} \opt{floating-point-suffix}\br
    digit-sequence exponent-part \opt{floating-point-suffix}
\end{bnf}

\begin{bnf}
    \nontermdef{hexadecimal-floating-point-literal}\br
    hexadecimal-prefix hexadecimal-fractional-constant binary-exponent-part \opt{floating-point-suffix}\br
    hexadecimal-prefix hexadecimal-digit-sequence binary-exponent-part \opt{floating-point-suffix}
\end{bnf}

\begin{bnf}
    \nontermdef{fractional-constant}\br
    \opt{digit-sequence} \terminal{.} digit-sequence\br
    digit-sequence \terminal{.}
\end{bnf}

\begin{bnf}
    \nontermdef{hexadecimal-fractional-constant}\br
    \opt{hexadecimal-digit-sequence} \terminal{.} hexadecimal-digit-sequence\br
    hexadecimal-digit-sequence \terminal{.}
\end{bnf}

\begin{bnf}
    \nontermdef{exponent-part}\br
    \terminal{e} \opt{sign} digit-sequence\br
    \terminal{E} \opt{sign} digit-sequence
\end{bnf}

\begin{bnf}
    \nontermdef{binary-exponent-part}\br
    \terminal{p} \opt{sign} digit-sequence\br
    \terminal{P} \opt{sign} digit-sequence
\end{bnf}

\begin{bnf}
    \nontermdef{sign} \textnormal{one of}\br
    \terminal{+  -}
\end{bnf}

\begin{bnf}
    \nontermdef{digit-sequence}\br
    digit\br
    digit-sequence \opt{\terminal{'}} digit
\end{bnf}

\begin{bnf}
    \nontermdef{floating-point-suffix} \textnormal{one of}\br
    \terminal{f  l  F  L}
\end{bnf}

\pnum
\indextext{literal!type of floating-point}%
\indextext{literal!\idxcode{float}}%
\indextext{suffix!\idxcode{F}}%
\indextext{suffix!\idxcode{f}}%
\indextext{suffix!\idxcode{L}}%
\indextext{suffix!\idxcode{l}}%
\indextext{literal!\idxcode{long double}}%
The type of a \grammarterm{floating-point-literal} is determined by
its \grammarterm{floating-point-suffix} as specified in \tref{lex.fcon.type}.
\begin{simpletypetable}
    {Types of \grammarterm{floating-point-literal}{s}}
    {lex.fcon.type}
    {ll}
    \topline
    \lhdr{\grammarterm{floating-point-suffix}} & \rhdr{type} \\ \capsep
    none & \keyword{double} \\
    \tcode{f} or \tcode{F} & \keyword {float} \\
    \tcode{l} or \tcode{L} & \keyword{long} \keyword{double} \\
\end{simpletypetable}

\pnum
\indextext{literal!floating-point}%
The \defn{significand} of a \grammarterm{floating-point-literal}
is the \grammarterm{fractional-constant} or \grammarterm{digit-sequence}
of a \grammarterm{decimal-floating-point-literal}
or the \grammarterm{hexadecimal-fractional-constant}
or \grammarterm{hexadecimal-digit-sequence}
of a \grammarterm{hexadecimal-floating-point-literal}.
In the significand,
the sequence of \grammarterm{digit}s or \grammarterm{hexadecimal-digit}s
and optional period are interpreted as a base $N$ real number $s$,
where $N$ is 10 for a \grammarterm{decimal-floating-point-literal} and
16 for a \grammarterm{hexadecimal-floating-point-literal}.
\begin{note}
    Any optional separating single quotes are ignored when determining the value.
\end{note}
If an \grammarterm{exponent-part} or \grammarterm{binary-exponent-part}
is present,
the exponent $e$ of the \grammarterm{floating-point-literal}
is the result of interpreting
the sequence of an optional \grammarterm{sign} and the \grammarterm{digit}s
as a base 10 integer.
Otherwise, the exponent $e$ is 0.
The scaled value of the literal is
$s \times 10^e$ for a \grammarterm{decimal-floating-point-literal} and
$s \times 2^e$ for a \grammarterm{hexadecimal-floating-point-literal}.
\begin{example}
    The \grammarterm{floating-point-literal}{s}
    \tcode{49.625} and \tcode{0xC.68p+2} have the same value.
    The \grammarterm{floating-point-literal}{s}
    \tcode{1.602'176'565e-19} and \tcode{1.602176565e-19}
    have the same value.
\end{example}

\pnum
If the scaled value is not in the range of representable
values for its type, the program is ill-formed.
Otherwise, the value of a \grammarterm{floating-point-literal}
is the scaled value if representable,
else the larger or smaller representable value nearest the scaled value,
chosen in an \impldef{choice of larger or smaller value of
    \grammarterm{floating-point-literal}} manner.

\rSec2[lex.string]{String literals}

\indextext{literal!string}%
\begin{bnf}
    \nontermdef{string-literal}\br
    \opt{encoding-prefix} \terminal{"} \opt{s-char-sequence} \terminal{"}\br
    \opt{encoding-prefix} \terminal{R} raw-string
\end{bnf}

\begin{bnf}
    \nontermdef{s-char-sequence}\br
    s-char\br
    s-char-sequence s-char
\end{bnf}

\begin{bnf}
    \nontermdef{s-char}\br
    \textnormal{any \changed{member of the basic source character set}{codepoint} except the double-quote \terminal{"}, backslash \terminal{\textbackslash}, or new-line character}\br
    escape-sequence\br
    universal-character-name
\end{bnf}

\begin{bnf}
    \nontermdef{raw-string}\br
    \terminal{"} \opt{d-char-sequence} \terminal{(} \opt{r-char-sequence} \terminal{)} \opt{d-char-sequence} \terminal{"}
\end{bnf}

\begin{bnf}
    \nontermdef{r-char-sequence}\br
    r-char\br
    r-char-sequence r-char
\end{bnf}

\begin{bnf}
    \nontermdef{r-char}\br
    \textnormal{any \changed{member of the basic source character set}{codepoint}, except a right parenthesis \terminal{)} followed by}\br
    \bnfindent\textnormal{the initial \grammarterm{d-char-sequence} (which may be empty) followed by a double quote \terminal{"}.}
\end{bnf}

\begin{bnf}
    \nontermdef{d-char-sequence}\br
    d-char\br
    d-char-sequence d-char
\end{bnf}

\begin{bnf}
    \nontermdef{d-char}\br
    \textnormal{any \changed{member of the basic source character set}{codepoint} except:}\br

    \textnormal{space, the left parenthesis \terminal{(}, the right parenthesis \terminal{)}, the backslash \terminal{\textbackslash}, and the control characters}\br
    \bnfindent\textnormal{representing horizontal tab, vertical tab, form feed, and newline.}
\end{bnf}

\pnum
\indextext{literal!string!raw}%
A \grammarterm{string-literal} that has an \tcode{R}
\indextext{prefix!\idxcode{R}}%
in the prefix is a \defn{raw string literal}. The
\grammarterm{d-char-sequence} serves as a delimiter. The terminating
\grammarterm{d-char-sequence} of a \grammarterm{raw-string} is the same sequence of
characters as the initial \grammarterm{d-char-sequence}. A \grammarterm{d-char-sequence}
shall consist of at most 16 characters.

\pnum
\begin{note}
    The characters \tcode{'('} and \tcode{')'} are permitted in a
    \grammarterm{raw-string}. Thus, \tcode{R"delimiter((a|b))delimiter"} is equivalent to
    \tcode{"(a|b)"}.
\end{note}

\pnum
\begin{note}
    A source-file new-line in a raw string literal results in a new-line in the
    resulting execution string literal. Assuming no
    whitespace at the beginning of lines in the following example, the assert will succeed:
    \begin{codeblock}
        const char* p = R"(a\
        b
        c)";
        assert(std::strcmp(p, "a\\\nb\nc") == 0);
    \end{codeblock}
\end{note}

\pnum
\begin{example}
    The raw string
    \begin{codeblock}
        R"a(
        )\
        a"
        )a"
    \end{codeblock}
    is equivalent to \tcode{"\textbackslash n)\textbackslash \textbackslash \textbackslash na\textbackslash"\textbackslash n"}. The raw string
    \begin{codeblock}
        R"(x = "\"y\"")"
    \end{codeblock}
    is equivalent to \tcode{"x = \textbackslash "\textbackslash\textbackslash\textbackslash "y\textbackslash\textbackslash\textbackslash "\textbackslash ""}.
\end{example}


\begin{addedblock}
Table X specifies the kinds of \grammarterm{string-literal}s and their properties.

\begin{floattable}{Types of \grammarterm{character-literal}s}{lex.icon.type}{c|c|c|c|c}
    \topline
    Kind & \grammarterm{encoding-prefix}  & code type & character encoding & examples  \\ \capsep
    \grammarterm{ordinary string literal} & none & \tcode{char} & execution encoding & 'v' \\
    \grammarterm{wide string literal} & none & \tcode{wchar_t} & execution wide-encoding & L'w' \\
    \grammarterm{UTF-8  string literal} & u8 & \tcode{char8_t} & UTF-8  & u8'v' \\
    \grammarterm{UTF-16 string literal} & u & \tcode{char16_t} & UTF-16 & u'v' \\
    \grammarterm{UTF-32 string literal} & U & \tcode{char32_t} & UTF-32 & U'v' \\
    
\end{floattable}
\end{addedblock}
\begin{removedblock}
\pnum
\indextext{literal!string}%
\indextext{character string}%
\indextext{string!type of}%
\indextext{literal!string!narrow}%
After translation phase 6, a \grammarterm{string-literal}
that does not begin with an \grammarterm{encoding-prefix} is an
\defn{ordinary string literal}.
An ordinary string literal
has type ``array of \placeholder{n} \tcode{const char}''
where \placeholder{n} is the size of the string as defined below,
has static storage duration\iref{basic.stc}, and
is initialized with the given characters.

\pnum
\indextext{literal!string!UTF-8}%
A \grammarterm{string-literal} that begins with \tcode{u8},
\indextext{prefix!\idxcode{u8}}%
such as \tcode{u8"asdf"}, is a \defn{UTF-8 string literal}.
A UTF-8 string literal
has type ``array of \placeholder{n} \tcode{const char8_t}'',
where \placeholder{n} is the size of the string as defined below;
each successive element of the object representation\iref{basic.types} has
the value of the corresponding code unit of the UTF-8 encoding of the string.

\end{removedblock}

\pnum
\indextext{literal!narrow-character}%
Ordinary string literals and UTF-8 string literals are
also referred to as narrow string literals.

\begin{addedblock}
String literal objects are initialized with the sequence of code unit values corresponding to the string-literal's as follows:
\begin{itemize}
\item If the string literal associated character set is the Unicode character set, each basic-s-char, r-char, character-escape-sequence are encoded to a code unit sequence using the string-literal's associated character encoding.
\item Otherwise, codepoint in the \grammarterm{s-char-sequence} is mapped to a sequence of code units representing the same abstract character in the string literal's associated encoding. If an abstract character lacks representation in the associated character set the program is ill formed.  

\item Each numeric-escape-sequence ([lex.ccon]) contributes a single code unit value with the numeric value of the octal or hexadecimal number. There is no limit to the number of digits in a hexadecimal sequence. A sequence of octal or hexadecimal digits is terminated by the first character that is not an octal digit or a hexadecimal digit, respectively. If the numeric value exceeds the range of the string-literal's code unit type, then the string-literal is ill-formed.
\end{itemize}

\end{addedblock}

\begin{removedblock}
\pnum
\indextext{literal!string!UTF-16}%
\indextext{literal!string!\idxcode{char16_t}}%
\indextext{type!\idxcode{char16_t}}%
A \grammarterm{string-literal} that begins with \tcode{u},
\indextext{prefix!\idxcode{u}}%
such as \tcode{u"asdf"}, is
a \defn{UTF-16 string literal}.
A UTF-16 string literal has
type ``array of \placeholder{n} \tcode{const char16_t}'', where \placeholder{n} is the
size of the string as defined below;
each successive element of the array
has the value of the corresponding code unit of
the UTF-16 encoding of the string.
\begin{note}
    A single \grammarterm{c-char} may
    produce more than one \tcode{char16_t} character in the form of
    surrogate pairs.
    A surrogate pair is a representation for a single code point
    as a sequence of two 16-bit code units.
\end{note}

\pnum
\indextext{literal!string!UTF-32}%
\indextext{literal!string!\idxcode{char32_t}}%
\indextext{type!\idxcode{char32_t}}%
A \grammarterm{string-literal} that begins with \tcode{U},
\indextext{prefix!\idxcode{U}}%
such as \tcode{U"asdf"}, is
a \defn{UTF-32 string literal}.
A UTF-32 string literal has
type ``array of \placeholder{n} \tcode{const char32_t}'', where \placeholder{n} is the
size of the string as defined below;
each successive element of the array
has the value of the corresponding code unit of
the UTF-32 encoding of the string.

\pnum
\indextext{literal!string!wide}%
A \grammarterm{string-literal} that begins with \tcode{L},
\indextext{prefix!\idxcode{L}}%
such as \tcode{L"asdf"}, is a \defn{wide string literal}.
\indexhdr{stddef.h}%
\indextext{type!\idxcode{wchar_t}}%
\indextext{literal!string!wide}%
\indextext{prefix!\idxcode{L}}%
A wide string literal has type ``array of \placeholder{n} \tcode{const
    wchar_t}'', where \placeholder{n} is the size of the string as defined below; it
is initialized with the given characters.

\end{removedblock}

\pnum
\indextext{concatenation!string}%
In translation phase 6\iref{lex.phases}, adjacent \grammarterm{string-literal}{s} are concatenated. If
both \grammarterm{string-literal}{s} have the same \grammarterm{encoding-prefix}, the resulting concatenated \grammarterm{string-literal} has
that \grammarterm{encoding-prefix}. If one \grammarterm{string-literal} has no \grammarterm{encoding-prefix}, it is treated as a \grammarterm{string-literal} of
the same \grammarterm{encoding-prefix} as the other operand. If a UTF-8 string literal token is adjacent to a
wide string literal token, the program is ill-formed. Any other concatenations are
conditionally-supported with \impldef{concatenation of some types of \grammarterm{string-literal}s}
behavior.
\begin{note}
    This
    concatenation is an interpretation, not a conversion.
    Because the interpretation happens in translation phase 6 (\changed{after each character from a
    \grammarterm{string-literal} has been translated into a value from the appropriate character set}{after the string literal contents have been encoded in the string-literal's associated character encoding}), a
    \grammarterm{string-literal}'s initial rawness has no effect on the interpretation or
    well-formedness of the concatenation.
\end{note}
\tref{lex.string.concat} has some examples of valid concatenations.

\begin{floattable}{String literal concatenations}{lex.string.concat}
    {lll|lll|lll}
    \topline
    \multicolumn{2}{|c}{Source} &
    Means &
    \multicolumn{2}{c}{Source} &
    Means &
    \multicolumn{2}{c}{Source} &
    Means \\
    \tcode{u"a"} & \tcode{u"b"} & \tcode{u"ab"} &
    \tcode{U"a"} & \tcode{U"b"} & \tcode{U"ab"} &
    \tcode{L"a"} & \tcode{L"b"} & \tcode{L"ab"} \\
    \tcode{u"a"} & \tcode{"b"}  & \tcode{u"ab"} &
    \tcode{U"a"} & \tcode{"b"}  & \tcode{U"ab"} &
    \tcode{L"a"} & \tcode{"b"}  & \tcode{L"ab"} \\
    \tcode{"a"}  & \tcode{u"b"} & \tcode{u"ab"} &
    \tcode{"a"}  & \tcode{U"b"} & \tcode{U"ab"} &
    \tcode{"a"}  & \tcode{L"b"} & \tcode{L"ab"} \\
\end{floattable}

Characters in concatenated strings are kept distinct.

\begin{example}
    \begin{codeblock}
        "\xA" "B"
    \end{codeblock}
    contains the two characters \tcode{'\textbackslash xA'} and \tcode{'B'}
    after concatenation (and not the single hexadecimal character
    \tcode{'\textbackslash xAB'}).
\end{example}

\pnum
\indextext{\idxcode{0}|seealso{zero, null}}%
\indextext{\idxcode{0}!string terminator}%
\indextext{\idxcode{0}!null character|see {character, null}}%
After any necessary concatenation, in translation phase
7\iref{lex.phases}, \changed{\tcode{'\textbackslash 0'}}{a null code unit} is appended to every
\grammarterm{string-literal} so that programs that scan a string can find its end.

\begin{removedblock}
\pnum
Escape sequences and \grammarterm{universal-character-name}{s} in non-raw string literals
have the same meaning as in \grammarterm{character-literal}s\iref{lex.ccon}, except that
the single quote \tcode{'} is representable either by itself or by the escape sequence
\tcode{\textbackslash'}, and the double quote \tcode{"} shall be preceded by a
\tcode{\textbackslash},
and except that a \grammarterm{universal-character-name} in a
UTF-16 string literal may yield a surrogate pair.
\indextext{string!\idxcode{sizeof}}%
In a narrow string literal, a \grammarterm{universal-character-name} may map to more
than one \tcode{char} or \tcode{char8_t} element due to \defnadj{multibyte}{encoding}. The
size of a \tcode{char32_t} or wide string literal is the total number of
escape sequences, \grammarterm{universal-character-name}{s}, and other characters, plus
one for the terminating \tcode{U'\textbackslash 0'} or
\tcode{L'\textbackslash 0'}. The size of a UTF-16 string
literal is the total number of escape sequences,
\grammarterm{universal-character-name}{s}, and other characters, plus one for each
character requiring a surrogate pair, plus one for the terminating
\tcode{u'\textbackslash 0'}.
\begin{note}
    The size of a \tcode{char16_t}
    string literal is the number of code units, not the number of
    characters.
\end{note}
\begin{note}
    Any \grammarterm{universal-character-name}{s} are required to
    correspond to a code point in the range
    $[0, \mathrm{D800})$ or $[\mathrm{E000}, \mathrm{10FFFF}]$ (hexadecimal)\iref{lex.charset}.
\end{note}
The size of a narrow string literal is
the total number of escape sequences and other characters, plus at least
one for the multibyte encoding of each \grammarterm{universal-character-name}, plus
one for the terminating \tcode{'\textbackslash 0'}.
\end{removedblock}

\begin{addedblock}
The size of a string-literal is the number of code unit in the string literal including the null character appened in phase 7.
\end{addedblock}

\pnum
Evaluating a \grammarterm{string-literal} results in a string literal object
with static storage duration\removed{, initialized from the given characters as
specified above}.
\indextext{string!distinct}%
Whether all \grammarterm{string-literal}s are distinct (that is, are stored in
nonoverlapping objects) and whether successive evaluations of a
\grammarterm{string-literal} yield the same or a different object is
unspecified.
\begin{note}
    \indextext{literal!string!undefined change to}%
    The effect of attempting to modify a \grammarterm{string-literal} is undefined.
\end{note}

\rSec2[lex.bool]{Boolean literals}

\indextext{literal!boolean}%
\begin{bnf}
    \nontermdef{boolean-literal}\br
    \terminal{false}\br
    \terminal{true}
\end{bnf}

\pnum
\indextext{Boolean literal}%
The Boolean literals are the keywords \tcode{false} and \tcode{true}.
Such literals are prvalues and have type \tcode{bool}.

\rSec2[lex.nullptr]{Pointer literals}

\indextext{literal!pointer}%
\begin{bnf}
    \nontermdef{pointer-literal}\br
    \terminal{nullptr}
\end{bnf}

\pnum
The pointer literal is the keyword \tcode{nullptr}. It is a prvalue of type
\tcode{std::nullptr_t}.
\begin{note}
    \tcode{std::nullptr_t} is a distinct type that is neither a pointer type nor a pointer-to-member type;
    rather, a prvalue of this type is a null pointer constant and can be
    converted to a null pointer value or null member pointer value. See~\ref{conv.ptr}
    and~\ref{conv.mem}.
\end{note}

\rSec2[lex.ext]{User-defined literals}

\indextext{literal!user-defined}%
\begin{bnf}
    \nontermdef{user-defined-literal}\br
    user-defined-integer-literal\br
    user-defined-floating-point-literal\br
    user-defined-string-literal\br
    user-defined-character-literal
\end{bnf}

\begin{bnf}
    \nontermdef{user-defined-integer-literal}\br
    decimal-literal ud-suffix\br
    octal-literal ud-suffix\br
    hexadecimal-literal ud-suffix\br
    binary-literal ud-suffix
\end{bnf}

\begin{bnf}
    \nontermdef{user-defined-floating-point-literal}\br
    fractional-constant \opt{exponent-part} ud-suffix\br
    digit-sequence exponent-part ud-suffix\br
    hexadecimal-prefix hexadecimal-fractional-constant binary-exponent-part ud-suffix\br
    hexadecimal-prefix hexadecimal-digit-sequence binary-exponent-part ud-suffix
\end{bnf}

\begin{bnf}
    \nontermdef{user-defined-string-literal}\br
    string-literal ud-suffix
\end{bnf}

\begin{bnf}
    \nontermdef{user-defined-character-literal}\br
    character-literal ud-suffix
\end{bnf}

\begin{bnf}
    \nontermdef{ud-suffix}\br
    identifier
\end{bnf}

\pnum
If a token matches both \grammarterm{user-defined-literal} and another \grammarterm{literal} kind, it
is treated as the latter.
\begin{example}
    \tcode{123_km}
    is a \grammarterm{user-defined-literal}, but \tcode{12LL} is an
    \grammarterm{integer-literal}.
\end{example}
The syntactic non-terminal preceding the \grammarterm{ud-suffix} in a
\grammarterm{user-defined-literal} is taken to be the longest sequence of
characters that could match that non-terminal.

\pnum
A \grammarterm{user-defined-literal} is treated as a call to a literal operator or
literal operator template\iref{over.literal}. To determine the form of this call for a
given \grammarterm{user-defined-literal} \placeholder{L} with \grammarterm{ud-suffix} \placeholder{X},
the \grammarterm{literal-operator-id} whose literal suffix identifier is \placeholder{X} is
looked up in the context of \placeholder{L} using the rules for unqualified name
lookup\iref{basic.lookup.unqual}. Let \placeholder{S} be the set of declarations found by
this lookup. \placeholder{S} shall not be empty.

\pnum
If \placeholder{L} is a \grammarterm{user-defined-integer-literal}, let \placeholder{n} be the literal
without its \grammarterm{ud-suffix}. If \placeholder{S} contains a literal operator with
parameter type \tcode{unsigned long long}, the literal \placeholder{L} is treated as a call of
the form
\begin{codeblock}
    operator "" @\placeholder{X}@(@\placeholder{n}@ULL)
\end{codeblock}
Otherwise, \placeholder{S} shall contain a raw literal operator
or a numeric literal operator template\iref{over.literal} but not both.
If \placeholder{S} contains a raw literal operator,
the literal \placeholder{L} is treated as a call of the form
\begin{codeblock}
    operator "" @\placeholder{X}@(@"\placeholder{n}{"}@)
\end{codeblock}
Otherwise (\placeholder{S} contains a numeric literal operator template),
\placeholder{L} is treated as a call of the form
\begin{codeblock}
    operator "" @\placeholder{X}@<'@$c_1$@', '@$c_2$@', ... '@$c_k$@'>()
\end{codeblock}
where \placeholder{n} is the source character sequence $c_1c_2...c_k$.
\begin{note}
    The sequence
    $c_1c_2...c_k$ can only contain characters from the basic source character set.
\end{note}

\pnum
If \placeholder{L} is a \grammarterm{user-defined-floating-point-literal}, let \placeholder{f} be the
literal without its \grammarterm{ud-suffix}. If \placeholder{S} contains a literal operator
with parameter type \tcode{long double}, the literal \placeholder{L} is treated as a call of
the form
\begin{codeblock}
    operator "" @\placeholder{X}@(@\placeholder{f}@L)
\end{codeblock}
Otherwise, \placeholder{S} shall contain a raw literal operator
or a numeric literal operator template\iref{over.literal} but not both.
If \placeholder{S} contains a raw literal operator,
the \grammarterm{literal} \placeholder{L} is treated as a call of the form
\begin{codeblock}
    operator "" @\placeholder{X}@(@"\placeholder{f}{"}@)
\end{codeblock}
Otherwise (\placeholder{S} contains a numeric literal operator template),
\placeholder{L} is treated as a call of the form
\begin{codeblock}
    operator "" @\placeholder{X}@<'@$c_1$@', '@$c_2$@', ... '@$c_k$@'>()
\end{codeblock}
where \placeholder{f} is the source character sequence $c_1c_2...c_k$.
\begin{note}
    The sequence
    $c_1c_2...c_k$ can only contain characters from the basic source character set.
\end{note}

\pnum
If \placeholder{L} is a \grammarterm{user-defined-string-literal},
let \placeholder{str} be the literal without its \grammarterm{ud-suffix}
and let \placeholder{len} be the number of code units in \placeholder{str}
(i.e., its length excluding the terminating null character).
If \placeholder{S} contains a literal operator template with
a non-type template parameter for which \placeholder{str} is
a well-formed \grammarterm{template-argument},
the literal \placeholder{L} is treated as a call of the form
\begin{codeblock}
    operator "" @\placeholder{X}@<@\placeholder{str}{}@>()
\end{codeblock}
Otherwise, the literal \placeholder{L} is treated as a call of the form
\begin{codeblock}
    operator "" @\placeholder{X}@(@\placeholder{str}{}@, @\placeholder{len}{}@)
\end{codeblock}

\pnum
If \placeholder{L} is a \grammarterm{user-defined-character-literal}, let \placeholder{ch} be the
literal without its \grammarterm{ud-suffix}.
\placeholder{S} shall contain a literal operator\iref{over.literal} whose only parameter has
the type of \placeholder{ch} and the
literal \placeholder{L} is treated as a call
of the form
\begin{codeblock}
    operator "" @\placeholder{X}@(@\placeholder{ch}{}@)
\end{codeblock}

\pnum
\begin{example}
    \begin{codeblock}
        long double operator "" _w(long double);
        std::string operator "" _w(const char16_t*, std::size_t);
        unsigned operator "" _w(const char*);
        int main() {
            1.2_w;            // calls \tcode{operator "" _w(1.2L)}
            u"one"_w;         // calls \tcode{operator "" _w(u"one", 3)}
            12_w;             // calls \tcode{operator "" _w("12")}
            "two"_w;          // error: no applicable literal operator
        }
    \end{codeblock}
\end{example}

\pnum
In translation phase 6\iref{lex.phases}, adjacent \grammarterm{string-literal}s are concatenated and
\grammarterm{user-defined-string-literal}{s} are considered \grammarterm{string-literal}s for that
purpose. During concatenation, \grammarterm{ud-suffix}{es} are removed and ignored and
the concatenation process occurs as described in~\ref{lex.string}. At the end of phase
6, if a \grammarterm{string-literal} is the result of a concatenation involving at least one
\grammarterm{user-defined-string-literal}, all the participating
\grammarterm{user-defined-string-literal}{s} shall have the same \grammarterm{ud-suffix}
and that suffix is applied to the result of the concatenation.

\pnum
\begin{example}
    \begin{codeblock}
        int main() {
            L"A" "B" "C"_x;   // OK: same as \tcode{L"ABC"_x}
            "P"_x "Q" "R"_y;  // error: two different \grammarterm{ud-suffix}{es}
        }
    \end{codeblock}
\end{example}
\indextext{literal|)}%
\indextext{conventions!lexical|)}



\section{References}
\renewcommand{\section}[2]{}%
\bibliographystyle{plain}
\bibliography{wg21}

\begin{thebibliography}{9}

    \bibitem[N4861]{N4861}
    Richard Smith
    \emph{Working Draft, Standard for Programming Language C++}\newline
    \url{https://wg21.link/N4861}

\end{thebibliography}
\end{document}
