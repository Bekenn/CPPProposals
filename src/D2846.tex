% !TeX program = luatex
% !TEX encoding = UTF-8


\documentclass{wg21}

\title{\tcode{size\_hint}: Eagerly reserving memory for not-quite-sized lazy ranges}
\docnumber{P2846R0}
\audience{SG-9, LEWG}
\author{Corentin Jabot}{corentin.jabot@gmail.com}

\begin{document}
\maketitle

\section{Abstract}

This proposals adds a \tcode{ranges::size_hint} customization point object which allows \tcode{ranges::to} to
reserve memory for non-sized ranges whose size can be approximated.

\section{Revisions}

\section{Motivation}

You should know this proposal is secretly about Unicode.

Consider the string

\tcode{"In C++ ist es schwieriger, sich selbst in den fuß zu schießen."}

Its correct upper-case transformation is

\tcode{"IN C++ IST ES SCHWIERIGER, SICH SELBST IN DEN FUSS ZU SCHIESSEN".}

You will have observed that the transformed string is longer.
2 codepoints longer to be exact. This is because \textbf{ß} capitalizes as \textbf{SS}.

Now consider a hypothetical uppercase_view that transforms Unicode codepoints into their uppercase version.
It might look like this:

\begin{colorblock}
U"In C++ ist es schwieriger, sich selbst in den fuß zu schießen."sv
    | views::uppercase
    | ranges::to<std::u32string>();
\end{colorblock}

We do not have to know anything else about \tcode{views::uppercase} to know that it cannot be a \tcode{sized_range}.

In fact, it cannot be, for the same reason, a \tcode{random_access_range}.  It will be, at best, a \tcode{bidirectional_range}.
This means that in the above example, we cannot reserve memory in advance when constructing the output vector in \tcode{ranges::to}.
So the implementation will be notionally calling \tcode{push_back} and the vector will reallocate itself according to its growth factor
which can have a measurable impact on performance.

But... only a couple thousand codepoints have a casing that is not their identity and of those only a few hundred might produce more than
one codepoint. That's about 1\% of the total number of allocated codepoints.

Most scripts not derived from Latin (for example CJK characters) do not even have a notion of case.

So the above example is massively pessimized because of a statistically unlikely scenario.

This is not just a problem with upper-casing. All casing transformations in Unicode have the same peculiarity.
It also applies to all forms of Unicode Normalization (normalization can produce output strings that are longer, or shorter than the input)
and text encoding and decoding, especially between UTF-forms.

It is not possible to compute the size of the conversion from a string of length \tcode{L} from UTF-32 to UTF-8, but we know it will be at least \tcode{L}.
And for some scripts, including English, it will be equal or very close to \tcode{L}.


So we need a way to advertise "This range is about yea big", so that \tcode{ranges::to} and all the ranges constructors added by \paper{P1206R7}
can reduce the number of allocations they perform.

\section{Design}

To that end, we propose:

\begin{itemize}
\item a \tcode{ranges::size_hint} CPO
\item a \tcode{approximately_sized_range} concept that checks whether a range supports \tcode{size_hint}
\item the extension of many existing standard views so that they can forward the \tcode{size_hint} of their adapted view
\end{itemize}

\subsection{\tcode{ranges::size_hint}}

\tcode{ranges::size_hint} is a CPO that calls
\begin{itemize}
    \item \tcode{ranges::size} for sized ranges
    \item the \tcode{size_hint} member function.
    \item the \tcode{size_hint} function found by adl.
\end{itemize}

Like \tcode{ranges::size} we mandate O(1) evaluation of \tcode{size_hint}.
With this design, ranges that are sized are already \tcode{approximately_sized_range}, which avoid some duplication, undue complexity, and confusion.
for example, we don't have to modify existing containers and views whose sized-ness does not depend on another view.

\subsection{Usage}

An implementation of \tcode{uppercase_view} might look like this

\begin{colorblock}
template <input_range V>
class uppercase_view {
    constexpr const V & base() const;
    constexpr auto begin() const;
    constexpr auto end() const;

    constexpr auto size_hint() requires approximately_sized_range<View> {
        return ranges::size_hint(base());
    }
    constexpr auto size_hint() const requires approximately_sized_range<const View> {
        return ranges::size_hint(base());
    }
};
\end{colorblock}

IE, we assume \tcode{uppercase_view} will have approximatively the same size as the underlying range, even if it might be in rare cases slightly more.
Note that \tcode{uppercase_view} would not provide a \tcode{size} method because it cannot determine its exact size.

\subsection{Adapting existing views}

Views that transform elements of their adapted view can just forward the \tcode{size_hint} of their underlying view.
Nothing too complicated there. \tcode{drop}, \tcode{take}, \tcode{adjacent} \tcode{chunk}, \tcode{slide} and \tcode{stride} can also
compute a \tcode{size_hint} the same way they compute their size.

\tcode{join} andf \tcode{split} cannot compute their size in O(1), so they do not provide a \tcode{size_hint}.

\subsubsection{Views with predicate}

\tcode{take_while}, \tcode{drop_while} and \tcode{filter} could in theory expose the size of their adapted range.
however, this might lead to huge overallocation so, conservatively, these things do not expose a \tcode{size_hint}.

\subsubsection{\tcode{zip} and \tcode{cartesian_product}}

It would be reasonable for \tcode{zip}'s \tcode{size_hint} to be the smallest \tcode{size_hint} amongst
the adapted ranges that do have a \tcode{size_hint}.
Similarly, it would make sense that the \tcode{size_hint} of \tcode{cartesian_product} would be the product of
the \tcode{size_hint} of the ranges that do have one.

I think the correct way to do that might be to provide 3 overloads:

\begin{colorblock}
constexpr auto size_hint() requires (approximately_sized_range<Views> &&...);
constexpr auto size_hint() const requires (approximately_sized_range<const Views> &&...);
constexpr auto size_hint() const requires (!((approximately_sized_range<Views> || approximately_sized_range<Views>) &&...));
\end{colorblock}

Otherwise, the const and non-const overload could give different results.

As I'm not entirely certain what the best approach is, this paper does not make a change to zip or \tcode{cartesian_product}

\subsection{\tcode{ranges::to}}

\tcode{ranges::to} is sligtly modified to use \tcode{ranges::size_hint} instead of \tcode{ranges::size}.
An implementation can also use \tcode{size_hint} in the various range constructors.
User code could use it for similar purposes

\section{Existing practices and alternatives considered}

Rust has a similar facility \href{https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.size_hint}{in the iterator trait}.

\begin{quoteblock}
\textbf{\tcode{fn size_hint(\&self) -> (usize, Option<usize>)}}


Returns the bounds on the remaining length of the iterator.
Specifically, size_hint() returns a tuple where the first element is the lower bound, and the second element is the upper bound.
The second half of the tuple that is returned is an Option<usize>. A None here means that either there is no known upper bound, or the upper bound is larger than usize.\\

It is not enforced that an iterator implementation yields the declared number of elements. A buggy iterator may yield less than the lower bound or more than the upper bound of elements.
size_hint() is primarily intended to be used for optimizations such as reserving space for the elements of the iterator, but must not be trusted to e.g., omit bounds checks in unsafe code. An incorrect implementation of size_hint() should not lead to memory safety violations.

That said, the implementation should provide a correct estimation, because otherwise it would be a violation of the trait’s protocol.
\end{quoteblock}

However, that flexibility is not useful in practice:
The upper bound is \href{https://internals.rust-lang.org/t/is-size-hint-1-ever-used/8187?u=scottmcm}{rarely used},
and I'm told that using it in reserved was tried and led to performance regression.
The complex return type seems to also create some confusion for rust users.

\section{Wording}

\ednote{Add the macro \tcode{__cpp_lib_ranges_zip} to \tcode{<version>} and \tcode{<ranges>}}
\begin{addedblock}
\begin{codeblock}
    #define __cpp_lib_ranges_zip 2026XX (**placeholder**)
\end{codeblock}
\end{addedblock}

\rSec1[ranges.syn]{Header \tcode{<ranges>} synopsis}

\begin{codeblock}
#include <compare>              // see \ref{compare.syn}
#include <initializer_list>     // see \ref{initializer.list.syn}
#include <iterator>             // see \ref{iterator.synopsis}

namespace std::ranges {
inline namespace @\unspec@ {
    // \ref{range.access}, range access
    inline constexpr @\unspec@ begin = @\unspec@;    // freestanding
    inline constexpr @\unspec@ end = @\unspec@;      // freestanding
    inline constexpr @\unspec@ cbegin = @\unspec@;   // freestanding
    inline constexpr @\unspec@ cend = @\unspec@;     // freestanding
    inline constexpr @\unspec@ rbegin = @\unspec@;   // freestanding
    inline constexpr @\unspec@ rend = @\unspec@;     // freestanding
    inline constexpr @\unspec@ crbegin = @\unspec@;  // freestanding
    inline constexpr @\unspec@ crend = @\unspec@;    // freestanding

    inline constexpr @\unspec@ size = @\unspec@;    // freestanding
    @\added{inline constexpr \unspec{}  size_hint = \unspec{};           // freestanding}@
    inline constexpr @\unspec@ ssize = @\unspec@;   // freestanding
    inline constexpr @\unspec@ empty = @\unspec@;   // freestanding
    inline constexpr @\unspec@ data = @\unspec@;    // freestanding
    inline constexpr @\unspec@ cdata = @\unspec@;   // freestanding
}


template<class>
constexpr bool disable_sized_range = false; // freestanding

template<class T>
concept sized_range = @\seebelow@;  // freestanding

@\added{template<class T>}@
@\added{concept approximately_sized_range = \seebelow;  // freestanding}@

template<class T>
constexpr bool enable_view = @\seebelow@;    // freestanding

}
\end{codeblock}

\ednote{Insert after }

\begin{addedblock}
\rSec2[range.prim.size.hint]{\tcode{ranges::size_hint}}
\indexlibraryglobal{size}%

\pnum
The name \tcode{ranges::size_hint} denotes a customization point
object \iref{customization.point.object}.

\pnum
Given a subexpression \tcode{E} with type \tcode{T},
let \tcode{t} be an lvalue that denotes the reified object for \tcode{E}.
Then:

\begin{itemize}
    \item
    If \tcode{ranges::size(E)} is a valid expression, \tcode{ranges::size_hint(E)} is expression-equivalent to
    \tcode{ranges::size(E)}.

    \item
    Otherwise, if \tcode{auto(t.size_hint())}
    is a valid expression of integer-like type \iref{iterator.concept.winc},
    \tcode{ranges::size_hint(E)} is expression-equivalent to
    \tcode{auto(\brk{}t.size_hint())}.

    \item
    Otherwise, if \tcode{T} is a class or enumeration type and \tcode{auto(size_hint(t))}
    is a valid expression of integer-like type
    where the meaning of \tcode{size_hint} is established as-if by performing
    argument-dependent lookup only \iref{basic.lookup.argdep},
    then \tcode{ranges::size_hint(E)} is expression-equivalent to
    that expression.

    \item
    Otherwise, \tcode{ranges::size_hint(E)} is ill-formed.
\end{itemize}

\pnum
\begin{note}
    Diagnosable ill-formed cases above
    result in substitution failure when \tcode{ranges::size_hint(E)}
    appears in the immediate context of a template instantiation.
\end{note}

\pnum
\begin{note}
    Whenever \tcode{ranges::size_hint(E)} is a valid expression, its
    type is integer-like.
\end{note}

\end{addedblock}

\rSec2[range.sized]{Sized ranges}

\pnum
The \libconcept{sized_range} concept refines \libconcept{range} with
the requirement that the number of elements in the range can be determined
in amortized constant time using \tcode{ranges::size}.

\begin{itemdecl}
    template<class T>
    concept @\deflibconcept{sized_range}@ =
    @\libconcept{range}@<T> && requires(T& t) { ranges::size(t); };
\end{itemdecl}

\begin{itemdescr}
    \pnum
    Given an lvalue \tcode{t} of type \tcode{remove_reference_t<T>}, \tcode{T}
    models \libconcept{sized_range} only if
    \begin{itemize}
        \item \tcode{ranges::size(t)} is amortized \bigoh{1}, does not modify \tcode{t},
        and is equal to \tcode{ranges::distance(\brk{}ranges::begin(t), ranges::end(t))}, and

        \item if \tcode{iterator_t<T>} models \libconcept{forward_iterator},
        \tcode{ranges::size(t)} is well-defined regardless of the evaluation of
        \tcode{ranges::begin(t)}.
        \begin{note}
            \tcode{ranges::size(t)} is otherwise not required to be
            well-defined after evaluating \tcode{ranges::begin(t)}.
            For example, it is possible for \tcode{ranges::size(t)} to be well-defined
            for a \libconcept{sized_range} whose iterator type
            does not model \libconcept{forward_iterator}
            only if evaluated before the first call to \tcode{ranges::begin(t)}.
        \end{note}
    \end{itemize}
\end{itemdescr}

\begin{addedblock}
\rSec2[range.approximately.sized]{Approximately sized ranges}

\pnum
The \libconcept{approximately_sized_range} concept refines \libconcept{range} with
the requirement that an approximation of the number of elements in the range can be determined
in amortized constant time using \tcode{ranges::size_hint}.

\begin{itemdecl}
template<class T>
concept @\deflibconcept{approximately_sized_range}@ =
@\libconcept{range}@<T> && requires(T& t) { ranges::size_hint(t); };
\end{itemdecl}

\begin{itemdescr}
    \pnum
    Given an lvalue \tcode{t} of type \tcode{remove_reference_t<T>}, \tcode{T}
    models \libconcept{approximately_sized_range} only if \tcode{ranges::size_hint(t)} is amortized \bigoh{1}, and does not modify \tcode{t}.
\end{itemdescr}
\end{addedblock}

\rSec3[range.utility.conv.to]{\tcode{ranges::to}}

\indexlibrarymember{to}{ranges}%
\begin{itemdecl}
    template<class C, @\libconcept{input_range}@ R, class... Args> requires (!@\libconcept{view}@<C>)
    constexpr C to(R&& r, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
\tcode{C} is a cv-unqualified class type.

\pnum
\returns
An object of type \tcode{C}
constructed from the elements of \tcode{r} in the following manner:
\begin{itemize}
\item
If \tcode{C} does not satisfy \libconcept{input_range} or
\tcode{\libconcept{convertible_to}<range_reference_t<R>, range_value_t<C>>}
is \tcode{true}:
\begin{itemize}
    \item
    If \tcode{\libconcept{constructible_from}<C, R, Args...>} is \tcode{true}:
    \begin{codeblock}
        C(std::forward<R>(r), std::forward<Args>(args)...)
    \end{codeblock}
    \item
    Otherwise, if
    \tcode{\libconcept{constructible_from}<C, from_range_t, R, Args...>}
    is \tcode{true}:
    \begin{codeblock}
        C(from_range, std::forward<R>(r), std::forward<Args>(args)...)
    \end{codeblock}
    \item
    Otherwise, if
    \begin{itemize}
        \item
        \tcode{\libconcept{common_range}<R>} is \tcode{true},
        \item
        the \grammarterm{qualified-id}
        \tcode{iterator_traits<iterator_t<R>>::iterator_category}
        is valid and denotes a type that models
        \tcode{\libconcept{derived_from}<input_iterator_tag>}, and
        \item
        \tcode{\libconcept{constructible_from}<C, iterator_t<R>, sentinel_t<R>, Args...>}
        is \tcode{true}:
    \end{itemize}
    \begin{codeblock}
        C(ranges::begin(r), ranges::end(r), std::forward<Args>(args)...)
    \end{codeblock}
    \item
    Otherwise, if
    \begin{itemize}
        \item
        \tcode{\libconcept{constructible_from}<C, Args...>} is \tcode{true}, and
        \item
        \tcode{\exposid{container-insertable}<C, range_reference_t<R>>} is \tcode{true}:
    \end{itemize}
    \begin{codeblock}
        C c(std::forward<Args>(args)...);
        if constexpr (@\libconcept{\added{approximately_}sized_range}@<R> && @\exposid{reservable-container}@<C>)
            c.reserve(static_cast<range_size_t<C>>(ranges::size@\added{_hint}@(r)));
        ranges::copy(r, @\exposid{container-inserter}@<range_reference_t<R>>(c));
    \end{codeblock}
\end{itemize}

\item
Otherwise,
if \tcode{\libconcept{input_range}<range_reference_t<R>>} is \tcode{true}:
\begin{codeblock}
    to<C>(r | views::transform([](auto&& elem) {
        return to<range_value_t<C>>(std::forward<decltype(elem)>(elem));
    }), std::forward<Args>(args)...);
\end{codeblock}

\item
Otherwise, the program is ill-formed.
\end{itemize}
\end{itemdescr}

\rSec3[range.ref.view]{Class template \tcode{ref_view}}

\pnum
\tcode{ref_view} is a view of the elements of some other range.
\indexlibraryglobal{ref_view}%
\begin{codeblock}
namespace std::ranges {
template<@\libconcept{range}@ R>
requires is_object_v<R>
class ref_view : public view_interface<ref_view<R>> {
    //...

    constexpr auto size() const requires @\libconcept{sized_range}@<R>
    { return ranges::size(*@\exposid{r_}@); }


    @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<R>}@
    @\added{\{ return ranges::size_hint(*\exposid{r_}); \}}@

    constexpr auto data() const requires @\libconcept{contiguous_range}@<R>
    { return ranges::data(*@\exposid{r_}@); }
};
\end{codeblock}

\rSec3[range.owning.view]{Class template \tcode{owning_view}}

\pnum
\tcode{owning_view} is a move-only view
of the elements of some other range.
\begin{codeblock}
namespace std::ranges {
template<@\libconcept{range}@ R>
requires @\libconcept{movable}@<R> && (!@\exposid{is-initializer-list}@<R>) // see \ref{range.refinements}
class owning_view : public view_interface<owning_view<R>> {
    private:
    R @\exposid{r_}@ = R();         // \expos

    public:
    owning_view() requires @\libconcept{default_initializable}@<R> = default;
    constexpr owning_view(R&& t);

    owning_view(owning_view&&) = default;
    owning_view& operator=(owning_view&&) = default;

    //...

    constexpr auto size() requires @\libconcept{sized_range}@<R>
    { return ranges::size(@\exposid{r_}@); }
    constexpr auto size() const requires @\libconcept{sized_range}@<const R>
    { return ranges::size(@\exposid{r_}@); }

    @\added{constexpr auto size_hint() requires \libconcept{approximately_sized_range}<R>}@
    @\added{\{ return ranges::size_hint(\exposid{r_}); \}}@

    @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<const R>}@
    @\added{\{ return ranges::size_hint(\exposid{r_}); \}}@

    constexpr auto data() requires @\libconcept{contiguous_range}@<R>
    { return ranges::data(@\exposid{r_}@); }
    constexpr auto data() const requires @\libconcept{contiguous_range}@<const R>
    { return ranges::data(@\exposid{r_}@); }
};
}
\end{codeblock}

\rSec3[range.as.rvalue.view]{Class template \tcode{as_rvalue_view}}

\begin{codeblock}
namespace std::ranges {
template<@\libconcept{view}@ V>
requires @\libconcept{input_range}@<V>
class as_rvalue_view : public view_interface<as_rvalue_view<V>> {
    V @\exposid{base_}@ = V();      // \expos

    public:
    as_rvalue_view() requires @\libconcept{default_initializable}@<V> = default;
    constexpr explicit as_rvalue_view(V base);

    //...

    constexpr auto size() requires @\libconcept{sized_range}@<V> { return ranges::size(@\exposid{base_}@); }
    constexpr auto size() const requires @\libconcept{sized_range}@<const V> { return ranges::size(@\exposid{base_}@); }

    @\added{constexpr auto size_hint() requires \libconcept{approximately_sized_range}<V>}@
    @\added{\{ return ranges::size_hint(\exposid{base_}); \}}@

    @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<const V>}@
    @\added{\{ return ranges::size_hint(\exposid{base_}); \}}@
};

template<class R>
as_rvalue_view(R&&) -> as_rvalue_view<views::all_t<R>>;
}
\end{codeblock}

\rSec3[range.transform.view]{Class template \tcode{transform_view}}

\indexlibraryglobal{transform_view}%
\indexlibrarymember{base}{transform_view}%
\indexlibrarymember{size}{transform_view}%
\begin{codeblock}
namespace std::ranges {
template<@\libconcept{input_range}@ V, @\libconcept{move_constructible}@ F>
requires @\libconcept{view}@<V> && is_object_v<F> &&
@\libconcept{regular_invocable}@<F&, range_reference_t<V>> &&
@\exposconcept{can-reference}@<invoke_result_t<F&, range_reference_t<V>>>
class transform_view : public view_interface<transform_view<V, F>> {
    //...

    constexpr auto size() requires @\libconcept{sized_range}@<V> { return ranges::size(@\exposid{base_}@); }
    constexpr auto size() const requires @\libconcept{sized_range}@<const V>
    { return ranges::size(@\exposid{base_}@); }

    @\added{constexpr auto size_hint() requires \libconcept{approximately_sized_range}<V>}@
    @\added{\{ return ranges::size_hint(\exposid{base_}); \}}@

    @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<const V>}@
    @\added{\{ return ranges::size_hint(\exposid{base_}); \}}@
};

}
\end{codeblock}

\rSec3[range.take.view]{Class template \tcode{take_view}}

\indexlibraryglobal{take_view}%
\indexlibrarymember{base}{take_view}%
\indexlibrarymember{begin}{take_view}%
\indexlibrarymember{end}{take_view}%
\indexlibrarymember{size}{take_view}%
\begin{codeblock}
namespace std::ranges {
template<@\libconcept{view}@ V>
class take_view : public view_interface<take_view<V>> {
    // ...
constexpr auto size() requires @\libconcept{sized_range}@<V> {
    auto n = ranges::size(@\exposid{base_}@);
    return ranges::min(n, static_cast<decltype(n)>(@\exposid{count_}@));
}

constexpr auto size() const requires @\libconcept{sized_range}@<const V> {
    auto n = ranges::size(@\exposid{base_}@);
    return ranges::min(n, static_cast<decltype(n)>(@\exposid{count_}@));
}
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
constexpr auto size_hint() requires @\libconcept{approximately_sized_range}@<V> {
    auto n = ranges::size_hint(@\exposid{base_}@);
    return ranges::min(n, static_cast<decltype(n)>(@\exposid{count_}@));
}

constexpr auto size_hint() const requires @\libconcept{approximately_sized_range}@<const V> {
    auto n = ranges::size_hint(@\exposid{base_}@);
    return ranges::min(n, static_cast<decltype(n)>(@\exposid{count_}@));
}
\end{codeblock}
\end{addedblock}
\begin{codeblock}
};

}
\end{codeblock}


\rSec3[range.drop.view]{Class template \tcode{drop_view}}

\indexlibraryglobal{drop_view}%
\indexlibrarymember{base}{drop_view}%
\indexlibrarymember{end}{drop_view}%
\indexlibrarymember{size}{drop_view}%
\begin{codeblock}
namespace std::ranges {
template<@\libconcept{view}@ V>
///...

constexpr auto size() requires @\libconcept{sized_range}@<V> {
    const auto s = ranges::size(@\exposid{base_}@);
    const auto c = static_cast<decltype(s)>(@\exposid{count_}@);
    return s < c ? 0 : s - c;
}

constexpr auto size() const requires @\libconcept{sized_range}@<const V> {
    const auto s = ranges::size(@\exposid{base_}@);
    const auto c = static_cast<decltype(s)>(@\exposid{count_}@);
    return s < c ? 0 : s - c;
}

\end{codeblock}
\begin{addedblock}
\begin{codeblock}
constexpr auto size_hint() requires @\libconcept{approximately_sized_range}@<V> {
    const auto s = ranges::size_hint(@\exposid{base_}@);
    const auto c = static_cast<decltype(s)>(@\exposid{count_}@);
    return s < c ? 0 : s - c;
}

constexpr auto size_hint() const requires @\libconcept{approximately_sized_range}@<const V> {
    const auto s = ranges::size_hint(@\exposid{base_}@);
    const auto c = static_cast<decltype(s)>(@\exposid{count_}@);
    return s < c ? 0 : s - c;
}
\end{codeblock}
\end{addedblock}
\begin{codeblock}

private:
V @\exposid{base_}@ = V();                              // \expos
range_difference_t<V> @\exposid{count_}@ = 0;           // \expos
};

}
\end{codeblock}

\rSec3[range.common.view]{Class template \tcode{common_view}}

\indexlibraryglobal{common_view}%
\indexlibrarymember{base}{common_view}%
\indexlibrarymember{size}{common_view}%
\indexlibrarymember{begin}{common_view}%
\indexlibrarymember{end}{common_view}%
\begin{codeblock}
namespace std::ranges {
template<@\libconcept{view}@ V>
requires (!@\libconcept{common_range}@<V> && @\libconcept{copyable}@<iterator_t<V>>)
class common_view : public view_interface<common_view<V>> {
    // ...
    constexpr auto size() requires @\libconcept{sized_range}@<V> {
        return ranges::size(@\exposid{base_}@);
    }
    constexpr auto size() const requires @\libconcept{sized_range}@<const V> {
        return ranges::size(@\exposid{base_}@);
    }

    @\added{constexpr auto size_hint() requires \libconcept{approximately_sized_range}<V>}@
    @\added{\{ return ranges::size_hint(\exposid{base_}); \}}@

    @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<const V>}@
    @\added{\{ return ranges::size_hint(\exposid{base_}); \}}@
};
}
\end{codeblock}

\rSec3[range.reverse.view]{Class template \tcode{reverse_view}}

\indexlibraryglobal{reverse_view}%
\indexlibrarymember{base}{reverse_view}%
\indexlibrarymember{size}{reverse_view}%
\begin{codeblock}
namespace std::ranges {
template<@\libconcept{view}@ V>
requires @\libconcept{bidirectional_range}@<V>
class reverse_view : public view_interface<reverse_view<V>> {
    ///...
    constexpr auto size() requires @\libconcept{sized_range}@<V> {
        return ranges::size(@\exposid{base_}@);
    }

    constexpr auto size() const requires @\libconcept{sized_range}@<const V> {
        return ranges::size(@\exposid{base_}@);
    }

    @\added{constexpr auto size_hint() requires \libconcept{approximately_sized_range}<V>}@
    @\added{\{ return ranges::size_hint(\exposid{base_}); \}}@

    @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<const V>}@
    @\added{\{ return ranges::size_hint(\exposid{base_}); \}}@
};

}
\end{codeblock}

\rSec3[range.as.const.view]{Class template \tcode{as_const_view}}

\begin{codeblock}
namespace std::ranges {
template<@\libconcept{view}@ V>
requires @\libconcept{input_range}@<V>
class as_const_view : public view_interface<as_const_view<V>> {
    //...

    constexpr auto size() requires @\libconcept{sized_range}@<V> { return ranges::size(@\exposid{base_}@); }
    constexpr auto size() const requires @\libconcept{sized_range}@<const V> { return ranges::size(@\exposid{base_}@); }

    @\added{constexpr auto size_hint() requires \libconcept{approximately_sized_range}<V>}@
    @\added{\{ return ranges::size_hint(\exposid{base_}); \}}@

    @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<const V>}@
    @\added{\{ return ranges::size_hint(\exposid{base_}); \}}@
};
}
\end{codeblock}

\rSec3[range.elements.view]{Class template \tcode{elements_view}}

\indexlibraryglobal{elements_view}%
\indexlibrarymember{base}{elements_view}%
\indexlibrarymember{begin}{elements_view}%
\indexlibrarymember{end}{elements_view}%
\indexlibrarymember{size}{elements_view}%
\begin{codeblock}
namespace std::ranges {
template<class T, size_t N>
concept @\defexposconcept{has-tuple-element}@ =                   // \expos
@\exposconcept{tuple-like}@<T> && N < tuple_size_v<T>;

template<class T, size_t N>
concept @\defexposconcept{returnable-element}@ =                  // \expos
is_reference_v<T> || @\libconcept{move_constructible}@<tuple_element_t<N, T>>;

template<@\libconcept{input_range}@ V, size_t N>
requires @\libconcept{view}@<V> && @\exposconcept{has-tuple-element}@<range_value_t<V>, N> &&
@\exposconcept{has-tuple-element}@<remove_reference_t<range_reference_t<V>>, N> &&
@\exposconcept{returnable-element}@<range_reference_t<V>, N>
class elements_view : public view_interface<elements_view<V, N>> {
    //...

    constexpr auto size() requires @\libconcept{sized_range}@<V>
    { return ranges::size(@\exposid{base_}@); }

    constexpr auto size() const requires @\libconcept{sized_range}@<const V>
    { return ranges::size(@\exposid{base_}@); }

    @\added{constexpr auto size_hint() requires \libconcept{approximately_sized_range}<V>}@
    @\added{\{ return ranges::size_hint(\exposid{base_}); \}}@

    @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<const V>}@
    @\added{\{ return ranges::size_hint(\exposid{base_}); \}}@

    private:
    // \ref{range.elements.iterator}, class template \tcode{elements_view::\exposid{iterator}}
    template<bool> class @\exposid{iterator}@;                      // \expos

    // \ref{range.elements.sentinel}, class template \tcode{elements_view::\exposid{sentinel}}
    template<bool> class @\exposid{sentinel}@;                      // \expos

    V @\exposid{base_}@ = V();                                      // \expos
};
}
\end{codeblock}


\rSec3[range.enumerate.view]{Class template \tcode{enumerate_view}}

\indexlibrarymember{begin}{enumerate_view}%
\indexlibrarymember{end}{enumerate_view}%
\indexlibrarymember{size}{enumerate_view}%
\begin{codeblock}
namespace std::ranges {
template<@\libconcept{view}@ V>
requires @\exposconcept{range-with-movable-references}@<V>
class enumerate_view : public view_interface<enumerate_view<V>> {
     //...

    constexpr auto size()
    requires @\libconcept{sized_range}@<V>
    { return ranges::size(@\exposid{base_}@); }

    constexpr auto size() const
    requires @\libconcept{sized_range}@<const V>
    { return ranges::size(@\exposid{base_}@); }

    @\added{constexpr auto size_hint() requires \libconcept{approximately_sized_range}<V>}@
    @\added{\{ return ranges::size_hint(\exposid{base_}); \}}@

    @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<const V>}@
    @\added{\{ return ranges::size_hint(\exposid{base_}); \}}@

    constexpr V base() const & requires @\libconcept{copy_constructible}@<V> { return @\exposid{base_}@; }
    constexpr V base() && { return std::move(@\exposid{base_}@); }
};

template<class R>
enumerate_view(R&&) -> enumerate_view<views::all_t<R>>;
}
\end{codeblock}

%\rSec3[range.zip.view]{Class template \tcode{zip_view}}
%
%\indexlibrarymember{begin}{zip_view}%
%\indexlibrarymember{end}{zip_view}%
%\indexlibrarymember{size}{zip_view}%
%\begin{codeblock}
%namespace std::ranges {
%template<class... Rs>
%concept @\defexposconcept{zip-is-common}@ =                             // \expos
%(sizeof...(Rs) == 1 && (@\libconcept{common_range}@<Rs> && ...)) ||
%(!(@\libconcept{bidirectional_range}@<Rs> && ...) && (@\libconcept{common_range}@<Rs> && ...)) ||
%((@\libconcept{random_access_range}@<Rs> && ...) && (@\libconcept{sized_range}@<Rs> && ...));
%
%template<@\libconcept{input_range}@... Views>
%requires (@\libconcept{view}@<Views> && ...) && (sizeof...(Views) > 0)
%class zip_view : public view_interface<zip_view<Views...>> {
%    //...
%    constexpr auto size() requires (@\libconcept{sized_range}@<Views> && ...);
%    constexpr auto size() const requires (@\libconcept{sized_range}@<const Views> && ...);
%
%    @\added{constexpr auto size_hint();}@
%    @\added{constexpr auto size_hint() const;}@
%
%};
%}
%\end{codeblock}

\rSec3[range.adjacent.view]{Class template \tcode{adjacent_view}}

\indexlibrarymember{begin}{adjacent_view}%
\indexlibrarymember{end}{adjacent_view}%
\indexlibrarymember{size}{adjacent_view}%
\begin{codeblock}
namespace std::ranges {
template<@\libconcept{forward_range}@ V, size_t N>
requires @\libconcept{view}@<V> && (N > 0)
class adjacent_view : public view_interface<adjacent_view<V, N>> {
    //...

    constexpr auto size() requires @\libconcept{sized_range}@<V>;
    constexpr auto size() const requires @\libconcept{sized_range}@<const V>;

    @\added{constexpr auto size_hint() requires \libconcept{approximately_sized_range}<V>;}@
    @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<const V>;}@

};
}
\end{codeblock}

\begin{itemdecl}
    constexpr auto size() requires @\libconcept{sized_range}@<V>;
    constexpr auto size() const requires @\libconcept{sized_range}@<const V>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to:
    \begin{codeblock}
        using ST = decltype(ranges::size(@\exposid{base_}@));
        using CT = common_type_t<ST, size_t>;
        auto sz = static_cast<CT>(ranges::size(@\exposid{base_}@));
        sz -= std::min<CT>(sz, N - 1);
        return static_cast<ST>(sz);
    \end{codeblock}
\end{itemdescr}

\begin{addedblock}
\begin{itemdecl}
    constexpr auto size_hint() requires @\libconcept{approximately_sized_range}@<V>;
    constexpr auto size_hint() const requires @\libconcept{approximately_sized_range}@<const V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
    using ST = decltype(ranges::size_hint(@\exposid{base_}@));
    using CT = common_type_t<ST, size_t>;
    auto sz = static_cast<CT>(ranges::size_hint(@\exposid{base_}@));
    sz -= std::min<CT>(sz, N - 1);
    return static_cast<ST>(sz);
\end{codeblock}
\end{itemdescr}
\end{addedblock}

rSec3[range.adjacent.transform.view]{Class template \tcode{adjacent_transform_view}}

\indexlibrarymember{begin}{adjacent_transform_view}%
\indexlibrarymember{end}{adjacent_transform_view}%
\indexlibrarymember{size}{adjacent_transform_view}%
\begin{codeblock}
namespace std::ranges {
template<@\libconcept{forward_range}@ V, @\libconcept{move_constructible}@ F, size_t N>
requires @\libconcept{view}@<V> && (N > 0) && is_object_v<F> &&
@\libconcept{regular_invocable}@<F&, @\exposid{REPEAT}@(range_reference_t<V>, N)...> &&
@\exposconcept{can-reference}@<invoke_result_t<F&, @\exposid{REPEAT}@(range_reference_t<V>, N)...>>
class adjacent_transform_view : public view_interface<adjacent_transform_view<V, F, N>> {
    //...
    constexpr auto size() requires @\libconcept{sized_range}@<@\exposid{InnerView}@> {
        return @\exposid{inner_}@.size();
    }

    constexpr auto size() const requires @\libconcept{sized_range}@<const @\exposid{InnerView}@> {
        return @\exposid{inner_}@.size();
    }

    @\added{constexpr auto size_hint() requires \libconcept{approximately_sized_range}<InnerView>}@
    @\added{\{ return \exposid{inner_}.size_hint(); \}}@

    @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<const InnerView>}@
    @\added{\{ \exposid{inner_}.size_hint(); \}}@
};
}
\end{codeblock}

\rSec3[range.chunk.view.input]{Class template \tcode{chunk\_view} for input ranges}

\indexlibrarymember{begin}{chunk_view}%
\indexlibrarymember{end}{chunk_view}%
\indexlibrarymember{size}{chunk_view}%
\begin{codeblock}
class chunk_view : public view_interface<chunk_view<V>> {
    //...
    constexpr auto size() requires @\libconcept{sized_range}@<V>;
    constexpr auto size() const requires @\libconcept{sized_range}@<const V>;
    @\added{constexpr auto size_hint() requires \libconcept{approximately_sized_range}<V>;}@
    @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<const V>;}@
};
\end{codeblock}

\begin{itemdecl}
    constexpr auto size() requires @\libconcept{sized_range}@<V>;
    constexpr auto size() const requires @\libconcept{sized_range}@<const V>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to:
    \begin{codeblock}
        return @\exposid{to-unsigned-like}@(@\exposid{div-ceil}@(ranges::distance(@\exposid{base_}@), @\exposid{n_}@));
    \end{codeblock}
\end{itemdescr}

\begin{addedblock}
\begin{itemdecl}
    constexpr auto size_hint() requires @\libconcept{approximately_sized_range}@<V>;
    constexpr auto size_hint() const requires @\libconcept{approximately_sized_range}@<const V>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to:
    \begin{codeblock}
        return @\exposid{to-unsigned-like}@(@\exposid{div-ceil}@(ranges::size_hint(@\exposid{base_}@), @\exposid{n_}@));
    \end{codeblock}
\end{itemdescr}
\end{addedblock}

\rSec3[range.chunk.view.fwd]{Class template \tcode{chunk_view} for forward ranges}

\indexlibrarymember{begin}{chunk_view}%
\indexlibrarymember{end}{chunk_view}%
\indexlibrarymember{size}{chunk_view}%
\begin{codeblock}
namespace std::ranges {
template<@\libconcept{view}@ V>
requires @\libconcept{forward_range}@<V>
class chunk_view<V> : public view_interface<chunk_view<V>> {
   //...
   constexpr auto size() requires @\libconcept{sized_range}@<V>;
   constexpr auto size() const requires @\libconcept{sized_range}@<const V>;
   @\added{constexpr auto size_hint() requires \libconcept{approximately_sized_range}<V>;}@
   @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<const V>;}@
};
}
\end{codeblock}

\begin{itemdecl}
    constexpr auto size() requires @\libconcept{sized_range}@<V>;
    constexpr auto size() const requires @\libconcept{sized_range}@<const V>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to:
    \begin{codeblock}
        return @\exposid{to-unsigned-like}@(@\exposid{div-ceil}@(ranges::distance(@\exposid{base_}@), @\exposid{n_}@));
    \end{codeblock}
\end{itemdescr}

\begin{addedblock}
\begin{itemdecl}
    constexpr auto size_hint() requires @\libconcept{approximately_sized_range}@<V>;
    constexpr auto size_hint() const requires @\libconcept{approximately_sized_range}@<const V>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to:
    \begin{codeblock}
        return @\exposid{to-unsigned-like}@(@\exposid{div-ceil}@(ranges::size_hint(@\exposid{base_}@), @\exposid{n_}@));
    \end{codeblock}
\end{itemdescr}
\end{addedblock}

\rSec3[range.slide.view]{Class template \tcode{slide_view}}

\indexlibrarymember{begin}{slide_view}%
\indexlibrarymember{end}{slide_view}%
\indexlibrarymember{size}{slide_view}%
\begin{codeblock}
namespace std::ranges {
template<@\libconcept{forward_range}@ V>
requires @\libconcept{view}@<V>
class slide_view : public view_interface<slide_view<V>> {
    //...
    constexpr auto size() requires @\libconcept{sized_range}@<V>;
    constexpr auto size() const requires @\libconcept{sized_range}@<const V>;
    @\added{constexpr auto size_hint() requires \libconcept{approximately_sized_range}<V>;}@
    @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<const V>;}@
};
}
\end{codeblock}

\begin{itemdecl}
    constexpr auto size() requires @\libconcept{sized_range}@<V>;
    constexpr auto size() const requires @\libconcept{sized_range}@<const V>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to:
    \begin{codeblock}
        auto sz = ranges::distance(@\exposid{base_}@) - @\exposid{n_}@ + 1;
        if (sz < 0) sz = 0;
        return @\exposid{to-unsigned-like}@(sz);
    \end{codeblock}
\end{itemdescr}


\begin{addedblock}
\begin{itemdecl}
    constexpr auto size_hint() requires @\libconcept{approximately_sized_range}@<V>;
    constexpr auto size_hint() const requires @\libconcept{approximately_sized_range}@<const V>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to:
    \begin{codeblock}
        auto sz = static_cast<range_difference_t<R>>(ranges::size_hint(r)) - @\exposid{n_}@ + 1;
        if (sz < 0) sz = 0;
        return @\exposid{to-unsigned-like}@(sz);
    \end{codeblock}
\end{itemdescr}
\end{addedblock}

\rSec3[range.stride.view]{Class template \tcode{stride_view}}

\begin{codeblock}
namespace std::ranges {
template<@\libconcept{input_range}@ V>
requires @\libconcept{view}@<V>
class stride_view : public view_interface<stride_view<V>> {
    //

    constexpr auto size() requires @\libconcept{sized_range}@<V>;
    constexpr auto size() const requires @\libconcept{sized_range}@<const V>;
    @\added{constexpr auto size_hint() requires \libconcept{approximately_sized_range}<V>;}@
    @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<const V>;}@
};
}
\end{codeblock}

\begin{itemdecl}
    constexpr auto size() requires @\libconcept{sized_range}@<V>;
    constexpr auto size() const requires @\libconcept{sized_range}@<const V>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to:
    \begin{codeblock}
        return @\exposid{to-unsigned-like}@(@\exposid{div-ceil}@(ranges::distance(@\exposid{base_}@), @\exposid{stride_}@));
    \end{codeblock}
\end{itemdescr}

\begin{addedblock}
\begin{itemdecl}
    constexpr auto size_hint() requires @\libconcept{approximately_sized_range}@<V>;
    constexpr auto size_hint() const requires @\libconcept{approximately_sized_range}@<const V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
    return @\exposid{to-unsigned-like}@(@\exposid{div-ceil}@(ranges::size_hint(@\exposid{base_}@), @\exposid{stride_}@));
\end{codeblock}
\end{itemdescr}
\end{addedblock}


\section{Acknowledgments}

Thanks to Zach Laine and Barry Revzin for providing valuable feedback on an early draft of this paper.


\bibliographystyle{plain}
\bibliography{wg21}


\renewcommand{\section}[2]{}%

\begin{thebibliography}{9}


\end{thebibliography}
\end{document}
