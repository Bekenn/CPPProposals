% !TeX program = luatex
% !TEX encoding = UTF-8


\documentclass{wg21}

\title{constexpr structured bindings and references to constexpr variables}
\docnumber{P2686R1}
\audience{EWG}
\author{Corentin Jabot}{corentin.jabot@gmail.com}
\authortwo{Brian Bi}{bbi10@bloomberg.net}

\usepackage{color, colortbl}
\begin{document}
\maketitle

\section{Abstract}

\paper{P1481R0} proposed to allow reference to constant expressions to be themselves constant expressions,
as a means to support \tcode{constexpr} structured bindings.
This paper reports implementation experience on this proposal and provides updated wording.

\section{Issues With R0 and possible solutions}

The previous revision of this paper (\paper{P2686R0}) was approved by EWG in Issaquah, and was subsequently
reviewed by CWG which found the proposed wording to be quite insufficient.

There is no issue with allowing constexpr structured binding in general, except for the case of an automatic storage duration structured binding
initialized by a tuple.

Ie, this scenario specifically:

\begin{colorblock}
void f() {
    constexpr auto [a] = std::tuple(1);
    static_assert(a == 1);
}
\end{colorblock}

Which translates to the following:

\begin{colorblock}
void f() {
    constexpr auto __sb = std::tuple(1);  // __sb has automatic storage scenario
    constexpr const int& a = get<0>(__sb);
}
\end{colorblock}

When the structured binding is over an array or a class type, it doesn't really create actual references,
so there is no issue. And when the structured binding is not at function scope, the underlying tuple object has
static storage duration and its address is a permitted result of a constant expression.

So the problematic case is when we are creating an automatic storage duration (ie, at block scope) structured binding of a tuple (or \placeholder{tuple-like})
object. It is a specific scenario, but not an uncommon one.

\subsection{Issue with the originally proposed wording}

The initial wording simply allowed references initialized by a constant expression to be usable in constant expressions.
This failed to observe that the address of a \tcode{constexpr} variable with automatic storage duration may be different for each evaluation
of a function and therefore cannot be a \emph{permitted result of a constant expression}.

CWG asks that EWG considers and pick one direction to resolve these concerns.
Some options are explored below.

\section{Possible solutions}

\subsection{\#0 Allowing static and non-tuple constexpr structured binding}

We should be clear that nothing prevents \tcode{constexpr} structured bindings from just working when binding an aggregate or an array - as those are modeled by special magic aliases that are not quite references
(which allows them to work with bitfields).

And a constexpr structured binding of a tuple \emph{with static storage duration}, ie:
\begin{colorblock}
static constexpr auto [a, b] = std::tuple{1, 2};
\end{colorblock}

would also just work as it would be equivalent to

\begin{colorblock}
static constexpr auto __t = std::tuple{1, 2};
static constexpr auto & a = std::get<0>(__t);
static constexpr auto & b = std::get<1>(__t);
\end{colorblock}

Supporting that requires no further changes to the language than basically allowing the compiler to
parse and apply the constexpr specifier.
And independently of the rest of this paper, this would be useful and should be done.

The problematic scenario is an automatic storage duration binding to a \tcode{tuple}.

We could stop there, i.e. not try to solve this problem and force users to use \tcode{static}.
We would however have to make sure expansion statements work with static variables as this was one of the motivations for this paper.
The rest of the paper explores other options.

\subsection{\#1 Making \tcode{constexpr} implicitly static}

We could make \tcode{constexpr} variables implicitly static.
However, this would most certainly break existing code, in addition to being inconsistent with the meaning of constexpr.
Consider

\begin{colorblock}
int f() {
    constexpr struct S {
        mutable int m ;
    } s{0};
    return ++s.m;
}

int main() {
    assert(f() + f() == 2); // currently 2. Becomes 3 if 's' is made implicitly static
}
\end{colorblock}

So this is not a practical suggestion. We could, as Richard Smith suggested
make \tcode{constexpr} only static in some cases to alleviate some of the breakages, or even only make constexpr bindings static - and not other variables, but this
feels like a hack rather than an actual solution.

\subsection{\#2 Always re-evaluate a call to \tcode{get}?}

We could conceive that during constant evaluation, tuple structured bindings are replaced by a call to \tcode{get} every time they are constant-evaluated.
This would help with constexpr structured binding, but would still disallow generic cases like :

\begin{colorblock}
constexpr in not_a_sb =1;
constexpr const int&  a = sb;
\end{colorblock}

Additionally, this would be observable in scenarios where get would perform some kind of compile-time i/o such as proposed by \paper{P2758R0}.

\subsection{\#3 Symbolic addressing}

The most promising option, the one we think should be pursued is for \tcode{constexpr} references to designate a specific object, rather than an address,
and to retain that information across constant evaluation contexts.
This is how constant evaluation of references works except that this information is not currently persisted across constant evaluation - which is why we do not permit
constexpr references to refer to objects with automatic storage duration (or subobjects thereof).

To quote the reflector:

\begin{quoteblock}
This would also resolve a longstanding complaint that the following is invalid:
\begin{colorblock}
void f() {
    constexpr int a = 1;
    constexpr auto *p = &a;
}
\end{colorblock}

It seems like a lot of C++ developers expect the declaration of p to be valid, even though it's potentially initialized to a different address each time f is invoked.
\end{quoteblock}

This solution has the benefit of not being structured-binding specific and would arguably meet user expectations better than the current rule.
Interestingly, and maybe counter-intuitively  the constexprness of pointers and references is completely orthogonal to that of their underlying object:

\begin{colorblock}
int main() {
    static int i = 0;
    static constexpr int & r = i; // currently valid

    int j = 0;
    constexpr int & s = j; // could be valid under the "symbolic addressing" model.
}
\end{colorblock}

References can be constant expressions because we can track during constant evaluation which objects they refer to, independently of whether the value of that object is or isn't a constant expression.

There are several things we would have to be careful about.
Pointers and references to variables with automatic storage duration cannot be used outside of the lifetime of their underlying objects, so they could not appear
\begin{itemize}
  \item In template arguments
  \item As the initializer of a variable with static storage duration.
\end{itemize}

Similarly, we can construct an automatic storage duration constexpr reference to a static variable, but not a static constexpr reference bound to an automatic storage duration object.

\subsection{Additional considerations}

\subsubsection{Thread-local variables}

Taking the address of a thread-local variable may initialize the variable, and that initialization may not be a constant expression.
Supporting references/pointers to thread-local variables would therefore require additional consideration, probably we would only want to allow it if it was already initialized
on declaration.

We could exclude thread locals from the design entirely as I'm not sure there is a compelling use case for constexpr references to thread-local objects.

\subsubsection{Lambda capture of \tcode{constexpr} references bound to automatic storage duration objects}

\tcode{constexpr} references are not odr-used.  Because of that, a constexpr reference used in a lambda does not trigger a capture.
This would be problematic for references bound to automatic storage duration objects, ie consider:

\begin{colorblock}
auto f() {
    int i = 0;
    constexpr const int & ref = i;
    return [] {
        return ref;
    });
}
f(); //# ! try to access i outside of its lifetime
\end{colorblock}

We will have to modify \href{http://eel.is/c++draft/basic.def.odr#5.1}{[basic.def.odr]/p5.1}so that constexpr references to automatic storage duration variables (or subobjects thereof) are odr-used.

\section{Next step}

CWG is asking EWG to pick a direction. We will provide wording consistent with that direction.
We need to pick one of the options presented in this paper.

\begin{itemize}
\item Option \#1: Making \tcode{constexpr} implicitly static
\item Option \#2: Always re-evaluate a call to \tcode{get}
\item Option \#3: Symbolic addressing.
\end{itemize}

Because Option \#1 and \#2 can either break existing code or introduce inconsistency, we suggest that the third option, Symbolic Addressing
constitutes the best path forward.

If we pick that third option, we should further decide whether we want to limit ourselves to allow constexpr references to automatic duration storage objects, or if we should also support
constexpr references to thread local duration storage objects, knowing that this will require additional complexity due to the fact that
thread-local variables are initialized at the point of use.

In the meantime, this paper retains the wording for \tcode{constexpr} structured binding which can be pursued independently (automatic storage duration bindings of \tcode{tuple} will simply not work.) - this is the wording for Option \#0;
%\section{Original Motivation}
%
%The context for this paper can be found in \paper{P1481R0}.
%I was not aware to reach the original author, nor do I have the possibility to reproduce the original paper.
%
%The gist of it is that the original author proposed to support \tcode{constexpr} structured binding by making
%
%\begin{colorblock}
%constexpr auto[a] = std::tuple(1);
%\end{colorblock}
%
%Equivalent to
%\begin{colorblock}
%constexpr auto __sb = std::tuple(1);
%const int& __a = std::get<0>(__sb);
%\end{colorblock}
%
%In addition to the original motivation, if we believe structured bindings are useful (they are, great feature!) and we also believe in constexpr (as a means to increase type safety, improve runtime performance, etc),
%then both features ought to work together.
%
%In addition to that, Expansion Statements (\paper{P1306R1}) aim to add a new kind of for loop
%with the express purpose to loop over tuples at compile time.
%
%\begin{colorblock}
%auto tup = std::make_tuple(0, ‘a’, 3.14);
%// ill-formed without this paper
%template for (constexpr auto [idx, member] : std::views::enumerate(meta::data_members_of(^T)) )
%    fmt::print("{} {}", idx, foo.[:member:]);
%\end{colorblock}
%
%
%\subsection{History}
%
%Interestingly, this proposal was last seen in Kona in 2019.
%The concerns were
%\begin{itemize}
%    \item Lack of implementation
%    \item It was presented late in the C++20 cycle
%\end{itemize}
%
%
%\begin{quoteblock}
%Encourage further work on this proposal
%
%\begin{tabular}{|c|c|c|c|c|}
%    \hline
%    SF & F & N & A & SA\\
%    \hline
%    9 & 16 & 4 & 0 & 0 \\
%    \hline
%\end{tabular}
%\end{quoteblock}
%
%This paper thereby provides an implementation.
%I've also updated the wording as CWG rewrote the impacted section, and added the wording to support the constexpr keyword
%on structured bindings declarations.
%
%\section{Implementation}
%
%\subsection{Circle}
%
%Circle implements constexpr structured bindings - and generally supports initializing references with constant expressions,
%and Sean Baxter was not aware that the standard didn't support it.
%Sean further observed that this is a core language syntactic sugar and as such, users could expect it to work everywhere.
%
%\subsection{Clang}
%I implemented a prototype implementation in the hope to weed out issues.
%It is available on \href{https://godbolt.org/z/dWWxcEEf9}{Compiler Explorer}.
%
%Please note that by lack of time, I have not yet published the last version of the implementation, but that should hopefully be
%done before Kona.
%
%
%I don't think the implementation revealed particular issues (my own inaptitudes non-withstanding), I, however, believe \tcode{[basic.odr]}
%might need to be tweaked.
%
%\begin{quoteblock}
%A variable \tcode{x} that is named by a potentially-evaluated expression \tcode{E} is odr-used by \tcode{E} unless x is a reference that is usable in constant expressions ([expr.const]).
%\end{quoteblock}
%
%I don't think this is sufficient. Consider for example,
%
%\begin{colorblock}
%void foo() {
%    const int a = 1;
%    const int& b = a;
%    auto l = [] { return b; }; // we should not capture b implicitly here,
%                               // even if b is usable in constant expressions
%}
%\end{colorblock}
%
%In my prototype, I check that the initializer of the reference is itself a constant expression, and that seems to work.

\section{Wording for constexpr structured binding}

\ednote{This wording only makes constexpr structured a valid grammatical construct and does not permit automatic storage duration bindings of tuple-like objets}

%\rSec1[expr.const]{Constant expressions}%
%
%\pnum
%A variable is \defn{potentially-constant} if
%it is constexpr or
%it has reference or const-qualified integral or enumeration type.
%
%\pnum
%A constant-initialized potentially-constant variable $V$ is
%\defn{usable in constant expressions} at a point $P$ if
%$V$'s initializing declaration $D$ is reachable from $P$ and
%\begin{itemize}
%    \item $V$ is constexpr \added{or it is of reference type initialized with a core constant expression},
%    \item $V$ is not initialized to a TU-local value, or
%    \item $P$ is in the same translation unit as $D$.
%\end{itemize}
%An object or reference is \defn{usable in constant expressions} if it is
%\begin{itemize}
%    \item a variable that is usable in constant expressions, or
%    \item a template parameter object\iref{temp.param}, or
%    \item a string literal object\iref{lex.string}, or
%    \item a temporary object of non-volatile const-qualified literal type
%    whose lifetime is extended\iref{class.temporary}
%    to that of a variable that is usable in constant expressions, or
%    \item a non-mutable subobject or reference member of any of the above.
%\end{itemize}
%

\rSec1[dcl.dcl]{Declarations}%
\rSec2[dcl.pre]{Preamble}

\ednote{Change 9.1.6 as follow}

\pnum
A \grammarterm{simple-declaration} with an \grammarterm{identifier-list} is called
a \defn{structured binding declaration}\iref{dcl.struct.bind}.
Each \grammarterm{decl-specifier} in the \grammarterm{decl-specifier-seq}
shall be
\added{\tcode{constexpr},}
\tcode{static},
\tcode{thread_local},
\tcode{auto} \iref{dcl.spec.auto}, or
a \grammarterm{cv-qualifier}.
\begin{example}
    \begin{codeblock}
        template<class T> concept C = true;
        C auto [x, y] = std::pair{1, 2};    // error: constrained \grammarterm{placeholder-type-specifier}
        // not permitted for structured bindings
    \end{codeblock}
\end{example}

\rSec1[dcl.struct.bind]{Structured binding declarations}%
%\indextext{structured binding declaration}%
%\indextext{declaration!structured binding|see{structured binding declaration}}%

\pnum
A structured binding declaration introduces the \grammarterm{identifier}{s}
$\tcode{v}_0$, $\tcode{v}_1$, $\tcode{v}_2, \dotsc$
of the
\grammarterm{identifier-list} as names
of \defn{structured binding}{s}.
Let \cv{} denote the \grammarterm{cv-qualifier}{s} in
the \grammarterm{decl-specifier-seq} and
\placeholder{S} consist of the \added{\tcode{constexpr} and }\grammarterm{storage-class-specifier}{s} of
the \grammarterm{decl-specifier-seq} (if any).
A \cv{} that includes \tcode{volatile} is deprecated;
see~\ref{depr.volatile.type}.
First, a variable with a unique name \exposid{e} is introduced. If the
\grammarterm{assignment-expression} in the \grammarterm{initializer}
has array type \cvqual{cv1} \tcode{A} and no \grammarterm{ref-qualifier} is present,
\exposid{e} is defined by
\begin{ncbnf}
    \opt{attribute-specifier-seq} \placeholder{S} \cv{} \terminal{A} \exposid{e} \terminal{;}
\end{ncbnf}
and each element is copy-initialized or direct-initialized
from the corresponding element of the \grammarterm{assignment-expression} as specified
by the form of the \grammarterm{initializer}.
Otherwise, \exposid{e}
is defined as-if by
\begin{ncbnf}
    \opt{attribute-specifier-seq} decl-specifier-seq \opt{ref-qualifier} \exposid{e} initializer \terminal{;}
\end{ncbnf}
where
the declaration is never interpreted as a function declaration and
the parts of the declaration other than the \grammarterm{declarator-id} are taken
from the corresponding structured binding declaration.
The type of the \grammarterm{id-expression}
\exposid{e} is called \tcode{E}.
\begin{note}
    \tcode{E} is never a reference type\iref{expr.prop}.
\end{note}

\pnum
If the \grammarterm{initializer} refers to
one of the names introduced by the structured binding declaration,
the program is ill-formed.

\pnum
If \tcode{E} is an array type with element type \tcode{T}, the number
of elements in the \grammarterm{identifier-list} shall be equal to the
number of elements of \tcode{E}. Each $\tcode{v}_i$ is the name of an
lvalue that refers to the element $i$ of the array and whose type
is \tcode{T}; the referenced type is \tcode{T}.
\begin{note}
    The top-level cv-qualifiers of \tcode{T} are \cv.
\end{note}
\begin{example}
    \begin{codeblock}
        auto f() -> int(&)[2];
        auto [ x, y ] = f();            // \tcode{x} and \tcode{y} refer to elements in a copy of the array return value
        auto& [ xr, yr ] = f();         // \tcode{xr} and \tcode{yr} refer to elements in the array referred to by \tcode{f}'s return value
    \end{codeblock}
\end{example}


\rSec2[dcl.constexpr]{The \keyword{constexpr} and \keyword{consteval} specifiers}%
\indextext{specifier!\idxcode{constexpr}}
\indextext{specifier!\idxcode{consteval}}

\pnum
The \keyword{constexpr} specifier shall be applied only to
the definition of a variable or variable template\added{, a structured binding declaration, } or
the declaration of a function or function template.
The \keyword{consteval} specifier shall be applied only to
the declaration of a function or function template.
A function or static data member
declared with the \keyword{constexpr} or \keyword{consteval} specifier
is implicitly an inline function or variable\iref{dcl.inline}.
If any declaration of a function or function template has
a \keyword{constexpr} or \keyword{consteval} specifier,
then all its declarations shall contain the same specifier.


\section{Feature test macros}

\ednote{ In \tcode{[tab:cpp.predefined.ft]}, bump \tcode{__cpp_structured_bindings} to the date of adoption}.


\section{Acknowledgments}

We would like to thank Bloomberg for sponsoring this work.
Thanks to Nina Dinka Ranns, Pablo Halpernm and Joshua Berne for their feedback.

Thanks to Richard Smith for the original discussion of possible solutions on the Core reflector.

Thanks to Nicolas Lesser for the original work on \paper{P1481R0}.

\section{References}

\renewcommand{\section}[2]{}%
\bibliographystyle{plain}
\bibliography{wg21, extra}

\begin{thebibliography}{9}

\bibitem[N4885]{N4885}
Thomas Köppe
\emph{Working Draft, Standard for Programming Language C++}\newline
\url{https://wg21.link/N4885}


\end{thebibliography}

\end{document}

%%%% example foo6 on godbolt is usable as a pr-value in a constant expression
% [expr.const] 5.9
% special case structure bindings to say they are evaluated in a constant expression context.
% Modify https://eel.is/c++draft/dcl.pre#6
