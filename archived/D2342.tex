% !TeX document-id = {9322a846-f757-4574-9231-a2e85c743b21}
% !TeX program = luatex
% !TEX encoding = UTF-8


\RequirePackage{luatex85}%
\documentclass{wg21}

\RequirePackageWithOptions{fontspec}
\usepackage{newunicodechar}

\setmainfont{Noto Sans}

\newfontfamily{\fallbackfont}{Noto Sans}
\DeclareTextFontCommand{\textfallback}{\fallbackfont}
\newunicodechar{ẞ}{\textfallback{ẞ}}



\newcommand{\UnicodeLetter}[1]{\textbf{\textcolor{BrickRed}{\Large\tcode{#1}}}}


\title{For a Few Punctuators More}
\docnumber{P2342R0}
\audience{SG-7, EWG}
\author{Corentin Jabot}{corentin.jabot@gmail.com}

\begin{document}
    \maketitle
    
    \section{Abstract}
    
    This paper argues that the dollar sign \tcode{\$}, bactick \tcode{\textasciigrave} and at \tcode{\atsign} could be used as a token in C++ for any future proposal that may have a use for it,
    with minimal impact on the C++ ecosystem.
    This aim to address the concerns raised when \tcode{\$} was proposed for reflection and subsequently rejected for fear of breaking either code or tools.
    
    \section{Goals and Scope of this paper}
    
    \textbf{This is an informative paper which proposes no change to the standard.}
    
    We however hope to convince WG21 and paper authors - notably ther authors of \paper{P2320R0} that using new punctuators is an option, if it would make sense in the
    context of a specific proposal.
    
    Of course other consideration specific to the feature might apply - for example, \tcode{\textasciigrave} and \tcode{'} are hard to distinguish, so  using \tcode{\textasciigrave}
    might not be sensible in all contextes.
    
    We are also not trying that we must or should use new symbols, just that we can do so if we ever want to!
    
    
    \section{Motivation}
    
    It seems increasingly difficult to find syntaxes for new features that are both distinct, easily readable, and terse.
    Of the non-alphanumeric characters available in both ASCII and EBCDIC, C++ makes use of the following:
    \begin{codeblock}
        . , < > ? / : ; ' " () {} [] %  * + - + = \ # ^ & | ~
    \end{codeblock}
    
    While the following are not used:
    \begin{codeblock}
        ` $ @\atsign@
    \end{codeblock}
    
    \section{Analysis of the ecosystem}
    
    \section{@}
    
    \subsection{Objective-C}
    
    \tcode{@} is used by Objective-C and Objective C++,  precisely because it is not valid C or C++ syntaxes.
    Some keywords are introduced by \tcode{@}:
    \begin{multicols}{4}
        \color{blue}
        \tcode{@interface}
        
        \tcode{@end}
        
        \tcode{@implementation}
        
        \tcode{@protocol}
        
        \tcode{@class}
        
        \tcode{@public}
        
        \tcode{@protected}
        
        \tcode{@private}
        
        \tcode{@property}
        
        \tcode{@try}
        
        \tcode{@throw}
        
        \tcode{@catch}
        
        \tcode{@finally}
        
        \tcode{@synthesize}
        
        \tcode{@dynamic}
        
        \tcode{@selector}
    \end{multicols}
    
    
    \tcode{@} is also used to construct specific objects (\tcode{NSString, NSNumbers, NSArray, NSDictionary}) from literals and expressions.
    As such, the following are valid constructs in Objective-C:
    \begin{codeblock}
        @\atsign@""
        @\atsign@123
        @\atsign@[foo, bar]
        @\atsign@(@\emph{expression}@)
        @\atsign@{foo:bar, baz:bar}
    \end{codeblock}
    
    This does reduce the possibility of using \tcode{@} in C++ if we are about Objective-C++. We do not try to answer the question of the relevance of Objective-C++ in this paper.
    
    Note that some syntaxes are available, for example \tcode{@</**/>} is not a valid Objective-C construct.
    
    \subsection{CMake}
    
    CMake's \tcode{configure_file} comand replaces \tcode{@VAR@} in files being generated by the corresponding cmake variable.
    No escape mechanism seems to be provided. This will be explored in more detail further in this document.
    
    \subsection{Bison}
    
    \tcode{@} can appear in Bison/Yacc, usually preceding a number or a dollar sign, with no mean of escaping.
    This can however be worked around by a macro
    
    \begin{colorblock}
        %{
        #define MY_LIB_ATSIGN(x) @\atsign@ ## x
        %}
        %%
        //...
        
        MY_LIB_ATSIGN(foo);
        
        //...
        
    \end{colorblock}
    
    \section{\$}
    
    \subsection{\$ in identifiers}
    
    \tcode{\$} is allowed in identifiers as a compiler extension by GCC, Clang, MSVC, ICC (\href{https://godbolt.org/z/5P18rc}{[Compiler explorer]}).
    We surveyed the VCPGK repository.
    
    \begin{itemize}
        \item \tcode{\$} is used as a macro identifier in the \href{http://www.1024cores.net/home/relacy-race-detector}{Relacy} library. This library does not seem to be maintained in the past couple of years and there seem to be few usages of it - although HPX is a user. 
        \item \tcode{\$} appears in system functions in OpenVMS - But not in a leading position. These functions appear listed in \href{https://vmssoftware.com/docs/VSI_UTIL_ROUTINES_MANUAL.pdfhttps://vmssoftware.com/docs/VSI_UTIL_ROUTINES_MANUAL.pdf}{VSI OpenVMS Utility Routines Manual}.
        Projects that are ported to OpenVMS call these functions.
        \item Similarily, \tcode{\$} appears in specific symbols injected by the \tcode{armlink} linker, although never in leading position 
        \item Similarily, \tcode{\$} appears in specific system functions on Darwin platforms for example \tcode{close\$NOCANCEL}
        \item \tcode{\$inject} appears in the \tcode{boost-di} library. Although we found no use of that identifier in the surveyed projects
        \item \tcode{ChakraCore}, the JS engine for IE9 uses \$0, \$1... \$9 in an enumerator (which does not appear to be part of a public interface). This projets seems to compile for C++11
        \item \tcode{\$} can appear in asm statements or macros that are expanded in asm statements
        \item the C library \href{http://libcello.org/}{Cello} use the dollar sign as a macro extensively - This library does not appear to be widely used.
        \item the \tcode{.NET} framework uses \tcode{\$} in reserved identifiers \href{https://github.com/dotnet/runtime/blob/main/src/coreclr/pal/inc/rt/specstrings_strict.h}{Github}
    \end{itemize}
    
    In total, we find ~2400 pp-token (excluding asm statements) with \$ in them in a corpus of 64640967 lines of C++ code and 33959876 lines of C code.
    Relacy accounts for ~900 of these uses; Most of the remaining uses are in system symbols, notably, over 1000 uses seem related to OpenVMS.
    
    \tcode{\$} appear in the leading position no more than 300 times, half of which are in \tcode{ChakraCore}.
    
    We found a further 2900 \tcode{\$} in C source files, of which 1300 are related to OpenVMS and 1100 are in the \href{http://libcello.org/}{Cello} library.
    
    \textbf{\tcode{\$\{\}}  and \tcode{\$()} never appear in the surveyed corpus except in Cello, which is a C library}.
    
    Because \tcode{\$} is not portable, some library perform some gymnastics to avoid potential warning, here is an example taken from \tcode{libuv}:
    
    \begin{colorblock}
        int uv__close_nocancel(int fd) {
            #pragma GCC diagnostic push
            #pragma GCC diagnostic ignored "-Wdollar-in-identifier-extension"
            extern int close$NOCANCEL(int);
            return close$NOCANCEL(fd);
            #pragma GCC diagnostic pop
        }
    \end{colorblock}

    
    \subsection{A note of methodology}
    
    Combing 10 millions lines of C++ code is a difficult exercice.
    A lexer was used to list pp-token containing \tcode{\$}, that list was analysed manually to exclude asm syatement ad study the context of each occurence.
    This is an error-prone process.
    However it correctly model the scale of the impact on the C++ open-source ecosystem.
    
    \subsection{\$ in name mangling}
    
    Darwin uses \tcode{_\$} in the mangling of swift symbols for versioning
    
    \subsection{\$ in code generators}
    
    \subsection{CMake}
    
    Cmake's \href{https://cmake.org/cmake/help/latest/command/configure_file.html}{\tcode{configure_file}} command (which generate a file in the build directory from a template) will replace \tcode{\${VAR}} by the value of VAR (or by nothing if VAR does not exist)
    This behavior can be disabled by passing \tcode{@ONLY} to the configure command.
    It is important to note that the \tcode{configure_file} command is usually run on specific files that contain little code, usually used to set a set of defines for version number or compile-time configuration. Because CMake doesn't know about C++ it will replace the content of string literals, comments and doesn't expand the preprocessor.
    
    \href{https://build2.org/build2/doc/build2-build-system-manual.xhtml#module-in}{Build 2 uses a similar syntax}.
    
    \subsection{Bison, Yacc}
    
    In bison/yacc, \tcode{\$} followed by a number or another \tcode{\$} is interpreted by the code generator, which doesn't provide a means to escape it.
    However because these tools don't expand the preprocessor, it is possible to introduce a dollar sign in the generated files by introducing a \tcode{\#define} in the preamble:
    
    \begin{colorblock}
        %{
        #define MY_LIB_DOLLAR $
        %}
        %%
        //...
        
        MY_LIB_CONCAT(MY_LIB_DOLLAR, foo);
        
        //...
        
    \end{colorblock}
    
    \subsection{SWIG}
    
    SWIG is another popular generator. It is designed to support a wide range of languages, including Perl and PHP (both of which use dollar sign in identifiers), and as such offers
    a mechanism to escape a \tcode{\$} by using \tcode{\textbackslash \$} instead.
    
    Regardless of the code generator used, the conclusion is the same:
    Introducing a new punctuator would not change the behavior of these code generators for existing code.
    Using that new ponctuator in combination with a code generator that would give it a special meaning can be achieved either by an escape mechanism provided by the tool, if possible or in all cases by the introduction of a macro that would be expanded to that new punctuator.
    We could also consider alternative spelling for that purpose if there is a need.
    
    \section{\textasciigrave Back tick\textasciigrave}
    
    On the mailing list, people expressed concern about using backtick as syntax elements - The only concern (to the best of my knowledge) is that it
    is used in markdown.
    
    However, we found that the following markdown properly renders the backticks (in code font) in all engines tested, including Github, Gitlab, pandoc, a VS code plugin, 3 online markdown editors,
    and discord. This is consistent with the \href{https://spec.commonmark.org/0.29/#code-spans}{CommonMark} specification.
    
    \begin{colorblock}
        `` `test` ``
        
        `test`
        
        ```
        
        `test`
        
        ```
    \end{colorblock}
    
    
    Therefore, using backticks in C++ would not hinder people's ability to use the most popular Markdown renderers, except the inline code block would require more than one backtick.
    
    \section{Other Considerations}
    
    We found no use of \tcode{\$, @ and \textasciigrave} in CUDA, OpenCL, Qt's moc, OpenMP, SYCL, C++/CX.
    
    Some tools, which implement a C++ parser, as is the case for MOC, might however need to be modified to not trip over the new syntax.
    \tcode{moc} itself seems robust enough to not complain about the following code:
    
    \begin{colorblock}
        struct X{
            Q_GADGET
            
            int i = `42`;
            int y = @\atsign@(42);
        };
    \end{colorblock}
    
    \section{Other Programming language}
    
    \begin{itemize}
        \item \tcode{\$} can appear notably in perl, javascript, php, D, rust programs
        \item \tcode{@} can appear in rust, python, java, D
        \item \tcode{\textasciigrave} can appear in Javascript, Raku, Swift
    \end{itemize}
    
    This list is not exhaustive but shows that other languages have been able to adopt these punctuators even when they often use the same code generators as C++, notably SWIG; Or use the same
    documentation tools (notably markdown) as C++ developers.
    
    
    \section{Recommandation}
    
    From this analysis, we conclude that:
    
    \begin{itemize}
        \item Using a lone \tcode{\$} as punctuator would have a non-null but limited impact on existing code, and very little impact on adjacent tools.
        \item Using a \tcode{\$} followed by another symbol such as \tcode{\{}, \tcode{[}, \tcode{(} would have close to no impact on existing code.
        \item It must remain possible to spell a dollar as part of an identifier, This is always the case as \tcode{\$} can be spelled \tcode{\textbackslash u0024}
        \item It must remain possible for implementers to support \tcode{\$} in the non-leading position in identifiers.
        \item Using \tcode{@} would impact objective c++ unless implementers can parse C++ headers included in objective C++ files differently, and we provide alternative spelling (assuming WG21 cares about interoperability between upcoming C++ versions and C++ features and Objective C++)
        \item Backticks can be used in C++
        \item Both \tcode{\$} and \tcode{@} will require to be escaped or macro-expanded if there is a need for them to appear in code produced by code generators.
    \end{itemize}
    
    \section{Should any of these be allowed in identifiers?}
    
    No, this would go against the direction voted in \paper{P1949R6}.
    We should however not preclude implementation to permit it, at least in the middle of identifiers. \tcode{\textbackslash u0024} should continue to work.
    
    \section{Should any of these be allowed in the basic character set?}
    
    The basic character set puts requirements on literal, not source files. This is made more clear by \paper{P2314R0}.
    Therefore the question of whether something can be a punctuator and whether it must be encodable in literals are separate concerns.
    Note that the basic character set is still used to describe a few grammar elements notably escape sequences and raw-string delimiters.
    So for example adding \tcode{\$} to the basic character set would make \tcode{'\textbackslash \$'} a conditionally supported escape sequence,
    and \tcode{R"\$(Hello)\$"} a valid raw string, which may or may not be sensible but are in any case separate concerns.
    
    We note that there is a C proposal \cite{CN2639} that does that.
    
    
    
    \bibliographystyle{plain}
    \bibliography{wg21}
    
    
    \renewcommand{\section}[2]{}%
    \begin{thebibliography}{9}
        \nocite{N4830}
        
        \bibitem{CN2639} 
        Philipp Klaus Krause - N2639: @ in basic source character set
        \url{http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2639.htm}
        
        \bibitem{Javascript}
        ECMAScript® 2022 Language Specification
        \url{https://tc39.es/ecma262/#prod-NoSubstitutionTemplate}
        
        \bibitem{Rust}
        The Rust Reference
        \url{https://doc.rust-lang.org/reference/tokens.html#punctuation}
        
        \bibitem{SWIG}
        SWIG-4.0 Documentation
        \url{http://www.swig.org/Doc4.0/SWIGDocumentation.html}
        
        \bibitem{Bison}
        Bison Documentation
        \url{https://www.gnu.org/software/bison/manual/html_node/index.html}
        
        \bibitem{ObjectiveCLiterals}
        Clang Documentation
        \url{https://clang.llvm.org/docs/ObjectiveCLiterals.html}
        
    \end{thebibliography}    
\end{document}
