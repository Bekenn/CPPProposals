% !TeX program = luatex
% !TEX encoding = UTF-8


\RequirePackage{luatex85}%
\documentclass{wg21}

\usepackage{xcolor}
\usepackage{soul}
\usepackage{ulem}
\usepackage{fullpage}
\usepackage{parskip}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{makecell}
\usepackage{longtable}
\usepackage{graphicx}
\usepackage{amssymb}
\RequirePackage{fontspec}
\usepackage{newunicodechar}
\usepackage{url}

% \setmonofont{Inconsolatazi4}
\setmainfont{Noto Serif}
\usepackage{csquotes}

\lstset{language=C++,
    keywordstyle=\ttfamily,
    stringstyle=\ttfamily,
    commentstyle=\ttfamily,
    morecomment=[l][]{\#},
    morekeywords={reflexpr,valueof,exprid,typeof, concept,constexpr,consteval,unqualid}
}


\lstdefinestyle{color}{language=C++,
        keywordstyle=\color{blue}\ttfamily,
        stringstyle=\color{red}\ttfamily,
        commentstyle=\color{OliveGreen}\ttfamily,
        morecomment=[l][\color{magenta}]{\#},
        morekeywords={reflexpr,valueof,exprid,typeof, concept,constexpr,consteval,unqualid, static\_assert}
}




\title{\tcode{std::generator}: Synchronous Coroutine Generator for Ranges}
\docnumber{P2168R0}
\audience{LEWG}
\author{Lewis Baker}{lbaker@fb.com }
\authortwo{Corentin Jabot}{corentin.jabot@gmail.com}

\begin{document}
\maketitle


\section{Abstract}

We propose a standard library type \tcode{std::generator} which implements a coroutine generator compatible with ranges.

\section{Example}
\begin{lstlisting}[style=color]

std::generator<int> fib (int max) {
    co_yield 0;
    auto a = 0, b = 1;
    
    for(auto n : std::views::iota(0, max))  {
        auto next = a + b;
        a = b, b = next;
        co_yield next;
    }
}

int answer_to_the_universe() {
    auto coro = fib(7) ;
    return std::accumulate(coro | std::views::drop(5), 0);
}

\end{lstlisting}

\section{Motivation}

C++ 20 had a very minimalist library support for coroutines.
Synchronous generators are an important use case for coroutines, one that cannot be supported without 
the machinery presented in this paper.
Writing an efficient and correctly behaving recursive generator is non-trivial, the standard should provide one.

 
\section{Design}

While the proposed \tcode{std::generator} interface is fairly straight-forward, a few decisions are worth pointing out.

\subsection{\tcode{input_view}}

\tcode{std::generator} is a non-copyable \tcode{view} which models \tcode{input_range} and spawn move-only iterators.
This is because the coroutine frame is a unique resource (even if the coroutine \textit{handle} is copyable).
Unfortunately, some generators can satisfy the \tcode{view} constraints but fail to model the \tcode{view} O(1) 
destruction requirement:

\begin{lstlisting}[style=color]

template <typename T>
std::generator<T> all (vector<T> vec) {
    for(auto & e : vec)  {
        co_yield e;
    }
}

\end{lstlisting}



\subsection{Header}

Multiple options are available as to where put the \tcode{generator} class.

\begin{itemize}
\item \tcode{<coroutine>}, but \tcode{<coroutine>} is a low level header, and \tcode{generator} depends on bits of \tcode{<type_traits>} and \tcode{<iterator>}.

\item \tcode{<ranges>}

\item A new \tcode{<generator>}

\end{itemize}

\subsection{Value Type}

This proposal supports specifying both the "yielded" type, which is the iterator ""reference"" type ( not need to be a reference) and its corresponding value type.
This allow ranges to handle proxy types and wrapped \tcode{reference}, like this implementation of zip:

\begin{lstlisting}[style=color]
template<typename Rng1, typename Rng2>
generator<
    std::tuple<range_reference_t<Rng1>, range_reference_t<Rng2>,
    std::tuple<range_value_type_t<Rng1>, range_value_type_t<Rng2>
>
zip(Rng1 r1, Rng2 r2) {
    auto it1 = begin(r1);
    auto it2 = begin(r2);
    auto end1 = end(r1);
    auto end2 = end(r2);
    while (it1 != end1 && it2 != end2) {
        co_yield {*it1++, *it2++};
    }
}
\end{lstlisting}


\subsection{Recursive generator}

\tcode{generator} can call other generators of the same type, including recursively.
For the caller perspective, this produces a range of values.

\begin{lstlisting}[style=color]
generator<int> idiota(uint n) {
    if(n != 0) {
        co_yield idiota(n - 1);
        co_yield n;
    }   
}
\end{lstlisting}

This can be implemented efficiently with symmetric transfer.
Earlier works \cite{CppCoro} implemented this feature in a distinct \tcode{recursive_generator} type.

However, it appears that a single type is reasonably efficient thanks to HALO optimizations and symmetric transfer.
The memory cost of that feature is 3 extra pointers per generator.
It is difficult to evaluate the runtime cost of our design given the current coroutine support in compilers.
However our tests show no noticeable difference between a \tcode{generator} and a \tcode{recursive_generator} 
which is called non recursively. It is worth noting that the proposed design makes sure that HALO \cite{P0981R0} optimizations are possible.

While we think a \tcode{single} generator type is sufficient, and offer a better API, there are three options:

\begin{itemize}
\item A single type supporting recursive calls

\item A separate type \tcode{recursive_generator} that can yield values from either \tcode{recursive_generator} or a \tcode{generator}. That may offer very negligible performance benefits, same memory usage.

\tcode A separate {recursive_generator} type which can only yield values from other \tcode{recursive_generator}. 

That third option would make the following ill-formed:

\begin{lstlisting}[style=color]
generator<int> f();
recursive_generator<int> g() {
    co_yield f(); // incompatible types
}
\end{lstlisting}

As such we do not recommend that option.

\end{itemize}

\section{Future Work}

A-non throwing default allocator with a noexcept generator function should
permit not to force the cost of exceptions on users of this type.  

\section{Implementation and experience}

\tcode{generator} has been provided as part of cppcoro and folly.
However, cppcoro offers a separate \tcode{recursive_generator} type, which is different than the proposed design.

Folly uses a single \tcode{generator} type which can be recursive but doesn't implement symmetric transfer. Despite that,
Folly users found the use of \tcode{Folly:::Generator} to be a lot more efficient than the eager algorithm they replaced with it.

\tcode{ranges-v3} also implements a \tcode{generator} type, which is never recursive and predates the work on move-only views and
iterators \cite{P1456R1}, \cite{P1207R0} which forces this implementation to ref-count the coroutine handler.

Our implementation \cite{Implementation} consists of a single type which takes advantage of symmetric transfer to implement
recursion efficiently.

\section{Wording}

The following wording is meant to illustrate the proposed API.


\rSec2[coroutine.syn]{Header \tcode{<coroutine>} synopsis}

[...]

\begin{codeblock}
    
namespace std {

\end{codeblock}  

\begin{addedblock}
\begin{codeblock}  
template<typename Y, typename V  = std::remove_cvref_t<Y>>
class generator;

template <typename Y, typename V>
inline constexpr bool ranges::enable_view<generator<Y, V>> = true;

\end{codeblock}
\end{addedblock}
\begin{codeblock}
    
}
\end{codeblock}

\begin{addedblock}


\rSec2[coroutine.generator]{Generator View}

\rSec3[coroutine.generator.overview]{Overview}


\tcode{generator} produces an \tcode{input_view} over a synchronous coroutine function yielding values.

\begin{example}
\begin{codeblock}
generator<int> iota(int start = 0) {
    while(true)
        co_yield start++;
}

void f() {
    for(auto i : iota() | views::take(3))
        cout << i << " " ; // prints 0 1 2
}

\end{codeblock}
\end{example}

\rSec3[coroutine.generator.class]{Class template \tcode{generator}}

\begin{codeblock}
    
namespace std {

template <typename Y, typename V = std::remove_cvref_t<Y>>
class generator  {
    
    class promise_type;
    class iterator;
    class sentinel {};
    
    std::coroutine_handle<promise_type> coroutine_ = nullptr; // \expos
    
    
    explicit generator(std::coroutine_handle<promise_type> coroutine) noexcept
    : coroutine_(coroutine) {}
    
public:
    generator() = default;
    generator(const generator &other) = delete;
    generator(generator && other)
        :coroutine_(exchange(other.coroutine_, nullptr)){}
    
    ~generator() {
       if (coroutine_) {
           coroutine_.destroy();
       }
    }
    
    generator &operator=(generator && other) noexcept {
        swap(other);
        return *this;
    }
    
    iterator begin();
    sentinel end() noexcept
    { return {};  }
    
    void swap(generator & other) noexcept {
        std::swap(coroutine_, other.coroutine_);
    }

};
\end{codeblock}

\begin{itemdecl}
iterator begin();
\end{itemdecl}

\begin{itemdescr}
    \precondition \tcode{coroutine_} refers to a suspended coroutine. 

    \effects
    Equivalent to:
    \begin{codeblock}
        if(coroutine_)
            coroutine_.resume();
        return iterator{coroutine_)};
    \end{codeblock}

\begin{note}
    This function can only be called once
\end{note}

\end{itemdescr}


\rSec3[coroutine.generator.promise]{Class template \tcode{generator::promise_type}}

\begin{codeblock}

template <typename Y, typename V>
class generator::promise_type {
   
    friend generator;     
    
public:
    using value_type = V;
    using reference  = Y;
    
    std::coroutine_handle<promise_type> get_return_object() noexcept;
    
    std::suspend_always initial_suspend() const {
        return {};
    }
    auto final_suspend() const;

    std::suspend_always
    yield_value(std::remove_reference_t<reference> && value) noexcept;
    
    std::suspend_always
    yield_value(std::remove_reference_t<reference> &value) noexcept;
    
    auto yield_value(generator&& g) noexcept; // \seebelownc
    
    reference value() const;

    void await_transform() = delete;
    
    void return_void() noexcept {}
    
    void unhandled_exception();
};  
\end{codeblock}

\begin{itemdecl}
std::coroutine_handle<promise_type> get_return_object() noexcept;
\end{itemdecl}

\begin{itemdescr}
    \effects
    Equivalent to:
    \begin{codeblock}
        return generator{
            std::coroutine_handle<promise_type>::from_promise(*this)};
    \end{codeblock}
\end{itemdescr}


\begin{itemdecl}
std::suspend_always
yield_value(std::remove_reference_t<reference>) noexcept;
std::suspend_always
yield_value(std::remove_reference_t<reference> &value) noexcept;
\end{itemdecl}


\begin{itemdescr}
\effects
Store a reference to \tcode{value} in the coroutine frame.
\end{itemdescr}


\begin{itemdecl}
auto yield_value(generator&& g) noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects
This function returns an implementation defined \tcode{awaitable} type which takes ownership of the generator \tcode{g}.

\begin{note}
This ensures that coroutine frames and continuation are destroyed in the reverse order of their creation.
\end{note} 


Execution is transferred to the coroutine represented by  \tcode{g.coroutine_} until its completion. 
After \tcode{g.coroutine_} completes, the current coroutine is resumed.


\begin{note}
Generators can transfer control recursively.
\end{note} 

\end{itemdescr}


\begin{itemdecl}
reference value() const;
\end{itemdecl}

\begin{itemdescr}
\effects
Returns the value previously set by a call to \tcode{yield_value}.

If the execution control has been transferred from this promise to another \tcode{generator}, \tcode{value}
returns the value set on the promise associated with that generator instead.

\begin{note}
Generators can transfer control recursively, \tcode{value} returns the value set on promise associated to the child-most generator coroutine. 
\end{note} 
    
\end{itemdescr}


\rSec3[coroutine.generator.iterator]{Class template \tcode{generator::iterator}}

\begin{codeblock}

template <typename Y, typename V>
class generator::iterator {
private:
    std::coroutine_handle<promise_type> coroutine_ = nullptr;
    
    
public:    
    using iterator_category = std::input_iterator_tag;
    using difference_type = std::ptrdiff_t;
    using value_type = promise_type::value_type;
    using reference = promise_type::reference;
    
    iterator() noexcept = default;
    iterator(const iterator &) = delete;
    
    
    iterator(iterator && other) noexcept
    : coroutine_(exchange(other.coroutine_, nullptr)) {}
       
    iterator &operator=(iterator &&other) noexcept {
        coroutine_ = exchange(other.coroutine_, nullptr);
    }
    
    explicit iterator(std::coroutine_handle<promise_type> coroutine) noexcept
    : coroutine_(coroutine) {}
    
    bool operator==(sentinel) const noexcept {
         return !coroutine_ || coroutine_.done();
    }
    
    iterator &operator++();
    void operator++(int);
    
    reference operator*() const noexcept;
    reference operator->() const noexcept requires std::is_reference_v<reference>;
    
}; 

\end{codeblock}

\begin{itemdecl}
iterator &operator++();
\end{itemdecl}

\begin{itemdescr}
    \precondition \tcode{coroutine_ \&\& !coroutine_.done()} is \tcode{true}.
    
    \effects
    Equivalent to:
    \begin{codeblock}
     m_coroutine.resume();
     return *this;
    \end{codeblock}
\end{itemdescr}


\begin{itemdecl}
void operator++(int);
\end{itemdecl}

\begin{itemdescr}
    \precondition \tcode{coroutine_ \&\& !coroutine_.done()} is \tcode{true}.
    
    \effects
    Equivalent to:
    \begin{codeblock}
         (void)operator++();
    \end{codeblock}
\end{itemdescr}


\begin{itemdecl}
reference operator*() const noexcept;
reference operator->() const noexcept requires std::is_reference_v<reference>;
\end{itemdecl}

\begin{itemdescr}
    \precondition \tcode{coroutine_ \&\& !coroutine_.done()} is \tcode{true}.
    
    \effects
    Equivalent to:
    \begin{codeblock}
        return coroutine_.promise().value();
    \end{codeblock}
\end{itemdescr}



\end{addedblock}
    

\section{References}
\renewcommand{\section}[2]{}%
\bibliographystyle{plain}
\bibliography{../wg21}

\begin{thebibliography}{9}
    \bibitem[CppCoro]{CppCoro}
    Lewis Baker
    \emph{CppCoro: A library of C++ coroutine abstractions for the coroutines TS}\newline
    \url{https://github.com/lewissbaker/cppcoro}
    
    \bibitem[Folly]{Folly}
    Facebook
    \emph{Folly: An open-source C++ library developed and used at Facebook}\newline
    \url{https://github.com/facebook/folly}
    
    
    \bibitem[range]{range-v3}
    Eric Niebler
    \emph{range-v3 Range library for C++14/17/20}\newline
    \url{https://github.com/ericniebler/range-v3}

    
    \bibitem[N4861]{N4861}
    Richard Smith
    \emph{Working Draft, Standard for Programming Language C++}\newline
    \url{https://wg21.link/N4861}
    
    
     \bibitem[Implementation]{Implementation}
    Lewis Baker, Corentin Jabot
    \emph{\tcode{std::generator} implementation}\newline
    \url{https://godbolt.org/z/icfqLr}
    
\end{thebibliography}

\end{document}